import {
  require_jsx_runtime
} from "./chunk-GRWX7YRK.js";
import {
  __toESM,
  require_react
} from "./chunk-I4MZPW7S.js";

// node_modules/@instantdb/core/dist/module/utils/log.js
var isEnabled = false;
if (typeof window !== "undefined" && typeof window.localStorage !== "undefined") {
  isEnabled = !!window.localStorage.getItem("devBackend") || !!window.localStorage.getItem("__instantLogging");
}
var log = {
  info: isEnabled ? console.info.bind(console) : () => {
  },
  debug: isEnabled ? console.debug.bind(console) : () => {
  },
  error: isEnabled ? console.error.bind(console) : () => {
  }
};
var log_default = log;

// node_modules/@instantdb/core/dist/module/utils/weakHash.js
function weakHash(input) {
  if (typeof input === "number") {
    return (Math.abs(input * 2654435761) >>> 0).toString(16);
  }
  if (typeof input === "boolean")
    return input ? "1" : "0";
  if (input === null)
    return "null";
  if (input === void 0)
    return "undefined";
  if (typeof input === "string") {
    let hash = 2166136261;
    for (let i2 = 0; i2 < input.length; i2++) {
      hash ^= input.charCodeAt(i2);
      hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
      hash = hash >>> 0;
    }
    return hash.toString(16);
  }
  if (Array.isArray(input)) {
    let hash = 2166136261;
    for (let i2 = 0; i2 < input.length; i2++) {
      hash ^= (i2 + 1) * 2654435761;
      const elementHash = weakHash(input[i2]);
      for (let j = 0; j < elementHash.length; j++) {
        hash ^= elementHash.charCodeAt(j);
        hash *= 16777619;
        hash = hash >>> 0;
      }
    }
    return hash.toString(16);
  }
  if (typeof input === "object") {
    let hash = 2166136261;
    const keys = Object.keys(input).sort();
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      const keyHash = weakHash(key);
      hash ^= parseInt(keyHash, 16);
      hash *= 16777619;
      hash = hash >>> 0;
      const valueHash = weakHash(input[key]);
      hash ^= parseInt(valueHash, 16);
      hash *= 16777619;
      hash = hash >>> 0;
    }
    return hash.toString(16);
  }
  return weakHash(String(input));
}

// node_modules/mutative/dist/mutative.esm.mjs
var Operation = {
  Remove: "remove",
  Replace: "replace",
  Add: "add"
};
var PROXY_DRAFT = Symbol.for("__MUTATIVE_PROXY_DRAFT__");
var RAW_RETURN_SYMBOL = Symbol("__MUTATIVE_RAW_RETURN_SYMBOL__");
var iteratorSymbol = Symbol.iterator;
var dataTypes = {
  mutable: "mutable",
  immutable: "immutable"
};
var internal = {};
function has(target, key) {
  return target instanceof Map ? target.has(key) : Object.prototype.hasOwnProperty.call(target, key);
}
function getDescriptor(target, key) {
  if (key in target) {
    let prototype = Reflect.getPrototypeOf(target);
    while (prototype) {
      const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);
      if (descriptor)
        return descriptor;
      prototype = Reflect.getPrototypeOf(prototype);
    }
  }
  return;
}
function isBaseSetInstance(obj) {
  return Object.getPrototypeOf(obj) === Set.prototype;
}
function isBaseMapInstance(obj) {
  return Object.getPrototypeOf(obj) === Map.prototype;
}
function latest(proxyDraft) {
  var _a;
  return (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original;
}
function isDraft(target) {
  return !!getProxyDraft(target);
}
function getProxyDraft(value) {
  if (typeof value !== "object")
    return null;
  return value === null || value === void 0 ? void 0 : value[PROXY_DRAFT];
}
function getValue(value) {
  var _a;
  const proxyDraft = getProxyDraft(value);
  return proxyDraft ? (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original : value;
}
function isDraftable(value, options) {
  if (!value || typeof value !== "object")
    return false;
  let markResult;
  return Object.getPrototypeOf(value) === Object.prototype || Array.isArray(value) || value instanceof Map || value instanceof Set || !!(options === null || options === void 0 ? void 0 : options.mark) && ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable || typeof markResult === "function");
}
function getPath(target, path = []) {
  if (Object.hasOwnProperty.call(target, "key")) {
    const parentCopy = target.parent.copy;
    const proxyDraft = getProxyDraft(get(parentCopy, target.key));
    if (proxyDraft !== null && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== target.original) {
      return null;
    }
    const isSet = target.parent.type === 3;
    const key = isSet ? Array.from(target.parent.setMap.keys()).indexOf(target.key) : target.key;
    if (!(isSet && parentCopy.size > key || has(parentCopy, key)))
      return null;
    path.push(key);
  }
  if (target.parent) {
    return getPath(target.parent, path);
  }
  path.reverse();
  try {
    resolvePath(target.copy, path);
  } catch (e) {
    return null;
  }
  return path;
}
function getType(target) {
  if (Array.isArray(target))
    return 1;
  if (target instanceof Map)
    return 2;
  if (target instanceof Set)
    return 3;
  return 0;
}
function get(target, key) {
  return getType(target) === 2 ? target.get(key) : target[key];
}
function set(target, key, value) {
  const type = getType(target);
  if (type === 2) {
    target.set(key, value);
  } else {
    target[key] = value;
  }
}
function peek(target, key) {
  const state = getProxyDraft(target);
  const source = state ? latest(state) : target;
  return source[key];
}
function isEqual(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function revokeProxy(proxyDraft) {
  if (!proxyDraft)
    return;
  while (proxyDraft.finalities.revoke.length > 0) {
    const revoke = proxyDraft.finalities.revoke.pop();
    revoke();
  }
}
function escapePath(path, pathAsArray) {
  return pathAsArray ? path : [""].concat(path).map((_item) => {
    const item = `${_item}`;
    if (item.indexOf("/") === -1 && item.indexOf("~") === -1)
      return item;
    return item.replace(/~/g, "~0").replace(/\//g, "~1");
  }).join("/");
}
function resolvePath(base, path) {
  for (let index = 0; index < path.length - 1; index += 1) {
    const key = path[index];
    base = get(getType(base) === 3 ? Array.from(base) : base, key);
    if (typeof base !== "object") {
      throw new Error(`Cannot resolve patch at '${path.join("/")}'.`);
    }
  }
  return base;
}
function strictCopy(target) {
  const copy = Object.create(Object.getPrototypeOf(target));
  Reflect.ownKeys(target).forEach((key) => {
    let desc = Reflect.getOwnPropertyDescriptor(target, key);
    if (desc.enumerable && desc.configurable && desc.writable) {
      copy[key] = target[key];
      return;
    }
    if (!desc.writable) {
      desc.writable = true;
      desc.configurable = true;
    }
    if (desc.get || desc.set)
      desc = {
        configurable: true,
        writable: true,
        enumerable: desc.enumerable,
        value: target[key]
      };
    Reflect.defineProperty(copy, key, desc);
  });
  return copy;
}
var propIsEnum = Object.prototype.propertyIsEnumerable;
function shallowCopy(original, options) {
  let markResult;
  if (Array.isArray(original)) {
    return Array.prototype.concat.call(original);
  } else if (original instanceof Set) {
    if (!isBaseSetInstance(original)) {
      const SubClass = Object.getPrototypeOf(original).constructor;
      return new SubClass(original.values());
    }
    return Set.prototype.difference ? Set.prototype.difference.call(original, /* @__PURE__ */ new Set()) : new Set(original.values());
  } else if (original instanceof Map) {
    if (!isBaseMapInstance(original)) {
      const SubClass = Object.getPrototypeOf(original).constructor;
      return new SubClass(original);
    }
    return new Map(original);
  } else if ((options === null || options === void 0 ? void 0 : options.mark) && (markResult = options.mark(original, dataTypes), markResult !== void 0) && markResult !== dataTypes.mutable) {
    if (markResult === dataTypes.immutable) {
      return strictCopy(original);
    } else if (typeof markResult === "function") {
      if (options.enablePatches || options.enableAutoFreeze) {
        throw new Error(`You can't use mark and patches or auto freeze together.`);
      }
      return markResult();
    }
    throw new Error(`Unsupported mark result: ${markResult}`);
  } else if (typeof original === "object" && Object.getPrototypeOf(original) === Object.prototype) {
    const copy = {};
    Object.keys(original).forEach((key) => {
      copy[key] = original[key];
    });
    Object.getOwnPropertySymbols(original).forEach((key) => {
      if (propIsEnum.call(original, key)) {
        copy[key] = original[key];
      }
    });
    return copy;
  } else {
    throw new Error(`Please check mark() to ensure that it is a stable marker draftable function.`);
  }
}
function ensureShallowCopy(target) {
  if (target.copy)
    return;
  target.copy = shallowCopy(target.original, target.options);
}
function deepClone(target) {
  if (!isDraftable(target))
    return getValue(target);
  if (Array.isArray(target))
    return target.map(deepClone);
  if (target instanceof Map) {
    const iterable = Array.from(target.entries()).map(([k, v]) => [
      k,
      deepClone(v)
    ]);
    if (!isBaseMapInstance(target)) {
      const SubClass = Object.getPrototypeOf(target).constructor;
      return new SubClass(iterable);
    }
    return new Map(iterable);
  }
  if (target instanceof Set) {
    const iterable = Array.from(target).map(deepClone);
    if (!isBaseSetInstance(target)) {
      const SubClass = Object.getPrototypeOf(target).constructor;
      return new SubClass(iterable);
    }
    return new Set(iterable);
  }
  const copy = Object.create(Object.getPrototypeOf(target));
  for (const key in target)
    copy[key] = deepClone(target[key]);
  return copy;
}
function cloneIfNeeded(target) {
  return isDraft(target) ? deepClone(target) : target;
}
function markChanged(proxyDraft) {
  var _a;
  proxyDraft.assignedMap = (_a = proxyDraft.assignedMap) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Map();
  if (!proxyDraft.operated) {
    proxyDraft.operated = true;
    if (proxyDraft.parent) {
      markChanged(proxyDraft.parent);
    }
  }
}
function throwFrozenError() {
  throw new Error("Cannot modify frozen object");
}
function deepFreeze(target, subKey, updatedValues, stack, keys) {
  {
    updatedValues = updatedValues !== null && updatedValues !== void 0 ? updatedValues : /* @__PURE__ */ new WeakMap();
    stack = stack !== null && stack !== void 0 ? stack : [];
    keys = keys !== null && keys !== void 0 ? keys : [];
    const value = updatedValues.has(target) ? updatedValues.get(target) : target;
    if (stack.length > 0) {
      const index = stack.indexOf(value);
      if (value && typeof value === "object" && index !== -1) {
        if (stack[0] === value) {
          throw new Error(`Forbids circular reference`);
        }
        throw new Error(`Forbids circular reference: ~/${keys.slice(0, index).map((key, index2) => {
          if (typeof key === "symbol")
            return `[${key.toString()}]`;
          const parent = stack[index2];
          if (typeof key === "object" && (parent instanceof Map || parent instanceof Set))
            return Array.from(parent.keys()).indexOf(key);
          return key;
        }).join("/")}`);
      }
      stack.push(value);
      keys.push(subKey);
    } else {
      stack.push(value);
    }
  }
  if (Object.isFrozen(target) || isDraft(target)) {
    {
      stack.pop();
      keys.pop();
    }
    return;
  }
  const type = getType(target);
  switch (type) {
    case 2:
      for (const [key, value] of target) {
        deepFreeze(key, key, updatedValues, stack, keys);
        deepFreeze(value, key, updatedValues, stack, keys);
      }
      target.set = target.clear = target.delete = throwFrozenError;
      break;
    case 3:
      for (const value of target) {
        deepFreeze(value, value, updatedValues, stack, keys);
      }
      target.add = target.clear = target.delete = throwFrozenError;
      break;
    case 1:
      Object.freeze(target);
      let index = 0;
      for (const value of target) {
        deepFreeze(value, index, updatedValues, stack, keys);
        index += 1;
      }
      break;
    default:
      Object.freeze(target);
      Object.keys(target).forEach((name) => {
        const value = target[name];
        deepFreeze(value, name, updatedValues, stack, keys);
      });
  }
  {
    stack.pop();
    keys.pop();
  }
}
function forEach(target, iter) {
  const type = getType(target);
  if (type === 0) {
    Reflect.ownKeys(target).forEach((key) => {
      iter(key, target[key], target);
    });
  } else if (type === 1) {
    let index = 0;
    for (const entry of target) {
      iter(index, entry, target);
      index += 1;
    }
  } else {
    target.forEach((entry, index) => iter(index, entry, target));
  }
}
function handleValue(target, handledSet, options) {
  if (isDraft(target) || !isDraftable(target, options) || handledSet.has(target) || Object.isFrozen(target))
    return;
  const isSet = target instanceof Set;
  const setMap = isSet ? /* @__PURE__ */ new Map() : void 0;
  handledSet.add(target);
  forEach(target, (key, value) => {
    var _a;
    if (isDraft(value)) {
      const proxyDraft = getProxyDraft(value);
      ensureShallowCopy(proxyDraft);
      const updatedValue = ((_a = proxyDraft.assignedMap) === null || _a === void 0 ? void 0 : _a.size) || proxyDraft.operated ? proxyDraft.copy : proxyDraft.original;
      set(isSet ? setMap : target, key, updatedValue);
    } else {
      handleValue(value, handledSet, options);
    }
  });
  if (setMap) {
    const set2 = target;
    const values = Array.from(set2);
    set2.clear();
    values.forEach((value) => {
      set2.add(setMap.has(value) ? setMap.get(value) : value);
    });
  }
}
function finalizeAssigned(proxyDraft, key) {
  const copy = proxyDraft.type === 3 ? proxyDraft.setMap : proxyDraft.copy;
  if (proxyDraft.finalities.revoke.length > 1 && proxyDraft.assignedMap.get(key) && copy) {
    handleValue(get(copy, key), proxyDraft.finalities.handledSet, proxyDraft.options);
  }
}
function finalizeSetValue(target) {
  if (target.type === 3 && target.copy) {
    target.copy.clear();
    target.setMap.forEach((value) => {
      target.copy.add(getValue(value));
    });
  }
}
function finalizePatches(target, generatePatches2, patches, inversePatches) {
  const shouldFinalize = target.operated && target.assignedMap && target.assignedMap.size > 0 && !target.finalized;
  if (shouldFinalize) {
    if (patches && inversePatches) {
      const basePath = getPath(target);
      if (basePath) {
        generatePatches2(target, basePath, patches, inversePatches);
      }
    }
    target.finalized = true;
  }
}
function markFinalization(target, key, value, generatePatches2) {
  const proxyDraft = getProxyDraft(value);
  if (proxyDraft) {
    if (!proxyDraft.callbacks) {
      proxyDraft.callbacks = [];
    }
    proxyDraft.callbacks.push((patches, inversePatches) => {
      var _a;
      const copy = target.type === 3 ? target.setMap : target.copy;
      if (isEqual(get(copy, key), value)) {
        let updatedValue = proxyDraft.original;
        if (proxyDraft.copy) {
          updatedValue = proxyDraft.copy;
        }
        finalizeSetValue(target);
        finalizePatches(target, generatePatches2, patches, inversePatches);
        if (target.options.enableAutoFreeze) {
          target.options.updatedValues = (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new WeakMap();
          target.options.updatedValues.set(updatedValue, proxyDraft.original);
        }
        set(copy, key, updatedValue);
      }
    });
    if (target.options.enableAutoFreeze) {
      if (proxyDraft.finalities !== target.finalities) {
        target.options.enableAutoFreeze = false;
      }
    }
  }
  if (isDraftable(value, target.options)) {
    target.finalities.draft.push(() => {
      const copy = target.type === 3 ? target.setMap : target.copy;
      if (isEqual(get(copy, key), value)) {
        finalizeAssigned(target, key);
      }
    });
  }
}
function generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray) {
  let { original, assignedMap, options } = proxyState;
  let copy = proxyState.copy;
  if (copy.length < original.length) {
    [original, copy] = [copy, original];
    [patches, inversePatches] = [inversePatches, patches];
  }
  for (let index = 0; index < original.length; index += 1) {
    if (assignedMap.get(index.toString()) && copy[index] !== original[index]) {
      const _path = basePath.concat([index]);
      const path = escapePath(_path, pathAsArray);
      patches.push({
        op: Operation.Replace,
        path,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: cloneIfNeeded(copy[index])
      });
      inversePatches.push({
        op: Operation.Replace,
        path,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: cloneIfNeeded(original[index])
      });
    }
  }
  for (let index = original.length; index < copy.length; index += 1) {
    const _path = basePath.concat([index]);
    const path = escapePath(_path, pathAsArray);
    patches.push({
      op: Operation.Add,
      path,
      // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
      value: cloneIfNeeded(copy[index])
    });
  }
  if (original.length < copy.length) {
    const { arrayLengthAssignment = true } = options.enablePatches;
    if (arrayLengthAssignment) {
      const _path = basePath.concat(["length"]);
      const path = escapePath(_path, pathAsArray);
      inversePatches.push({
        op: Operation.Replace,
        path,
        value: original.length
      });
    } else {
      for (let index = copy.length; original.length < index; index -= 1) {
        const _path = basePath.concat([index - 1]);
        const path = escapePath(_path, pathAsArray);
        inversePatches.push({
          op: Operation.Remove,
          path
        });
      }
    }
  }
}
function generatePatchesFromAssigned({ original, copy, assignedMap }, basePath, patches, inversePatches, pathAsArray) {
  assignedMap.forEach((assignedValue, key) => {
    const originalValue = get(original, key);
    const value = cloneIfNeeded(get(copy, key));
    const op = !assignedValue ? Operation.Remove : has(original, key) ? Operation.Replace : Operation.Add;
    if (isEqual(originalValue, value) && op === Operation.Replace)
      return;
    const _path = basePath.concat(key);
    const path = escapePath(_path, pathAsArray);
    patches.push(op === Operation.Remove ? { op, path } : { op, path, value });
    inversePatches.push(op === Operation.Add ? { op: Operation.Remove, path } : op === Operation.Remove ? { op: Operation.Add, path, value: originalValue } : { op: Operation.Replace, path, value: originalValue });
  });
}
function generateSetPatches({ original, copy }, basePath, patches, inversePatches, pathAsArray) {
  let index = 0;
  original.forEach((value) => {
    if (!copy.has(value)) {
      const _path = basePath.concat([index]);
      const path = escapePath(_path, pathAsArray);
      patches.push({
        op: Operation.Remove,
        path,
        value
      });
      inversePatches.unshift({
        op: Operation.Add,
        path,
        value
      });
    }
    index += 1;
  });
  index = 0;
  copy.forEach((value) => {
    if (!original.has(value)) {
      const _path = basePath.concat([index]);
      const path = escapePath(_path, pathAsArray);
      patches.push({
        op: Operation.Add,
        path,
        value
      });
      inversePatches.unshift({
        op: Operation.Remove,
        path,
        value
      });
    }
    index += 1;
  });
}
function generatePatches(proxyState, basePath, patches, inversePatches) {
  const { pathAsArray = true } = proxyState.options.enablePatches;
  switch (proxyState.type) {
    case 0:
    case 2:
      return generatePatchesFromAssigned(proxyState, basePath, patches, inversePatches, pathAsArray);
    case 1:
      return generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray);
    case 3:
      return generateSetPatches(proxyState, basePath, patches, inversePatches, pathAsArray);
  }
}
var readable = false;
var checkReadable = (value, options, ignoreCheckDraftable = false) => {
  if (typeof value === "object" && value !== null && (!isDraftable(value, options) || ignoreCheckDraftable) && !readable) {
    throw new Error(`Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`);
  }
};
var mapHandler = {
  get size() {
    const current2 = latest(getProxyDraft(this));
    return current2.size;
  },
  has(key) {
    return latest(getProxyDraft(this)).has(key);
  },
  set(key, value) {
    const target = getProxyDraft(this);
    const source = latest(target);
    if (!source.has(key) || !isEqual(source.get(key), value)) {
      ensureShallowCopy(target);
      markChanged(target);
      target.assignedMap.set(key, true);
      target.copy.set(key, value);
      markFinalization(target, key, value, generatePatches);
    }
    return this;
  },
  delete(key) {
    if (!this.has(key)) {
      return false;
    }
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    markChanged(target);
    if (target.original.has(key)) {
      target.assignedMap.set(key, false);
    } else {
      target.assignedMap.delete(key);
    }
    target.copy.delete(key);
    return true;
  },
  clear() {
    const target = getProxyDraft(this);
    if (!this.size)
      return;
    ensureShallowCopy(target);
    markChanged(target);
    target.assignedMap = /* @__PURE__ */ new Map();
    for (const [key] of target.original) {
      target.assignedMap.set(key, false);
    }
    target.copy.clear();
  },
  forEach(callback, thisArg) {
    const target = getProxyDraft(this);
    latest(target).forEach((_value, _key) => {
      callback.call(thisArg, this.get(_key), _key, this);
    });
  },
  get(key) {
    var _a, _b;
    const target = getProxyDraft(this);
    const value = latest(target).get(key);
    const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;
    if (target.options.strict) {
      checkReadable(value, target.options, mutable);
    }
    if (mutable) {
      return value;
    }
    if (target.finalized || !isDraftable(value, target.options)) {
      return value;
    }
    if (value !== target.original.get(key)) {
      return value;
    }
    const draft = internal.createDraft({
      original: value,
      parentDraft: target,
      key,
      finalities: target.finalities,
      options: target.options
    });
    ensureShallowCopy(target);
    target.copy.set(key, draft);
    return draft;
  },
  keys() {
    return latest(getProxyDraft(this)).keys();
  },
  values() {
    const iterator = this.keys();
    return {
      [iteratorSymbol]: () => this.values(),
      next: () => {
        const result = iterator.next();
        if (result.done)
          return result;
        const value = this.get(result.value);
        return {
          done: false,
          value
        };
      }
    };
  },
  entries() {
    const iterator = this.keys();
    return {
      [iteratorSymbol]: () => this.entries(),
      next: () => {
        const result = iterator.next();
        if (result.done)
          return result;
        const value = this.get(result.value);
        return {
          done: false,
          value: [result.value, value]
        };
      }
    };
  },
  [iteratorSymbol]() {
    return this.entries();
  }
};
var mapHandlerKeys = Reflect.ownKeys(mapHandler);
var getNextIterator = (target, iterator, { isValuesIterator }) => () => {
  var _a, _b;
  const result = iterator.next();
  if (result.done)
    return result;
  const key = result.value;
  let value = target.setMap.get(key);
  const currentDraft = getProxyDraft(value);
  const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;
  if (target.options.strict) {
    checkReadable(key, target.options, mutable);
  }
  if (!mutable && !currentDraft && isDraftable(key, target.options) && !target.finalized && target.original.has(key)) {
    const proxy = internal.createDraft({
      original: key,
      parentDraft: target,
      key,
      finalities: target.finalities,
      options: target.options
    });
    target.setMap.set(key, proxy);
    value = proxy;
  } else if (currentDraft) {
    value = currentDraft.proxy;
  }
  return {
    done: false,
    value: isValuesIterator ? value : [value, value]
  };
};
var setHandler = {
  get size() {
    const target = getProxyDraft(this);
    return target.setMap.size;
  },
  has(value) {
    const target = getProxyDraft(this);
    if (target.setMap.has(value))
      return true;
    ensureShallowCopy(target);
    const valueProxyDraft = getProxyDraft(value);
    if (valueProxyDraft && target.setMap.has(valueProxyDraft.original))
      return true;
    return false;
  },
  add(value) {
    const target = getProxyDraft(this);
    if (!this.has(value)) {
      ensureShallowCopy(target);
      markChanged(target);
      target.assignedMap.set(value, true);
      target.setMap.set(value, value);
      markFinalization(target, value, value, generatePatches);
    }
    return this;
  },
  delete(value) {
    if (!this.has(value)) {
      return false;
    }
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    markChanged(target);
    const valueProxyDraft = getProxyDraft(value);
    if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) {
      target.assignedMap.set(valueProxyDraft.original, false);
      return target.setMap.delete(valueProxyDraft.original);
    }
    if (!valueProxyDraft && target.setMap.has(value)) {
      target.assignedMap.set(value, false);
    } else {
      target.assignedMap.delete(value);
    }
    return target.setMap.delete(value);
  },
  clear() {
    if (!this.size)
      return;
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    markChanged(target);
    for (const value of target.original) {
      target.assignedMap.set(value, false);
    }
    target.setMap.clear();
  },
  values() {
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    const iterator = target.setMap.keys();
    return {
      [Symbol.iterator]: () => this.values(),
      next: getNextIterator(target, iterator, { isValuesIterator: true })
    };
  },
  entries() {
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    const iterator = target.setMap.keys();
    return {
      [Symbol.iterator]: () => this.entries(),
      next: getNextIterator(target, iterator, {
        isValuesIterator: false
      })
    };
  },
  keys() {
    return this.values();
  },
  [iteratorSymbol]() {
    return this.values();
  },
  forEach(callback, thisArg) {
    const iterator = this.values();
    let result = iterator.next();
    while (!result.done) {
      callback.call(thisArg, result.value, result.value, this);
      result = iterator.next();
    }
  }
};
if (Set.prototype.difference) {
  Object.assign(setHandler, {
    intersection(other) {
      return Set.prototype.intersection.call(new Set(this.values()), other);
    },
    union(other) {
      return Set.prototype.union.call(new Set(this.values()), other);
    },
    difference(other) {
      return Set.prototype.difference.call(new Set(this.values()), other);
    },
    symmetricDifference(other) {
      return Set.prototype.symmetricDifference.call(new Set(this.values()), other);
    },
    isSubsetOf(other) {
      return Set.prototype.isSubsetOf.call(new Set(this.values()), other);
    },
    isSupersetOf(other) {
      return Set.prototype.isSupersetOf.call(new Set(this.values()), other);
    },
    isDisjointFrom(other) {
      return Set.prototype.isDisjointFrom.call(new Set(this.values()), other);
    }
  });
}
var setHandlerKeys = Reflect.ownKeys(setHandler);
var draftsCache = /* @__PURE__ */ new WeakSet();
var proxyHandler = {
  get(target, key, receiver) {
    var _a, _b;
    const copy = (_a = target.copy) === null || _a === void 0 ? void 0 : _a[key];
    if (copy && draftsCache.has(copy)) {
      return copy;
    }
    if (key === PROXY_DRAFT)
      return target;
    let markResult;
    if (target.options.mark) {
      const value2 = key === "size" && (target.original instanceof Map || target.original instanceof Set) ? Reflect.get(target.original, key) : Reflect.get(target.original, key, receiver);
      markResult = target.options.mark(value2, dataTypes);
      if (markResult === dataTypes.mutable) {
        if (target.options.strict) {
          checkReadable(value2, target.options, true);
        }
        return value2;
      }
    }
    const source = latest(target);
    if (source instanceof Map && mapHandlerKeys.includes(key)) {
      if (key === "size") {
        return Object.getOwnPropertyDescriptor(mapHandler, "size").get.call(target.proxy);
      }
      const handle = mapHandler[key];
      if (handle) {
        return handle.bind(target.proxy);
      }
    }
    if (source instanceof Set && setHandlerKeys.includes(key)) {
      if (key === "size") {
        return Object.getOwnPropertyDescriptor(setHandler, "size").get.call(target.proxy);
      }
      const handle = setHandler[key];
      if (handle) {
        return handle.bind(target.proxy);
      }
    }
    if (!has(source, key)) {
      const desc = getDescriptor(source, key);
      return desc ? `value` in desc ? desc.value : (
        // !case: support for getter
        (_b = desc.get) === null || _b === void 0 ? void 0 : _b.call(target.proxy)
      ) : void 0;
    }
    const value = source[key];
    if (target.options.strict) {
      checkReadable(value, target.options);
    }
    if (target.finalized || !isDraftable(value, target.options)) {
      return value;
    }
    if (value === peek(target.original, key)) {
      ensureShallowCopy(target);
      target.copy[key] = createDraft({
        original: target.original[key],
        parentDraft: target,
        key: target.type === 1 ? Number(key) : key,
        finalities: target.finalities,
        options: target.options
      });
      if (typeof markResult === "function") {
        const subProxyDraft = getProxyDraft(target.copy[key]);
        ensureShallowCopy(subProxyDraft);
        markChanged(subProxyDraft);
        return subProxyDraft.copy;
      }
      return target.copy[key];
    }
    return value;
  },
  set(target, key, value) {
    var _a;
    if (target.type === 3 || target.type === 2) {
      throw new Error(`Map/Set draft does not support any property assignment.`);
    }
    let _key;
    if (target.type === 1 && key !== "length" && !(Number.isInteger(_key = Number(key)) && _key >= 0 && (key === 0 || _key === 0 || String(_key) === String(key)))) {
      throw new Error(`Only supports setting array indices and the 'length' property.`);
    }
    const desc = getDescriptor(latest(target), key);
    if (desc === null || desc === void 0 ? void 0 : desc.set) {
      desc.set.call(target.proxy, value);
      return true;
    }
    const current2 = peek(latest(target), key);
    const currentProxyDraft = getProxyDraft(current2);
    if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {
      target.copy[key] = value;
      target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Map();
      target.assignedMap.set(key, false);
      return true;
    }
    if (isEqual(value, current2) && (value !== void 0 || has(target.original, key)))
      return true;
    ensureShallowCopy(target);
    markChanged(target);
    if (has(target.original, key) && isEqual(value, target.original[key])) {
      target.assignedMap.delete(key);
    } else {
      target.assignedMap.set(key, true);
    }
    target.copy[key] = value;
    markFinalization(target, key, value, generatePatches);
    return true;
  },
  has(target, key) {
    return key in latest(target);
  },
  ownKeys(target) {
    return Reflect.ownKeys(latest(target));
  },
  getOwnPropertyDescriptor(target, key) {
    const source = latest(target);
    const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
    if (!descriptor)
      return descriptor;
    return {
      writable: true,
      configurable: target.type !== 1 || key !== "length",
      enumerable: descriptor.enumerable,
      value: source[key]
    };
  },
  getPrototypeOf(target) {
    return Reflect.getPrototypeOf(target.original);
  },
  setPrototypeOf() {
    throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);
  },
  defineProperty() {
    throw new Error(`Cannot call 'defineProperty()' on drafts`);
  },
  deleteProperty(target, key) {
    var _a;
    if (target.type === 1) {
      return proxyHandler.set.call(this, target, key, void 0, target.proxy);
    }
    if (peek(target.original, key) !== void 0 || key in target.original) {
      ensureShallowCopy(target);
      markChanged(target);
      target.assignedMap.set(key, false);
    } else {
      target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Map();
      target.assignedMap.delete(key);
    }
    if (target.copy)
      delete target.copy[key];
    return true;
  }
};
function createDraft(createDraftOptions) {
  const { original, parentDraft, key, finalities, options } = createDraftOptions;
  const type = getType(original);
  const proxyDraft = {
    type,
    finalized: false,
    parent: parentDraft,
    original,
    copy: null,
    proxy: null,
    finalities,
    options,
    // Mapping of draft Set items to their corresponding draft values.
    setMap: type === 3 ? new Map(original.entries()) : void 0
  };
  if (key || "key" in createDraftOptions) {
    proxyDraft.key = key;
  }
  const { proxy, revoke } = Proxy.revocable(type === 1 ? Object.assign([], proxyDraft) : proxyDraft, proxyHandler);
  finalities.revoke.push(revoke);
  draftsCache.add(proxy);
  proxyDraft.proxy = proxy;
  if (parentDraft) {
    const target = parentDraft;
    target.finalities.draft.push((patches, inversePatches) => {
      var _a, _b;
      const oldProxyDraft = getProxyDraft(proxy);
      let copy = target.type === 3 ? target.setMap : target.copy;
      const draft = get(copy, key);
      const proxyDraft2 = getProxyDraft(draft);
      if (proxyDraft2) {
        let updatedValue = proxyDraft2.original;
        if (proxyDraft2.operated) {
          updatedValue = getValue(draft);
        }
        finalizeSetValue(proxyDraft2);
        finalizePatches(proxyDraft2, generatePatches, patches, inversePatches);
        if (target.options.enableAutoFreeze) {
          target.options.updatedValues = (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new WeakMap();
          target.options.updatedValues.set(updatedValue, proxyDraft2.original);
        }
        set(copy, key, updatedValue);
      }
      (_b = oldProxyDraft.callbacks) === null || _b === void 0 ? void 0 : _b.forEach((callback) => {
        callback(patches, inversePatches);
      });
    });
  } else {
    const target = getProxyDraft(proxy);
    target.finalities.draft.push((patches, inversePatches) => {
      finalizeSetValue(target);
      finalizePatches(target, generatePatches, patches, inversePatches);
    });
  }
  return proxy;
}
internal.createDraft = createDraft;
function finalizeDraft(result, returnedValue, patches, inversePatches, enableAutoFreeze) {
  var _a;
  const proxyDraft = getProxyDraft(result);
  const original = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : result;
  const hasReturnedValue = !!returnedValue.length;
  if (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated) {
    while (proxyDraft.finalities.draft.length > 0) {
      const finalize = proxyDraft.finalities.draft.pop();
      finalize(patches, inversePatches);
    }
  }
  const state = hasReturnedValue ? returnedValue[0] : proxyDraft ? proxyDraft.operated ? proxyDraft.copy : proxyDraft.original : result;
  if (proxyDraft)
    revokeProxy(proxyDraft);
  if (enableAutoFreeze) {
    deepFreeze(state, state, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options.updatedValues);
  }
  return [
    state,
    patches && hasReturnedValue ? [{ op: Operation.Replace, path: [], value: returnedValue[0] }] : patches,
    inversePatches && hasReturnedValue ? [{ op: Operation.Replace, path: [], value: original }] : inversePatches
  ];
}
function draftify(baseState, options) {
  var _a;
  const finalities = {
    draft: [],
    revoke: [],
    handledSet: /* @__PURE__ */ new WeakSet()
  };
  let patches;
  let inversePatches;
  if (options.enablePatches) {
    patches = [];
    inversePatches = [];
  }
  const isMutable = ((_a = options.mark) === null || _a === void 0 ? void 0 : _a.call(options, baseState, dataTypes)) === dataTypes.mutable || !isDraftable(baseState, options);
  const draft = isMutable ? baseState : createDraft({
    original: baseState,
    parentDraft: null,
    finalities,
    options
  });
  return [
    draft,
    (returnedValue = []) => {
      const [finalizedState, finalizedPatches, finalizedInversePatches] = finalizeDraft(draft, returnedValue, patches, inversePatches, options.enableAutoFreeze);
      return options.enablePatches ? [finalizedState, finalizedPatches, finalizedInversePatches] : finalizedState;
    }
  ];
}
function handleReturnValue(options) {
  const { rootDraft, value, useRawReturn = false, isRoot = true } = options;
  forEach(value, (key, item, source) => {
    const proxyDraft = getProxyDraft(item);
    if (proxyDraft && rootDraft && proxyDraft.finalities === rootDraft.finalities) {
      options.isContainDraft = true;
      const currentValue = proxyDraft.original;
      if (source instanceof Set) {
        const arr = Array.from(source);
        source.clear();
        arr.forEach((_item) => source.add(key === _item ? currentValue : _item));
      } else {
        set(source, key, currentValue);
      }
    } else if (typeof item === "object" && item !== null) {
      options.value = item;
      options.isRoot = false;
      handleReturnValue(options);
    }
  });
  if (isRoot) {
    if (!options.isContainDraft)
      console.warn(`The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`);
    if (useRawReturn) {
      console.warn(`The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`);
    }
  }
}
function getCurrent(target) {
  var _a;
  const proxyDraft = getProxyDraft(target);
  if (!isDraftable(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options))
    return target;
  const type = getType(target);
  if (proxyDraft && !proxyDraft.operated)
    return proxyDraft.original;
  let currentValue;
  function ensureShallowCopy2() {
    currentValue = type === 2 ? !isBaseMapInstance(target) ? new (Object.getPrototypeOf(target)).constructor(target) : new Map(target) : type === 3 ? Array.from(proxyDraft.setMap.values()) : shallowCopy(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options);
  }
  if (proxyDraft) {
    proxyDraft.finalized = true;
    try {
      ensureShallowCopy2();
    } finally {
      proxyDraft.finalized = false;
    }
  } else {
    currentValue = target;
  }
  forEach(currentValue, (key, value) => {
    if (proxyDraft && isEqual(get(proxyDraft.original, key), value))
      return;
    const newValue = getCurrent(value);
    if (newValue !== value) {
      if (currentValue === target)
        ensureShallowCopy2();
      set(currentValue, key, newValue);
    }
  });
  if (type === 3) {
    const value = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : currentValue;
    return !isBaseSetInstance(value) ? new (Object.getPrototypeOf(value)).constructor(currentValue) : new Set(currentValue);
  }
  return currentValue;
}
function current(target) {
  if (!isDraft(target)) {
    throw new Error(`current() is only used for Draft, parameter: ${target}`);
  }
  return getCurrent(target);
}
var makeCreator = (arg) => {
  if (arg !== void 0 && Object.prototype.toString.call(arg) !== "[object Object]") {
    throw new Error(`Invalid options: ${String(arg)}, 'options' should be an object.`);
  }
  return function create2(arg0, arg1, arg2) {
    var _a, _b, _c;
    if (typeof arg0 === "function" && typeof arg1 !== "function") {
      return function(base2, ...args) {
        return create2(base2, (draft2) => arg0.call(this, draft2, ...args), arg1);
      };
    }
    const base = arg0;
    const mutate = arg1;
    let options = arg2;
    if (typeof arg1 !== "function") {
      options = arg1;
    }
    if (options !== void 0 && Object.prototype.toString.call(options) !== "[object Object]") {
      throw new Error(`Invalid options: ${options}, 'options' should be an object.`);
    }
    options = Object.assign(Object.assign({}, arg), options);
    const state = isDraft(base) ? current(base) : base;
    const mark = Array.isArray(options.mark) ? (value, types) => {
      for (const mark2 of options.mark) {
        if (typeof mark2 !== "function") {
          throw new Error(`Invalid mark: ${mark2}, 'mark' should be a function.`);
        }
        const result2 = mark2(value, types);
        if (result2) {
          return result2;
        }
      }
      return;
    } : options.mark;
    const enablePatches = (_a = options.enablePatches) !== null && _a !== void 0 ? _a : false;
    const strict = (_b = options.strict) !== null && _b !== void 0 ? _b : false;
    const enableAutoFreeze = (_c = options.enableAutoFreeze) !== null && _c !== void 0 ? _c : false;
    const _options = {
      enableAutoFreeze,
      mark,
      strict,
      enablePatches
    };
    if (!isDraftable(state, _options) && typeof state === "object" && state !== null) {
      throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
    }
    const [draft, finalize] = draftify(state, _options);
    if (typeof arg1 !== "function") {
      if (!isDraftable(state, _options)) {
        throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
      }
      return [draft, finalize];
    }
    let result;
    try {
      result = mutate(draft);
    } catch (error) {
      revokeProxy(getProxyDraft(draft));
      throw error;
    }
    const returnValue = (value) => {
      const proxyDraft = getProxyDraft(draft);
      if (!isDraft(value)) {
        if (value !== void 0 && !isEqual(value, draft) && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated)) {
          throw new Error(`Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`);
        }
        const rawReturnValue = value === null || value === void 0 ? void 0 : value[RAW_RETURN_SYMBOL];
        if (rawReturnValue) {
          const _value = rawReturnValue[0];
          if (_options.strict && typeof value === "object" && value !== null) {
            handleReturnValue({
              rootDraft: proxyDraft,
              value,
              useRawReturn: true
            });
          }
          return finalize([_value]);
        }
        if (value !== void 0) {
          if (typeof value === "object" && value !== null) {
            handleReturnValue({ rootDraft: proxyDraft, value });
          }
          return finalize([value]);
        }
      }
      if (value === draft || value === void 0) {
        return finalize([]);
      }
      const returnedProxyDraft = getProxyDraft(value);
      if (_options === returnedProxyDraft.options) {
        if (returnedProxyDraft.operated) {
          throw new Error(`Cannot return a modified child draft.`);
        }
        return finalize([current(value)]);
      }
      return finalize([value]);
    };
    if (result instanceof Promise) {
      return result.then(returnValue, (error) => {
        revokeProxy(getProxyDraft(draft));
        throw error;
      });
    }
    return returnValue(result);
  };
};
var create = makeCreator();
var constructorString = Object.prototype.constructor.toString();

// node_modules/@instantdb/core/dist/module/utils/object.js
function areObjectKeysEqual(a, b) {
  const ak = Object.keys(a);
  const bk = Object.keys(b);
  return ak.length === bk.length && Object.keys(a).every((k) => b.hasOwnProperty(k));
}
function areObjectsShallowEqual(obj1, obj2) {
  return Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key) => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);
}
function areObjectsDeepEqual(obj1, obj2) {
  if (typeof obj1 !== "object" || typeof obj2 !== "object" || obj1 === null || obj2 === null) {
    return obj1 === obj2;
  }
  if (!areObjectKeysEqual(obj1, obj2)) {
    return false;
  }
  return Object.keys(obj1).every((key) => areObjectsDeepEqual(obj1[key], obj2[key]));
}
function immutableDeepMerge(target, source) {
  if (!isObject(target) || !isObject(source)) {
    return source;
  }
  const result = {};
  for (const key of Object.keys(target)) {
    if (source[key] === null)
      continue;
    result[key] = target[key];
  }
  for (const key of Object.keys(source)) {
    if (source[key] === null)
      continue;
    const areBothObjects = isObject(target[key]) && isObject(source[key]);
    result[key] = areBothObjects ? immutableDeepMerge(target[key], source[key]) : source[key];
  }
  return result;
}
function immutableDeepReplace(target, replaceValue, replacementValue) {
  if (!isObject(target)) {
    return target;
  }
  const result = {};
  for (const [key, value] of Object.entries(target)) {
    result[key] = isObject(value) ? immutableDeepReplace(value, replaceValue, replacementValue) : value === replaceValue ? replacementValue : value;
  }
  return result;
}
function isObject(val) {
  return typeof val === "object" && val !== null && !Array.isArray(val);
}

// node_modules/@instantdb/core/dist/module/store.js
function hasEA(attr) {
  return attr["cardinality"] === "one";
}
function isRef(attr) {
  return attr["value-type"] === "ref";
}
function isBlob(attr) {
  return attr["value-type"] === "blob";
}
function getAttr(attrs, attrId) {
  return attrs[attrId];
}
function getInMap(obj, path) {
  return path.reduce((acc, key) => acc && acc.get(key), obj);
}
function deleteInMap(m, path) {
  if (path.length === 0)
    throw new Error("path must have at least one element");
  if (path.length === 1) {
    m.delete(path[0]);
    return;
  }
  const [head, ...tail] = path;
  if (!m.has(head))
    return;
  deleteInMap(m.get(head), tail);
}
function setInMap(m, path, value) {
  if (path.length === 0)
    throw new Error("path must have at least one element");
  if (path.length === 1) {
    m.set(path[0], value);
    return;
  }
  const [head, ...tail] = path;
  let nextM = m.get(head);
  if (!nextM) {
    nextM = /* @__PURE__ */ new Map();
    m.set(head, nextM);
  }
  setInMap(nextM, tail, value);
}
function createTripleIndexes(attrs, triples) {
  const eav = /* @__PURE__ */ new Map();
  const aev = /* @__PURE__ */ new Map();
  const vae = /* @__PURE__ */ new Map();
  for (const triple of triples) {
    const [eid, aid, v, t] = triple;
    const attr = getAttr(attrs, aid);
    if (!attr) {
      console.warn("no such attr", eid, attrs);
      continue;
    }
    if (isRef(attr)) {
      setInMap(vae, [v, aid, eid], triple);
    }
    setInMap(eav, [eid, aid, v], triple);
    setInMap(aev, [aid, eid, v], triple);
  }
  return { eav, aev, vae };
}
function createAttrIndexes(attrs) {
  const blobAttrs = /* @__PURE__ */ new Map();
  const primaryKeys = /* @__PURE__ */ new Map();
  const forwardIdents = /* @__PURE__ */ new Map();
  const revIdents = /* @__PURE__ */ new Map();
  for (const attr of Object.values(attrs)) {
    const fwdIdent = attr["forward-identity"];
    const [_, fwdEtype, fwdLabel] = fwdIdent;
    const revIdent = attr["reverse-identity"];
    setInMap(forwardIdents, [fwdEtype, fwdLabel], attr);
    if (isBlob(attr)) {
      setInMap(blobAttrs, [fwdEtype, fwdLabel], attr);
    }
    if (attr["primary?"]) {
      setInMap(primaryKeys, [fwdEtype], attr);
    }
    if (revIdent) {
      const [_2, revEtype, revLabel] = revIdent;
      setInMap(revIdents, [revEtype, revLabel], attr);
    }
  }
  return { blobAttrs, primaryKeys, forwardIdents, revIdents };
}
function toJSON(store) {
  return {
    __type: store.__type,
    attrs: store.attrs,
    triples: allMapValues(store.eav, 3),
    cardinalityInference: store.cardinalityInference,
    linkIndex: store.linkIndex
  };
}
function fromJSON(storeJSON) {
  return createStore(storeJSON.attrs, storeJSON.triples, storeJSON.cardinalityInference, storeJSON.linkIndex);
}
function resetAttrIndexes(store) {
  store.attrIndexes = createAttrIndexes(store.attrs);
}
function createStore(attrs, triples, enableCardinalityInference, linkIndex) {
  const store = createTripleIndexes(attrs, triples);
  store.attrs = attrs;
  store.attrIndexes = createAttrIndexes(attrs);
  store.cardinalityInference = enableCardinalityInference;
  store.linkIndex = linkIndex;
  store.__type = "store";
  return store;
}
function resolveLookupRefs(store, triple) {
  var _a, _b;
  let eid;
  if (Array.isArray(triple[0])) {
    const [a, v] = triple[0];
    const eMaps = store.aev.get(a);
    if (!eMaps) {
      return null;
    }
    const triples = allMapValues(eMaps, 2);
    eid = (_a = triples.find((x) => x[2] === v)) === null || _a === void 0 ? void 0 : _a[0];
  } else {
    eid = triple[0];
  }
  if (!eid) {
    return null;
  }
  const lookupV = triple[2];
  if (Array.isArray(lookupV) && lookupV.length === 2 && store.aev.get(lookupV[0])) {
    const [a, v] = lookupV;
    const eMaps = store.aev.get(a);
    if (!eMaps) {
      return null;
    }
    const triples = allMapValues(eMaps, 2);
    const value = (_b = triples.find((x) => x[2] === v)) === null || _b === void 0 ? void 0 : _b[0];
    if (!value) {
      return null;
    }
    const [_e, aid, _v, ...rest] = triple;
    return [eid, aid, value, ...rest];
  } else {
    const [_, ...rest] = triple;
    return [eid, ...rest];
  }
}
function retractTriple(store, rawTriple) {
  const triple = resolveLookupRefs(store, rawTriple);
  if (!triple) {
    return;
  }
  const [eid, aid, v] = triple;
  const attr = getAttr(store.attrs, aid);
  if (!attr) {
    return;
  }
  deleteInMap(store.eav, [eid, aid, v]);
  deleteInMap(store.aev, [aid, eid, v]);
  if (isRef(attr)) {
    deleteInMap(store.vae, [v, aid, eid]);
  }
}
var _seed = 0;
function getCreatedAt(store, attr, triple) {
  const [eid, aid, v] = triple;
  let createdAt;
  const t = getInMap(store.ea, [eid, aid, v]);
  if (t) {
    createdAt = t[3];
  }
  return createdAt || Date.now() * 10 + _seed++;
}
function addTriple(store, rawTriple) {
  var _a;
  const triple = resolveLookupRefs(store, rawTriple);
  if (!triple) {
    return;
  }
  const [eid, aid, v] = triple;
  const attr = getAttr(store.attrs, aid);
  if (!attr) {
    return;
  }
  const existingTriple = getInMap(store.eav, [eid, aid, v]);
  const t = (_a = existingTriple === null || existingTriple === void 0 ? void 0 : existingTriple[3]) !== null && _a !== void 0 ? _a : getCreatedAt(store, attr, triple);
  const enhancedTriple = [eid, aid, v, t];
  if (hasEA(attr)) {
    setInMap(store.eav, [eid, aid], /* @__PURE__ */ new Map([[v, enhancedTriple]]));
    setInMap(store.aev, [aid, eid], /* @__PURE__ */ new Map([[v, enhancedTriple]]));
  } else {
    setInMap(store.eav, [eid, aid, v], enhancedTriple);
    setInMap(store.aev, [aid, eid, v], enhancedTriple);
  }
  if (isRef(attr)) {
    setInMap(store.vae, [v, aid, eid], enhancedTriple);
  }
}
function mergeTriple(store, rawTriple) {
  var _a;
  const triple = resolveLookupRefs(store, rawTriple);
  if (!triple) {
    return;
  }
  const [eid, aid, update] = triple;
  const attr = getAttr(store.attrs, aid);
  if (!attr)
    return;
  if (!isBlob(attr))
    throw new Error("merge operation is not supported for links");
  const eavValuesMap = getInMap(store.eav, [eid, aid]);
  if (!eavValuesMap)
    return;
  const currentTriple = (_a = eavValuesMap.values().next()) === null || _a === void 0 ? void 0 : _a.value;
  if (!currentTriple)
    return;
  const currentValue = currentTriple[2];
  const updatedValue = immutableDeepMerge(currentValue, update);
  const enhancedTriple = [
    eid,
    aid,
    updatedValue,
    getCreatedAt(store, attr, currentTriple)
  ];
  setInMap(store.eav, [eid, aid], /* @__PURE__ */ new Map([[updatedValue, enhancedTriple]]));
}
function deleteEntity(store, args) {
  var _a, _b;
  const [lookup2, etype] = args;
  const triple = resolveLookupRefs(store, [lookup2]);
  if (!triple) {
    return;
  }
  const [id2] = triple;
  const eMap = store.eav.get(id2);
  if (eMap) {
    for (const a of eMap.keys()) {
      const attr = store.attrs[a];
      if (
        // Fall back to deleting everything if we've rehydrated tx-steps from
        // the store that didn't set `etype` in deleteEntity
        !etype || // If we don't know about the attr, let's just get rid of it
        !attr || // Make sure it matches the etype
        ((_a = attr["forward-identity"]) === null || _a === void 0 ? void 0 : _a[1]) === etype
      ) {
        deleteInMap(store.aev, [a, id2]);
        deleteInMap(store.eav, [id2, a]);
      }
    }
    if (eMap.size === 0) {
      deleteInMap(store.eav, [id2]);
    }
  }
  const vaeTriples = store.vae.get(id2) && allMapValues(store.vae.get(id2), 2);
  if (vaeTriples) {
    vaeTriples.forEach((triple2) => {
      var _a2;
      const [e, a, v] = triple2;
      const attr = store.attrs[a];
      if (!etype || !attr || ((_a2 = attr["reverse-identity"]) === null || _a2 === void 0 ? void 0 : _a2[1]) === etype) {
        deleteInMap(store.eav, [e, a, v]);
        deleteInMap(store.aev, [a, e, v]);
        deleteInMap(store.vae, [v, a, e]);
      }
    });
  }
  if (((_b = store.vae.get(id2)) === null || _b === void 0 ? void 0 : _b.size) === 0) {
    deleteInMap(store.vae, [id2]);
  }
}
function resetIndexMap(store, newTriples) {
  const newIndexMap = createTripleIndexes(store.attrs, newTriples);
  Object.keys(newIndexMap).forEach((key) => {
    store[key] = newIndexMap[key];
  });
}
function addAttr(store, [attr]) {
  store.attrs[attr.id] = attr;
  resetAttrIndexes(store);
}
function getAllTriples(store) {
  return allMapValues(store.eav, 3);
}
function deleteAttr(store, [id2]) {
  if (!store.attrs[id2])
    return;
  const newTriples = getAllTriples(store).filter(([_, aid]) => aid !== id2);
  delete store.attrs[id2];
  resetAttrIndexes(store);
  resetIndexMap(store, newTriples);
}
function updateAttr(store, [partialAttr]) {
  const attr = store.attrs[partialAttr.id];
  if (!attr)
    return;
  store.attrs[partialAttr.id] = Object.assign(Object.assign({}, attr), partialAttr);
  resetAttrIndexes(store);
  resetIndexMap(store, getAllTriples(store));
}
function applyTxStep(store, txStep) {
  const [action, ...args] = txStep;
  switch (action) {
    case "add-triple":
      addTriple(store, args);
      break;
    case "deep-merge-triple":
      mergeTriple(store, args);
      break;
    case "retract-triple":
      retractTriple(store, args);
      break;
    case "delete-entity":
      deleteEntity(store, args);
      break;
    case "add-attr":
      addAttr(store, args);
      break;
    case "delete-attr":
      deleteAttr(store, args);
      break;
    case "update-attr":
      updateAttr(store, args);
      break;
    default:
      throw new Error(`unhandled transaction action: ${action}`);
  }
}
function allMapValues(m, level, res = []) {
  if (!m) {
    return res;
  }
  if (level === 0) {
    return res;
  }
  if (level === 1) {
    for (const v of m.values()) {
      res.push(v);
    }
    return res;
  }
  for (const v of m.values()) {
    allMapValues(v, level - 1, res);
  }
  return res;
}
function triplesByValue(store, m, v) {
  var _a, _b;
  const res = [];
  if (v === null || v === void 0 ? void 0 : v.hasOwnProperty("$not")) {
    for (const candidate of m.keys()) {
      if (v.$not !== candidate) {
        res.push(m.get(candidate));
      }
    }
    return res;
  }
  if (v === null || v === void 0 ? void 0 : v.hasOwnProperty("$isNull")) {
    const { attrId, isNull, reverse } = v.$isNull;
    if (reverse) {
      for (const candidate of m.keys()) {
        const vMap = store.vae.get(candidate);
        const isValNull = !vMap || ((_a = vMap.get(attrId)) === null || _a === void 0 ? void 0 : _a.get(null)) || !vMap.get(attrId);
        if (isNull ? isValNull : !isValNull) {
          res.push(m.get(candidate));
        }
      }
    } else {
      const aMap = store.aev.get(attrId);
      for (const candidate of m.keys()) {
        const isValNull = !aMap || ((_b = aMap.get(candidate)) === null || _b === void 0 ? void 0 : _b.get(null)) || !aMap.get(candidate);
        if (isNull ? isValNull : !isValNull) {
          res.push(m.get(candidate));
        }
      }
    }
    return res;
  }
  if (v === null || v === void 0 ? void 0 : v.$comparator) {
    return allMapValues(m, 1).filter(v.$op);
  }
  const values = v.in || v.$in || [v];
  for (const value of values) {
    const triple = m.get(value);
    if (triple) {
      res.push(triple);
    }
  }
  return res;
}
function whichIdx(e, a, v) {
  let res = "";
  if (e !== void 0) {
    res += "e";
  }
  if (a !== void 0) {
    res += "a";
  }
  if (v !== void 0) {
    res += "v";
  }
  return res;
}
function getTriples(store, [e, a, v]) {
  var _a, _b;
  const idx = whichIdx(e, a, v);
  switch (idx) {
    case "e": {
      const eMap = store.eav.get(e);
      return allMapValues(eMap, 2);
    }
    case "ea": {
      const aMap = (_a = store.eav.get(e)) === null || _a === void 0 ? void 0 : _a.get(a);
      return allMapValues(aMap, 1);
    }
    case "eav": {
      const aMap = (_b = store.eav.get(e)) === null || _b === void 0 ? void 0 : _b.get(a);
      if (!aMap) {
        return [];
      }
      return triplesByValue(store, aMap, v);
    }
    case "ev": {
      const eMap = store.eav.get(e);
      if (!eMap) {
        return [];
      }
      const res = [];
      for (const aMap of eMap.values()) {
        res.push(...triplesByValue(store, aMap, v));
      }
      return res;
    }
    case "a": {
      const aMap = store.aev.get(a);
      return allMapValues(aMap, 2);
    }
    case "av": {
      const aMap = store.aev.get(a);
      if (!aMap) {
        return [];
      }
      const res = [];
      for (const eMap of aMap.values()) {
        res.push(...triplesByValue(store, eMap, v));
      }
      return res;
    }
    case "v": {
      const res = [];
      for (const eMap of store.eav.values()) {
        for (const aMap of eMap.values()) {
          res.push(...triplesByValue(store, aMap, v));
        }
      }
    }
    default: {
      return allMapValues(store.eav, 3);
    }
  }
}
function getAsObject(store, etype, e) {
  var _a;
  const blobAttrs = store.attrIndexes.blobAttrs.get(etype);
  const obj = {};
  for (const [label, attr] of blobAttrs.entries()) {
    const aMap = (_a = store.eav.get(e)) === null || _a === void 0 ? void 0 : _a.get(attr.id);
    const triples = allMapValues(aMap, 1);
    for (const triple of triples) {
      obj[label] = triple[2];
    }
  }
  return obj;
}
function getAttrByFwdIdentName(store, inputEtype, inputLabel) {
  var _a;
  return (_a = store.attrIndexes.forwardIdents.get(inputEtype)) === null || _a === void 0 ? void 0 : _a.get(inputLabel);
}
function getAttrByReverseIdentName(store, inputEtype, inputLabel) {
  var _a;
  return (_a = store.attrIndexes.revIdents.get(inputEtype)) === null || _a === void 0 ? void 0 : _a.get(inputLabel);
}
function getPrimaryKeyAttr(store, etype) {
  var _a;
  const fromPrimary = store.attrIndexes.primaryKeys.get(etype);
  if (fromPrimary) {
    return fromPrimary;
  }
  return (_a = store.attrIndexes.forwardIdents.get(etype)) === null || _a === void 0 ? void 0 : _a.get("id");
}
function transact(store, txSteps) {
  return create(store, (draft) => {
    txSteps.forEach((txStep) => {
      applyTxStep(draft, txStep);
    });
  });
}

// node_modules/@instantdb/core/dist/module/datalog.js
function isVariable(x) {
  return typeof x === "string" && x.startsWith("?");
}
function matchVariable(variable, triplePart, context) {
  if (context.hasOwnProperty(variable)) {
    const bound = context[variable];
    return matchPart(bound, triplePart, context);
  }
  return Object.assign(Object.assign({}, context), { [variable]: triplePart });
}
function matchExact(patternPart, triplePart, context) {
  return patternPart === triplePart ? context : null;
}
function matcherForPatternPart(patternPart) {
  switch (typeof patternPart) {
    case "string":
      return patternPart.startsWith("?") ? matchVariable : matchExact;
    default:
      return matchExact;
  }
}
var validArgMapProps = [
  "in",
  "$in",
  "$not",
  "$isNull",
  "$comparator"
  // covers all of $gt, $lt, etc.
];
function isArgsMap(patternPart) {
  for (const prop of validArgMapProps) {
    if (patternPart.hasOwnProperty(prop)) {
      return true;
    }
  }
  return false;
}
function matchPart(patternPart, triplePart, context) {
  if (!context)
    return null;
  if (typeof patternPart === "object") {
    if (isArgsMap(patternPart)) {
      return context;
    }
    return null;
  }
  const matcher = matcherForPatternPart(patternPart);
  return matcher(patternPart, triplePart, context);
}
function matchPattern(pattern, triple, context) {
  return pattern.reduce((context2, patternPart, idx) => {
    const triplePart = triple[idx];
    return matchPart(patternPart, triplePart, context2);
  }, context);
}
function querySingle(store, pattern, context) {
  return relevantTriples(store, pattern, context).map((triple) => matchPattern(pattern, triple, context)).filter((x) => x);
}
function queryPattern(store, pattern, contexts) {
  if (pattern.or) {
    return pattern.or.patterns.flatMap((patterns) => {
      return queryWhere(store, patterns, contexts);
    });
  }
  if (pattern.and) {
    return pattern.and.patterns.reduce((contexts2, patterns) => {
      return queryWhere(store, patterns, contexts2);
    }, contexts);
  }
  return contexts.flatMap((context) => querySingle(store, pattern, context));
}
function queryWhere(store, patterns, contexts = [{}]) {
  return patterns.reduce((contexts2, pattern) => {
    return queryPattern(store, pattern, contexts2);
  }, contexts);
}
function actualize(context, find) {
  if (Array.isArray(find)) {
    return find.map((findPart) => actualize(context, findPart));
  }
  return isVariable(find) ? context[find] : find;
}
function query(store, { find, where }) {
  const contexts = queryWhere(store, where);
  return contexts.map((context) => actualize(context, find));
}
function relevantTriples(store, pattern, context) {
  return getTriples(store, actualize(context, pattern));
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i2 = 0; i2 < str.length; ++i2) {
    bytes.push(str.charCodeAt(i2));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version3, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version3;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = bytes[i2];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i2 = 0; i2 < msg.length; ++i2) {
      bytes[i2] = msg.charCodeAt(i2);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i2 = 0; i2 < length32; i2 += 8) {
    const x = input[i2 >> 5] >>> i2 % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i2 = 0; i2 < x.length; i2 += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i2], 7, -680876936);
    d = md5ff(d, a, b, c, x[i2 + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i2 + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i2 + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i2 + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i2 + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i2 + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i2 + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i2 + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i2 + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i2 + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i2 + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i2 + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i2 + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i2 + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i2 + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i2 + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i2 + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i2 + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i2], 20, -373897302);
    a = md5gg(a, b, c, d, x[i2 + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i2 + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i2 + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i2 + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i2 + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i2 + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i2 + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i2 + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i2 + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i2 + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i2 + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i2 + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i2 + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i2 + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i2 + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i2 + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i2 + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i2 + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i2 + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i2 + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i2 + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i2], 11, -358537222);
    c = md5hh(c, d, a, b, x[i2 + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i2 + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i2 + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i2 + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i2 + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i2 + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i2], 6, -198630844);
    d = md5ii(d, a, b, c, x[i2 + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i2 + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i2 + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i2 + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i2 + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i2 + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i2 + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i2 + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i2 + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i2 + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i2 + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i2 + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i2 + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i2 + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i2 + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i2 = 0; i2 < length8; i2 += 8) {
    output[i2 >> 5] |= (input[i2 / 8] & 255) << i2 % 32;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i2 = 0; i2 < msg.length; ++i2) {
      bytes.push(msg.charCodeAt(i2));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i2 = 0; i2 < N; ++i2) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i2 * 64 + j * 4] << 24 | bytes[i2 * 64 + j * 4 + 1] << 16 | bytes[i2 * 64 + j * 4 + 2] << 8 | bytes[i2 * 64 + j * 4 + 3];
    }
    M[i2] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i2 = 0; i2 < N; ++i2) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i2][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@instantdb/core/dist/module/utils/uuid.js
function uuidToByteArray(uuid) {
  const hex = uuid.replace(/-/g, "");
  const bytes = [];
  for (let i2 = 0; i2 < hex.length; i2 += 2) {
    bytes.push(parseInt(hex.substring(i2, i2 + 2), 16));
  }
  return bytes;
}
function compareByteArrays(a, b) {
  for (let i2 = 0; i2 < a.length; i2++) {
    if (a[i2] < b[i2])
      return -1;
    if (a[i2] > b[i2])
      return 1;
  }
  return 0;
}
function uuidCompare(uuid_a, uuid_b) {
  return compareByteArrays(uuidToByteArray(uuid_a), uuidToByteArray(uuid_b));
}
function id() {
  return v4_default();
}
var uuid_default = id;

// node_modules/@instantdb/core/dist/module/instaql.js
var _seed2 = 0;
function wildcard(friendlyName) {
  return makeVarImpl(`_${friendlyName}`, _seed2++);
}
function makeVarImpl(x, level) {
  return `?${x}-${level}`;
}
var AttrNotFoundError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AttrNotFoundError";
  }
};
function idAttr(store, ns) {
  const attr = getPrimaryKeyAttr(store, ns);
  if (!attr) {
    throw new AttrNotFoundError(`Could not find id attr for ${ns}`);
  }
  return attr;
}
function defaultWhere(makeVar, store, etype, level) {
  return [eidWhere(makeVar, store, etype, level)];
}
function eidWhere(makeVar, store, etype, level) {
  return [
    makeVar(etype, level),
    idAttr(store, etype).id,
    makeVar(etype, level),
    makeVar("time", level)
  ];
}
function replaceInAttrPat(attrPat, needle, v) {
  return attrPat.map((x) => x === needle ? v : x);
}
function refAttrPat(makeVar, store, etype, level, label) {
  const fwdAttr = getAttrByFwdIdentName(store, etype, label);
  const revAttr = getAttrByReverseIdentName(store, etype, label);
  const attr = fwdAttr || revAttr;
  if (!attr) {
    throw new AttrNotFoundError(`Could not find attr for ${[etype, label]}`);
  }
  if (attr["value-type"] !== "ref") {
    throw new Error(`Attr ${attr.id} is not a ref`);
  }
  const [_f, fwdEtype] = attr["forward-identity"];
  const [_r, revEtype] = attr["reverse-identity"];
  const nextLevel = level + 1;
  const attrPat = fwdAttr ? [
    makeVar(fwdEtype, level),
    attr.id,
    makeVar(revEtype, nextLevel),
    wildcard("time")
  ] : [
    makeVar(fwdEtype, nextLevel),
    attr.id,
    makeVar(revEtype, level),
    wildcard("time")
  ];
  const nextEtype = fwdAttr ? revEtype : fwdEtype;
  const isForward = Boolean(fwdAttr);
  return [nextEtype, nextLevel, attrPat, attr, isForward];
}
function makeLikeMatcher(caseSensitive, pattern) {
  if (typeof pattern !== "string") {
    return function likeMatcher(_value) {
      return false;
    };
  }
  const regexPattern = pattern.replace(/%/g, ".*").replace(/_/g, ".");
  const regex = new RegExp(`^${regexPattern}$`, caseSensitive ? void 0 : "i");
  return function likeMatcher(value) {
    if (typeof value !== "string") {
      return false;
    }
    return regex.test(value);
  };
}
function parseValue(attr, v) {
  if (typeof v !== "object" || v.hasOwnProperty("$in") || v.hasOwnProperty("in")) {
    return v;
  }
  const isDate = attr["checked-data-type"] === "date";
  if (v.hasOwnProperty("$gt")) {
    return {
      $comparator: true,
      $op: isDate ? function gtDate(triple) {
        return new Date(triple[2]) > new Date(v.$gt);
      } : function gt(triple) {
        return triple[2] > v.$gt;
      }
    };
  }
  if (v.hasOwnProperty("$gte")) {
    return {
      $comparator: true,
      $op: isDate ? function gteDate(triple) {
        return new Date(triple[2]) >= new Date(v.$gte);
      } : function gte(triple) {
        return triple[2] >= v.$gte;
      }
    };
  }
  if (v.hasOwnProperty("$lt")) {
    return {
      $comparator: true,
      $op: isDate ? function ltDate(triple) {
        return new Date(triple[2]) < new Date(v.$lt);
      } : function lt(triple) {
        return triple[2] < v.$lt;
      }
    };
  }
  if (v.hasOwnProperty("$lte")) {
    return {
      $comparator: true,
      $op: isDate ? function lteDate(triple) {
        return new Date(triple[2]) <= new Date(v.$lte);
      } : function lte(triple) {
        return triple[2] <= v.$lte;
      }
    };
  }
  if (v.hasOwnProperty("$like")) {
    const matcher = makeLikeMatcher(true, v.$like);
    return {
      $comparator: true,
      $op: function like(triple) {
        return matcher(triple[2]);
      }
    };
  }
  if (v.hasOwnProperty("$ilike")) {
    const matcher = makeLikeMatcher(false, v.$ilike);
    return {
      $comparator: true,
      $op: function ilike(triple) {
        return matcher(triple[2]);
      }
    };
  }
  return v;
}
function valueAttrPat(makeVar, store, valueEtype, valueLevel, valueLabel, v) {
  const fwdAttr = getAttrByFwdIdentName(store, valueEtype, valueLabel);
  const revAttr = getAttrByReverseIdentName(store, valueEtype, valueLabel);
  const attr = fwdAttr || revAttr;
  if (!attr) {
    throw new AttrNotFoundError(`No attr for etype = ${valueEtype} label = ${valueLabel}`);
  }
  if (v === null || v === void 0 ? void 0 : v.hasOwnProperty("$isNull")) {
    const idAttr2 = getAttrByFwdIdentName(store, valueEtype, "id");
    if (!idAttr2) {
      throw new AttrNotFoundError(`No attr for etype = ${valueEtype} label = id`);
    }
    return [
      makeVar(valueEtype, valueLevel),
      idAttr2.id,
      { $isNull: { attrId: attr.id, isNull: v.$isNull, reverse: !fwdAttr } },
      wildcard("time")
    ];
  }
  if (fwdAttr) {
    return [
      makeVar(valueEtype, valueLevel),
      attr.id,
      parseValue(attr, v),
      wildcard("time")
    ];
  }
  return [v, attr.id, makeVar(valueEtype, valueLevel), wildcard("time")];
}
function refAttrPats(makeVar, store, etype, level, refsPath) {
  const [lastEtype, lastLevel, attrPats] = refsPath.reduce((acc, label) => {
    const [etype2, level2, attrPats2] = acc;
    const [nextEtype, nextLevel, attrPat] = refAttrPat(makeVar, store, etype2, level2, label);
    return [nextEtype, nextLevel, [...attrPats2, attrPat]];
  }, [etype, level, []]);
  return [lastEtype, lastLevel, attrPats];
}
function whereCondAttrPats(makeVar, store, etype, level, path, v) {
  const refsPath = path.slice(0, path.length - 1);
  const valueLabel = path[path.length - 1];
  const [lastEtype, lastLevel, refPats] = refAttrPats(makeVar, store, etype, level, refsPath);
  const valuePat = valueAttrPat(makeVar, store, lastEtype, lastLevel, valueLabel, v);
  return refPats.concat([valuePat]);
}
function withJoin(where, join) {
  return join ? [join].concat(where) : where;
}
function isOrClauses([k, v]) {
  return k === "or" && Array.isArray(v);
}
function isAndClauses([k, v]) {
  return k === "and" && Array.isArray(v);
}
function genMakeVar(baseMakeVar, etype, orIdx) {
  return (x, lvl) => {
    if (x == etype) {
      return baseMakeVar(x, lvl);
    }
    return `${baseMakeVar(x, lvl)}-${orIdx}`;
  };
}
function parseWhereClauses(makeVar, clauseType, store, etype, level, whereValue) {
  const patterns = whereValue.map((w, i2) => {
    const makeNamespacedVar = genMakeVar(makeVar, etype, i2);
    return parseWhere(makeNamespacedVar, store, etype, level, w);
  });
  const joinSym = makeVar(etype, level);
  return { [clauseType]: { patterns, joinSym } };
}
function growPath(path) {
  const ret = [];
  for (let i2 = 1; i2 <= path.length; i2++) {
    ret.push(path.slice(0, i2));
  }
  return ret;
}
function whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path) {
  return growPath(path).map((path2) => whereCondAttrPats(makeVar, store, etype, level, path2, { $isNull: true }));
}
function parseWhere(makeVar, store, etype, level, where) {
  return Object.entries(where).flatMap(([k, v]) => {
    if (isOrClauses([k, v])) {
      return parseWhereClauses(makeVar, "or", store, etype, level, v);
    }
    if (isAndClauses([k, v])) {
      return parseWhereClauses(makeVar, "and", store, etype, level, v);
    }
    const path = k.split(".");
    if (v === null || v === void 0 ? void 0 : v.hasOwnProperty("$not")) {
      const notPats = whereCondAttrPats(makeVar, store, etype, level, path, v);
      const nilPats = whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path);
      return [
        {
          or: {
            patterns: [notPats, ...nilPats],
            joinSym: makeVar(etype, level)
          }
        }
      ];
    }
    if ((v === null || v === void 0 ? void 0 : v.hasOwnProperty("$isNull")) && v.$isNull === true && path.length > 1) {
      return [
        {
          or: {
            patterns: whereCondAttrPatsForNullIsTrue(makeVar, store, etype, level, path),
            joinSym: makeVar(etype, level)
          }
        }
      ];
    }
    return whereCondAttrPats(makeVar, store, etype, level, path, v);
  });
}
function makeWhere(store, etype, level, where) {
  const makeVar = makeVarImpl;
  if (!where) {
    return defaultWhere(makeVar, store, etype, level);
  }
  const parsedWhere = parseWhere(makeVar, store, etype, level, where);
  return parsedWhere.concat(defaultWhere(makeVar, store, etype, level));
}
function makeFind(makeVar, etype, level) {
  return [makeVar(etype, level), makeVar("time", level)];
}
function makeJoin(makeVar, store, etype, level, label, eid) {
  const [nextEtype, nextLevel, pat, attr, isForward] = refAttrPat(makeVar, store, etype, level, label);
  const actualized = replaceInAttrPat(pat, makeVar(etype, level), eid);
  return [nextEtype, nextLevel, actualized, attr, isForward];
}
function extendObjects(makeVar, store, { etype, level, form }, objects) {
  const childQueries = Object.keys(form).filter((c) => c !== "$");
  if (!childQueries.length) {
    return Object.values(objects);
  }
  return Object.entries(objects).map(function extendChildren([eid, parent]) {
    const childResults = childQueries.map(function getChildResult(label) {
      var _a, _b, _c;
      const isSingular = Boolean(store.cardinalityInference && ((_c = (_b = (_a = store.linkIndex) === null || _a === void 0 ? void 0 : _a[etype]) === null || _b === void 0 ? void 0 : _b[label]) === null || _c === void 0 ? void 0 : _c.isSingular));
      try {
        const [nextEtype, nextLevel, join] = makeJoin(makeVar, store, etype, level, label, eid);
        const childrenArray = queryOne(store, {
          etype: nextEtype,
          level: nextLevel,
          form: form[label],
          join
        });
        const childOrChildren = isSingular ? childrenArray[0] : childrenArray;
        return { [label]: childOrChildren };
      } catch (e) {
        if (e instanceof AttrNotFoundError) {
          return { [label]: isSingular ? void 0 : [] };
        }
        throw e;
      }
    });
    return childResults.reduce(function reduceChildren(parent2, child) {
      return Object.assign(Object.assign({}, parent2), child);
    }, parent);
  });
}
function compareOrder([id_a, v_a], [id_b, v_b]) {
  if (v_a === v_b || v_a == null && v_b == null) {
    return uuidCompare(id_a, id_b);
  }
  if (v_b == null) {
    return 1;
  }
  if (v_a == null) {
    return -1;
  }
  if (v_a > v_b) {
    return 1;
  }
  return -1;
}
function comparableDate(x) {
  if (x == null) {
    return x;
  }
  return new Date(x).getTime();
}
function isBefore(startCursor, orderAttr, direction, idVec) {
  var _a;
  const [c_e, _c_a, c_v, c_t] = startCursor;
  const compareVal = direction === "desc" ? 1 : -1;
  if (((_a = orderAttr["forward-identity"]) === null || _a === void 0 ? void 0 : _a[2]) === "id") {
    return compareOrder(idVec, [c_e, c_t]) === compareVal;
  }
  const [e, v] = idVec;
  const v_new = orderAttr["checked-data-type"] === "date" ? comparableDate(v) : v;
  const c_v_new = orderAttr["checked-data-type"] === "date" ? comparableDate(c_v) : c_v;
  return compareOrder([e, v_new], [c_e, c_v_new]) === compareVal;
}
function orderAttrFromCursor(store, cursor) {
  const cursorAttrId = cursor[1];
  return store.attrs[cursorAttrId];
}
function orderAttrFromOrder(store, etype, order) {
  const label = Object.keys(order)[0];
  return getAttrByFwdIdentName(store, etype, label);
}
function getOrderAttr(store, etype, cursor, order) {
  if (cursor) {
    return orderAttrFromCursor(store, cursor);
  }
  if (order) {
    return orderAttrFromOrder(store, etype, order);
  }
}
function runDataloadAndReturnObjects(store, etype, direction, pageInfo, order, dq) {
  var _a;
  let idVecs = query(store, dq);
  const startCursor = pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo["start-cursor"];
  const orderAttr = getOrderAttr(store, etype, startCursor, order);
  if (orderAttr && ((_a = orderAttr === null || orderAttr === void 0 ? void 0 : orderAttr["forward-identity"]) === null || _a === void 0 ? void 0 : _a[2]) !== "id") {
    const isDate = orderAttr["checked-data-type"] === "date";
    const a = orderAttr.id;
    idVecs = idVecs.map(([id2]) => {
      var _a2, _b, _c, _d, _e;
      let v = (_e = (_d = (_c = (_b = (_a2 = store.eav.get(id2)) === null || _a2 === void 0 ? void 0 : _a2.get(a)) === null || _b === void 0 ? void 0 : _b.values()) === null || _c === void 0 ? void 0 : _c.next()) === null || _d === void 0 ? void 0 : _d.value) === null || _e === void 0 ? void 0 : _e[2];
      if (isDate) {
        v = comparableDate(v);
      }
      return [id2, v];
    });
  }
  idVecs.sort(direction === "asc" ? function compareIdVecs(a, b) {
    return compareOrder(a, b);
  } : function compareIdVecs(a, b) {
    return compareOrder(b, a);
  });
  let objects = {};
  for (const idVec of idVecs) {
    const [id2] = idVec;
    if (objects[id2]) {
      continue;
    }
    if (startCursor && orderAttr && isBefore(startCursor, orderAttr, direction, idVec)) {
      continue;
    }
    const obj = getAsObject(store, etype, id2);
    if (obj) {
      objects[id2] = obj;
    }
  }
  return objects;
}
function determineOrder(form) {
  var _a;
  const orderOpts = (_a = form.$) === null || _a === void 0 ? void 0 : _a.order;
  if (!orderOpts) {
    return "asc";
  }
  return orderOpts[Object.keys(orderOpts)[0]] || "asc";
}
function resolveObjects(store, { etype, level, form, join, pageInfo }) {
  var _a, _b, _c, _d, _e, _g, _h, _j;
  const limit = ((_a = form.$) === null || _a === void 0 ? void 0 : _a.limit) || ((_b = form.$) === null || _b === void 0 ? void 0 : _b.first) || ((_c = form.$) === null || _c === void 0 ? void 0 : _c.last);
  const offset = (_d = form.$) === null || _d === void 0 ? void 0 : _d.offset;
  const before = (_e = form.$) === null || _e === void 0 ? void 0 : _e.before;
  const after = (_g = form.$) === null || _g === void 0 ? void 0 : _g.after;
  const order = (_h = form.$) === null || _h === void 0 ? void 0 : _h.order;
  if ((offset || before || after) && (!pageInfo || !pageInfo["start-cursor"])) {
    return [];
  }
  const where = withJoin(makeWhere(store, etype, level, (_j = form.$) === null || _j === void 0 ? void 0 : _j.where), join);
  const find = makeFind(makeVarImpl, etype, level);
  const objs = runDataloadAndReturnObjects(store, etype, determineOrder(form), pageInfo, order, { where, find });
  if (limit != null) {
    const entries = Object.entries(objs);
    if (entries.length <= limit) {
      return objs;
    }
    return Object.fromEntries(entries.slice(0, limit));
  }
  return objs;
}
function guardedResolveObjects(store, opts) {
  try {
    return resolveObjects(store, opts);
  } catch (e) {
    if (e instanceof AttrNotFoundError) {
      return {};
    }
    throw e;
  }
}
function queryOne(store, opts) {
  const objects = guardedResolveObjects(store, opts);
  return extendObjects(makeVarImpl, store, opts, objects);
}
function formatPageInfo(pageInfo) {
  const res = {};
  for (const [k, v] of Object.entries(pageInfo)) {
    res[k] = {
      startCursor: v["start-cursor"],
      endCursor: v["end-cursor"],
      hasNextPage: v["has-next-page?"],
      hasPreviousPage: v["has-previous-page?"]
    };
  }
  return res;
}
function query2({ store, pageInfo, aggregate }, q) {
  const data = Object.keys(q).reduce(function reduceResult(res, k) {
    if (aggregate === null || aggregate === void 0 ? void 0 : aggregate[k]) {
      return res;
    }
    res[k] = queryOne(store, {
      etype: k,
      form: q[k],
      level: 0,
      pageInfo: pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo[k]
    });
    return res;
  }, {});
  const result = { data };
  if (pageInfo) {
    result.pageInfo = formatPageInfo(pageInfo);
  }
  if (aggregate) {
    result.aggregate = aggregate;
  }
  return result;
}

// node_modules/@instantdb/core/dist/module/instatx.js
function transactionChunk(etype, id2, prevOps) {
  return new Proxy({}, {
    get: (_target, cmd) => {
      if (cmd === "__ops")
        return prevOps;
      return (args) => {
        return transactionChunk(etype, id2, [
          ...prevOps,
          [cmd, etype, id2, args]
        ]);
      };
    }
  });
}
function lookup(attribute, value) {
  return `lookup__${attribute}__${JSON.stringify(value)}`;
}
function isLookup(k) {
  return k.startsWith("lookup__");
}
function parseLookup(k) {
  const [_, attribute, ...vJSON] = k.split("__");
  return [attribute, JSON.parse(vJSON.join("__"))];
}
function etypeChunk(etype) {
  return new Proxy({}, {
    get(_target, id2) {
      if (isLookup(id2)) {
        return transactionChunk(etype, parseLookup(id2), []);
      }
      return transactionChunk(etype, id2, []);
    }
  });
}
function txInit() {
  return new Proxy({}, {
    get(_target, ns) {
      return etypeChunk(ns);
    }
  });
}
var tx = txInit();
function getOps(x) {
  return x.__ops;
}

// node_modules/@instantdb/core/dist/module/instaml.js
function rewriteStep(attrMapping, txStep) {
  const { attrIdMap, refSwapAttrIds } = attrMapping;
  const rewritten = [];
  for (const part of txStep) {
    const newValue = attrIdMap[part];
    if (newValue) {
      rewritten.push(newValue);
    } else if (Array.isArray(part) && part.length == 2 && attrIdMap[part[0]]) {
      const [aid, value] = part;
      rewritten.push([attrIdMap[aid], value]);
    } else {
      rewritten.push(part);
    }
  }
  const [action] = txStep;
  if ((action === "add-triple" || action === "retract-triple") && refSwapAttrIds.has(txStep[2])) {
    const tmp = rewritten[1];
    rewritten[1] = rewritten[3];
    rewritten[3] = tmp;
  }
  return rewritten;
}
function getAttrByFwdIdentName2(attrs, inputEtype, inputIdentName) {
  return Object.values(attrs).find((attr) => {
    const [_id, etype, label] = attr["forward-identity"];
    return etype === inputEtype && label === inputIdentName;
  });
}
function getAttrByReverseIdentName2(attrs, inputEtype, inputIdentName) {
  return Object.values(attrs).find((attr) => {
    const revIdent = attr["reverse-identity"];
    if (!revIdent)
      return false;
    const [_id, etype, label] = revIdent;
    return etype === inputEtype && label === inputIdentName;
  });
}
function explodeLookupRef(eid) {
  if (Array.isArray(eid)) {
    return eid;
  }
  const entries = Object.entries(eid);
  if (entries.length !== 1) {
    throw new Error("lookup must be an object with a single unique attr and value.");
  }
  return entries[0];
}
function isRefLookupIdent(attrs, etype, identName) {
  return identName.indexOf(".") !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
  // before assuming it's a ref lookup.
  !getAttrByFwdIdentName2(attrs, etype, identName);
}
function extractRefLookupFwdName(identName) {
  const [fwdName, idIdent, ...rest] = identName.split(".");
  if (rest.length > 0 || idIdent !== "id") {
    throw new Error(`${identName} is not a valid lookup attribute.`);
  }
  return fwdName;
}
function lookupIdentToAttr(attrs, etype, identName) {
  if (!isRefLookupIdent(attrs, etype, identName)) {
    return getAttrByFwdIdentName2(attrs, etype, identName);
  }
  const fwdName = extractRefLookupFwdName(identName);
  const refAttr = getAttrByFwdIdentName2(attrs, etype, fwdName) || getAttrByReverseIdentName2(attrs, etype, fwdName);
  if (refAttr && refAttr["value-type"] !== "ref") {
    throw new Error(`${identName} does not reference a valid link attribute.`);
  }
  return refAttr;
}
function lookupPairOfEid(eid) {
  if (typeof eid === "string" && !isLookup(eid)) {
    return null;
  }
  return typeof eid === "string" && isLookup(eid) ? parseLookup(eid) : explodeLookupRef(eid);
}
function extractLookup(attrs, etype, eid) {
  const lookupPair = lookupPairOfEid(eid);
  if (lookupPair === null) {
    return eid;
  }
  const [identName, value] = lookupPair;
  const attr = lookupIdentToAttr(attrs, etype, identName);
  if (!attr || !attr["unique?"]) {
    throw new Error(`${identName} is not a unique attribute.`);
  }
  return [attr.id, value];
}
function expandLink(attrs, [etype, eidA, obj]) {
  const addTriples = Object.entries(obj).flatMap(([label, eidOrEids]) => {
    const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];
    const fwdAttr = getAttrByFwdIdentName2(attrs, etype, label);
    const revAttr = getAttrByReverseIdentName2(attrs, etype, label);
    return eids.map((eidB) => {
      const txStep = fwdAttr ? [
        "add-triple",
        extractLookup(attrs, etype, eidA),
        fwdAttr.id,
        extractLookup(attrs, fwdAttr["reverse-identity"][1], eidB)
      ] : [
        "add-triple",
        extractLookup(attrs, revAttr["forward-identity"][1], eidB),
        revAttr.id,
        extractLookup(attrs, etype, eidA)
      ];
      return txStep;
    });
  });
  return addTriples;
}
function expandUnlink(attrs, [etype, eidA, obj]) {
  const retractTriples = Object.entries(obj).flatMap(([label, eidOrEids]) => {
    const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];
    const fwdAttr = getAttrByFwdIdentName2(attrs, etype, label);
    const revAttr = getAttrByReverseIdentName2(attrs, etype, label);
    return eids.map((eidB) => {
      const txStep = fwdAttr ? [
        "retract-triple",
        extractLookup(attrs, etype, eidA),
        fwdAttr.id,
        extractLookup(attrs, fwdAttr["reverse-identity"][1], eidB)
      ] : [
        "retract-triple",
        extractLookup(attrs, revAttr["forward-identity"][1], eidB),
        revAttr.id,
        extractLookup(attrs, etype, eidA)
      ];
      return txStep;
    });
  });
  return retractTriples;
}
function expandUpdate(attrs, [etype, eid, obj]) {
  const lookup2 = extractLookup(attrs, etype, eid);
  const attrTuples = [["id", extractLookup(attrs, etype, eid)]].concat(Object.entries(obj)).map(([identName, value]) => {
    const attr = getAttrByFwdIdentName2(attrs, etype, identName);
    return ["add-triple", lookup2, attr.id, value];
  });
  return attrTuples;
}
function expandDelete(attrs, [etype, eid]) {
  const lookup2 = extractLookup(attrs, etype, eid);
  return [["delete-entity", lookup2, etype]];
}
function expandDeepMerge(attrs, [etype, eid, obj]) {
  const lookup2 = extractLookup(attrs, etype, eid);
  const attrTuples = Object.entries(obj).map(([identName, value]) => {
    const attr = getAttrByFwdIdentName2(attrs, etype, identName);
    const coercedValue = immutableDeepReplace(value, void 0, null);
    return ["deep-merge-triple", lookup2, attr.id, coercedValue];
  });
  const idTuple = [
    "add-triple",
    lookup2,
    getAttrByFwdIdentName2(attrs, etype, "id").id,
    lookup2
  ];
  return [idTuple].concat(attrTuples);
}
function removeIdFromArgs(step) {
  const [op, etype, eid, obj] = step;
  if (!obj) {
    return step;
  }
  const newObj = Object.assign({}, obj);
  delete newObj.id;
  return [op, etype, eid, newObj];
}
function toTxSteps(attrs, step) {
  const [action, ...args] = removeIdFromArgs(step);
  switch (action) {
    case "merge":
      return expandDeepMerge(attrs, args);
    case "update":
      return expandUpdate(attrs, args);
    case "link":
      return expandLink(attrs, args);
    case "unlink":
      return expandUnlink(attrs, args);
    case "delete":
      return expandDelete(attrs, args);
    default:
      throw new Error(`unsupported action ${action}`);
  }
}
function checkedDataTypeOfValueType(valueType) {
  switch (valueType) {
    case "string":
    case "date":
    case "boolean":
    case "number":
      return valueType;
    default:
      return void 0;
  }
}
function objectPropsFromSchema(schema2, etype, label) {
  var _a, _b;
  const attr = (_b = (_a = schema2.entities[etype]) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b[label];
  if (label === "id")
    return null;
  if (!attr) {
    throw new Error(`${etype}.${label} does not exist in your schema`);
  }
  const { unique, indexed } = attr === null || attr === void 0 ? void 0 : attr.config;
  const checkedDataType = checkedDataTypeOfValueType(attr === null || attr === void 0 ? void 0 : attr.valueType);
  return {
    "index?": indexed,
    "unique?": unique,
    "checked-data-type": checkedDataType
  };
}
function createObjectAttr(schema2, etype, label, props) {
  const schemaObjectProps = schema2 ? objectPropsFromSchema(schema2, etype, label) : null;
  const attrId = uuid_default();
  const fwdIdentId = uuid_default();
  const fwdIdent = [fwdIdentId, etype, label];
  return Object.assign(Object.assign({ id: attrId, "forward-identity": fwdIdent, "value-type": "blob", cardinality: "one", "unique?": false, "index?": false, isUnsynced: true }, schemaObjectProps || {}), props || {});
}
function findSchemaLink(schema2, etype, label) {
  const found = Object.values(schema2.links).find((x) => {
    return x.forward.on === etype && x.forward.label === label || x.reverse.on === etype && x.reverse.label === label;
  });
  return found;
}
function refPropsFromSchema(schema2, etype, label) {
  const found = findSchemaLink(schema2, etype, label);
  if (!found) {
    throw new Error(`Couldn't find the link ${etype}.${label} in your schema`);
  }
  const { forward, reverse } = found;
  return {
    "forward-identity": [uuid_default(), forward.on, forward.label],
    "reverse-identity": [uuid_default(), reverse.on, reverse.label],
    cardinality: forward.has === "one" ? "one" : "many",
    "unique?": reverse.has === "one"
  };
}
function createRefAttr(schema2, etype, label, props) {
  const schemaRefProps = schema2 ? refPropsFromSchema(schema2, etype, label) : null;
  const attrId = uuid_default();
  const fwdIdent = [uuid_default(), etype, label];
  const revIdent = [uuid_default(), label, etype];
  return Object.assign(Object.assign({ id: attrId, "forward-identity": fwdIdent, "reverse-identity": revIdent, "value-type": "ref", cardinality: "many", "unique?": false, "index?": false, isUnsynced: true }, schemaRefProps || {}), props || {});
}
var OBJ_ACTIONS = /* @__PURE__ */ new Set(["update", "merge", "link", "unlink"]);
var REF_ACTIONS = /* @__PURE__ */ new Set(["link", "unlink"]);
var UPDATE_ACTIONS = /* @__PURE__ */ new Set(["update", "merge"]);
var SUPPORTS_LOOKUP_ACTIONS = /* @__PURE__ */ new Set([
  "link",
  "unlink",
  "update",
  "merge",
  "delete"
]);
var lookupProps = { "unique?": true, "index?": true };
var refLookupProps = Object.assign(Object.assign({}, lookupProps), { cardinality: "one" });
function lookupPairsOfOp(op) {
  const res = [];
  const [action, etype, eid, obj] = op;
  if (!SUPPORTS_LOOKUP_ACTIONS.has(action)) {
    return res;
  }
  const eidLookupPair = lookupPairOfEid(eid);
  if (eidLookupPair) {
    res.push({ etype, lookupPair: eidLookupPair });
  }
  if (action === "link") {
    for (const [label, eidOrEids] of Object.entries(obj)) {
      const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];
      for (const linkEid of eids) {
        const linkEidLookupPair = lookupPairOfEid(linkEid);
        if (linkEidLookupPair) {
          res.push({
            etype,
            lookupPair: linkEidLookupPair,
            linkLabel: label
          });
        }
      }
    }
  }
  return res;
}
function createMissingAttrs({ attrs: existingAttrs, schema: schema2 }, ops) {
  var _a, _b;
  const [addedIds, attrs, addOps] = [/* @__PURE__ */ new Set(), Object.assign({}, existingAttrs), []];
  function addAttr2(attr) {
    attrs[attr.id] = attr;
    addOps.push(["add-attr", attr]);
    addedIds.add(attr.id);
  }
  function addUnsynced(attr) {
    if ((attr === null || attr === void 0 ? void 0 : attr.isUnsynced) && !addedIds.has(attr.id)) {
      addOps.push(["add-attr", attr]);
      addedIds.add(attr.id);
    }
  }
  function addForRef(etype, label) {
    const fwdAttr = getAttrByFwdIdentName2(attrs, etype, label);
    const revAttr = getAttrByReverseIdentName2(attrs, etype, label);
    addUnsynced(fwdAttr);
    addUnsynced(revAttr);
    if (!fwdAttr && !revAttr) {
      addAttr2(createRefAttr(schema2, etype, label, refLookupProps));
    }
  }
  for (const op of ops) {
    for (const { etype, lookupPair, linkLabel } of lookupPairsOfOp(op)) {
      const identName = lookupPair[0];
      if (linkLabel) {
        addForRef(etype, linkLabel);
        const fwdAttr = getAttrByFwdIdentName2(attrs, etype, linkLabel);
        const revAttr = getAttrByReverseIdentName2(attrs, etype, linkLabel);
        addUnsynced(fwdAttr);
        addUnsynced(revAttr);
        const linkEtype = ((_a = fwdAttr === null || fwdAttr === void 0 ? void 0 : fwdAttr["reverse-identity"]) === null || _a === void 0 ? void 0 : _a[1]) || ((_b = revAttr === null || revAttr === void 0 ? void 0 : revAttr["forward-identity"]) === null || _b === void 0 ? void 0 : _b[1]) || linkLabel;
        if (isRefLookupIdent(attrs, linkEtype, identName)) {
          addForRef(linkEtype, extractRefLookupFwdName(identName));
        } else {
          const attr = getAttrByFwdIdentName2(attrs, linkEtype, identName);
          if (!attr) {
            addAttr2(createObjectAttr(schema2, linkEtype, identName, lookupProps));
          }
          addUnsynced(attr);
        }
      } else if (isRefLookupIdent(attrs, etype, identName)) {
        addForRef(etype, extractRefLookupFwdName(identName));
      } else {
        const attr = getAttrByFwdIdentName2(attrs, etype, identName);
        if (!attr) {
          addAttr2(createObjectAttr(schema2, etype, identName, lookupProps));
        }
        addUnsynced(attr);
      }
    }
  }
  for (const op of ops) {
    const [action, etype, eid, obj] = op;
    if (OBJ_ACTIONS.has(action)) {
      const labels = Object.keys(obj);
      labels.push("id");
      for (const label of labels) {
        const fwdAttr = getAttrByFwdIdentName2(attrs, etype, label);
        addUnsynced(fwdAttr);
        if (UPDATE_ACTIONS.has(action)) {
          if (!fwdAttr) {
            addAttr2(createObjectAttr(schema2, etype, label, label === "id" ? { "unique?": true } : null));
          }
        }
        if (REF_ACTIONS.has(action)) {
          const revAttr = getAttrByReverseIdentName2(attrs, etype, label);
          if (!fwdAttr && !revAttr) {
            addAttr2(createRefAttr(schema2, etype, label));
          }
          addUnsynced(revAttr);
        }
      }
    }
  }
  return [attrs, addOps];
}
function transform(ctx, inputChunks) {
  const chunks = Array.isArray(inputChunks) ? inputChunks : [inputChunks];
  const ops = chunks.flatMap((tx2) => getOps(tx2));
  const [newAttrs, addAttrTxSteps] = createMissingAttrs(ctx, ops);
  const txSteps = ops.flatMap((op) => toTxSteps(newAttrs, op));
  return [...addAttrTxSteps, ...txSteps];
}

// node_modules/@instantdb/core/dist/module/IndexedDBStorage.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var IndexedDBStorage = class {
  constructor(dbName) {
    this.dbName = dbName;
    this._storeName = "kv";
    this._dbPromise = this._init();
  }
  _init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      request.onerror = (event) => {
        reject(event);
      };
      request.onsuccess = (event) => {
        resolve(event.target.result);
      };
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        db.createObjectStore(this._storeName);
      };
    });
  }
  getItem(k) {
    return __awaiter(this, void 0, void 0, function* () {
      const db = yield this._dbPromise;
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([this._storeName], "readonly");
        const objectStore = transaction.objectStore(this._storeName);
        const request = objectStore.get(k);
        request.onerror = (event) => {
          reject(event);
        };
        request.onsuccess = (_event) => {
          if (request.result) {
            resolve(request.result);
          } else {
            resolve(null);
          }
        };
      });
    });
  }
  setItem(k, v) {
    return __awaiter(this, void 0, void 0, function* () {
      const db = yield this._dbPromise;
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([this._storeName], "readwrite");
        const objectStore = transaction.objectStore(this._storeName);
        const request = objectStore.put(v, k);
        request.onerror = (event) => {
          reject(event);
        };
        request.onsuccess = (_event) => {
          resolve();
        };
      });
    });
  }
};

// node_modules/@instantdb/core/dist/module/WindowNetworkListener.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var WindowNetworkListener = class {
  static getIsOnline() {
    return __awaiter2(this, void 0, void 0, function* () {
      return navigator.onLine;
    });
  }
  static listen(f2) {
    const onOnline = () => {
      f2(true);
    };
    const onOffline = () => {
      f2(false);
    };
    addEventListener("online", onOnline);
    addEventListener("offline", onOffline);
    return () => {
      removeEventListener("online", onOnline);
      removeEventListener("offline", onOffline);
    };
  }
};

// node_modules/@instantdb/core/dist/module/utils/fetch.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function jsonFetch(input, init3) {
  return __awaiter3(this, void 0, void 0, function* () {
    const res = yield fetch(input, init3);
    const json2 = yield res.json();
    return res.status === 200 ? Promise.resolve(json2) : Promise.reject({ status: res.status, body: json2 });
  });
}

// node_modules/@instantdb/core/dist/module/authAPI.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function sendMagicCode({ apiURI, appId, email }) {
  return jsonFetch(`${apiURI}/runtime/auth/send_magic_code`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ "app-id": appId, email })
  });
}
function verifyMagicCode(_a) {
  return __awaiter4(this, arguments, void 0, function* ({ apiURI, appId, email, code }) {
    const res = yield jsonFetch(`${apiURI}/runtime/auth/verify_magic_code`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ "app-id": appId, email, code })
    });
    return res;
  });
}
function verifyRefreshToken(_a) {
  return __awaiter4(this, arguments, void 0, function* ({ apiURI, appId, refreshToken }) {
    const res = yield jsonFetch(`${apiURI}/runtime/auth/verify_refresh_token`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        "app-id": appId,
        "refresh-token": refreshToken
      })
    });
    return res;
  });
}
function exchangeCodeForToken(_a) {
  return __awaiter4(this, arguments, void 0, function* ({ apiURI, appId, code, codeVerifier }) {
    const res = yield jsonFetch(`${apiURI}/runtime/oauth/token`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        app_id: appId,
        code,
        code_verifier: codeVerifier
      })
    });
    return res;
  });
}
function signInWithIdToken(_a) {
  return __awaiter4(this, arguments, void 0, function* ({ apiURI, appId, nonce, idToken, clientName, refreshToken }) {
    const res = yield jsonFetch(`${apiURI}/runtime/oauth/id_token`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        app_id: appId,
        nonce,
        id_token: idToken,
        client_name: clientName,
        refresh_token: refreshToken
      })
    });
    return res;
  });
}
function signOut(_a) {
  return __awaiter4(this, arguments, void 0, function* ({ apiURI, appId, refreshToken }) {
    const res = yield jsonFetch(`${apiURI}/runtime/signout`, {
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify({
        app_id: appId,
        refresh_token: refreshToken
      })
    });
    return res;
  });
}

// node_modules/@instantdb/core/dist/module/StorageAPI.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getSignedUploadUrl(_a) {
  return __awaiter5(this, arguments, void 0, function* ({ apiURI, appId, fileName, refreshToken, metadata = {} }) {
    const { data } = yield jsonFetch(`${apiURI}/storage/signed-upload-url`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${refreshToken}`
      },
      body: JSON.stringify({
        app_id: appId,
        filename: fileName
      })
    });
    return data;
  });
}
function upload(presignedUrl, file) {
  return __awaiter5(this, void 0, void 0, function* () {
    const response = yield fetch(presignedUrl, {
      method: "PUT",
      body: file,
      headers: {
        "Content-Type": file.type
      }
    });
    return response.ok;
  });
}
function getDownloadUrl(_a) {
  return __awaiter5(this, arguments, void 0, function* ({ apiURI, appId, path, refreshToken }) {
    const { data } = yield jsonFetch(`${apiURI}/storage/signed-download-url?app_id=${appId}&filename=${encodeURIComponent(path)}`, {
      method: "GET",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${refreshToken}`
      }
    });
    return data;
  });
}
function deleteFile(_a) {
  return __awaiter5(this, arguments, void 0, function* ({ apiURI, appId, path, refreshToken }) {
    const { data } = yield jsonFetch(`${apiURI}/storage/files?app_id=${appId}&filename=${encodeURIComponent(path)}`, {
      method: "DELETE",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${refreshToken}`
      }
    });
    return data;
  });
}

// node_modules/@instantdb/core/dist/module/utils/pick.js
function pick(obj, keys) {
  if (!keys)
    return obj;
  const ret = {};
  keys.forEach((key) => {
    ret[key] = obj[key];
  });
  return ret;
}

// node_modules/@instantdb/core/dist/module/presence.js
function buildPresenceSlice(data, opts, userPeerId) {
  var _a, _b;
  const slice = {
    peers: {}
  };
  const includeUser = opts && "user" in opts ? opts.user : true;
  if (includeUser) {
    const user = pick((_a = data.user) !== null && _a !== void 0 ? _a : {}, opts === null || opts === void 0 ? void 0 : opts.keys);
    slice.user = Object.assign(Object.assign({}, user), { peerId: userPeerId });
  }
  for (const id2 of Object.keys((_b = data.peers) !== null && _b !== void 0 ? _b : {})) {
    const shouldIncludeAllPeers = (opts === null || opts === void 0 ? void 0 : opts.peers) === void 0;
    const isPeerIncluded = Array.isArray(opts === null || opts === void 0 ? void 0 : opts.peers) && (opts === null || opts === void 0 ? void 0 : opts.peers.includes(id2));
    if (shouldIncludeAllPeers || isPeerIncluded) {
      const peer = pick(data.peers[id2], opts === null || opts === void 0 ? void 0 : opts.keys);
      slice.peers[id2] = Object.assign(Object.assign({}, peer), { peerId: id2 });
    }
  }
  return slice;
}
function hasPresenceResponseChanged(a, b) {
  if (a.isLoading !== b.isLoading)
    return true;
  if (a.error !== b.error)
    return true;
  if (a.user || b.user) {
    if (!a.user || !b.user)
      return true;
    const same = areObjectsShallowEqual(a.user, b.user);
    if (!same)
      return true;
  }
  const sameKeys = areObjectKeysEqual(a.peers, b.peers);
  if (!sameKeys)
    return true;
  for (const id2 of Object.keys(a.peers)) {
    const same = areObjectsShallowEqual(a.peers[id2], b.peers[id2]);
    if (!same)
      return true;
  }
  return false;
}

// node_modules/@instantdb/core/dist/module/utils/Deferred.js
var Deferred = class {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  resolve(value) {
    this._resolve(value);
  }
  reject(reason) {
    this._reject(reason);
  }
};

// node_modules/@instantdb/core/dist/module/utils/PersistedObject.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PersistedObject = class {
  constructor(persister, key, defaultValue, onMerge, toJSON2 = (x) => {
    return JSON.stringify(x);
  }, fromJSON2 = (x) => {
    return JSON.parse(x);
  }, saveThrottleMs = 100) {
    this._subs = [];
    this._persister = persister;
    this._key = key;
    this._onMerge = onMerge;
    this._loadedCbs = [];
    this._isLoading = true;
    this.currentValue = defaultValue;
    this.toJSON = toJSON2;
    this.fromJSON = fromJSON2;
    this._saveThrottleMs = saveThrottleMs;
    this._pendingSaveCbs = [];
    this._version = 0;
    this._load();
  }
  _load() {
    return __awaiter6(this, void 0, void 0, function* () {
      const fromStorage = this.fromJSON(yield this._persister.getItem(this._key));
      this._isLoading = false;
      this._onMerge(fromStorage, this.currentValue);
      for (const cb of this._loadedCbs) {
        cb();
      }
    });
  }
  waitForLoaded() {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!this._isLoading) {
        return;
      }
      const loadedPromise = new Promise((resolve) => {
        this._loadedCbs.push(resolve);
      });
      yield loadedPromise;
    });
  }
  isLoading() {
    return this._isLoading;
  }
  version() {
    return this._version;
  }
  waitForSync() {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!this._nextSave) {
        return;
      }
      const syncedPromise = new Promise((resolve) => {
        this._pendingSaveCbs.push(resolve);
      });
      yield syncedPromise;
    });
  }
  _writeToStorage() {
    this._persister.setItem(this._key, this.toJSON(this.currentValue));
    for (const cb of this._pendingSaveCbs) {
      cb();
    }
    this._pendingSaveCbs.length = 0;
  }
  flush() {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!this._nextSave) {
        return;
      }
      clearTimeout(this._nextSave);
      this._writeToStorage();
    });
  }
  _enqueuePersist(cb) {
    if (this._nextSave) {
      if (cb) {
        this._pendingSaveCbs.push(cb);
      }
      return;
    }
    this._nextSave = setTimeout(() => {
      this._nextSave = null;
      this._writeToStorage();
    }, this._saveThrottleMs);
  }
  set(f2, cb) {
    this._version++;
    this.currentValue = f2(this.currentValue);
    if (this._isLoading) {
      this._loadedCbs.push(() => this._enqueuePersist(cb));
    } else {
      this._enqueuePersist(cb);
    }
    for (const sub of this._subs) {
      sub(this.currentValue);
    }
  }
  subscribe(cb) {
    this._subs.push(cb);
    cb(this.currentValue);
    return () => {
      this._subs = this._subs.filter((x) => x !== cb);
    };
  }
};

// node_modules/@instantdb/core/dist/module/model/instaqlResult.js
function _extractTriplesHelper(idNodes, acc = []) {
  idNodes.forEach((idNode) => {
    const { data } = idNode;
    const { "datalog-result": datalogResult } = data;
    const { "join-rows": joinRows } = datalogResult;
    for (const rows of joinRows) {
      for (const triple of rows) {
        acc.push(triple);
      }
    }
    _extractTriplesHelper(idNode["child-nodes"], acc);
  });
}
function extractTriples(idNodes) {
  const triples = [];
  _extractTriplesHelper(idNodes, triples);
  return triples;
}

// node_modules/@instantdb/core/dist/module/utils/linkIndex.js
function createLinkIndex(schema2) {
  return Object.values(schema2.links).reduce((linkIndex, link) => {
    var _a, _b;
    var _c, _d;
    (_a = linkIndex[_c = link.forward.on]) !== null && _a !== void 0 ? _a : linkIndex[_c] = {};
    linkIndex[link.forward.on][link.forward.label] = {
      isForward: true,
      isSingular: link.forward.has === "one",
      link
    };
    (_b = linkIndex[_d = link.reverse.on]) !== null && _b !== void 0 ? _b : linkIndex[_d] = {};
    linkIndex[link.reverse.on][link.reverse.label] = {
      isForward: false,
      isSingular: link.reverse.has === "one",
      link
    };
    return linkIndex;
  }, {});
}

// node_modules/@instantdb/core/dist/module/version.js
var version = "v0.17.3";
var version_default2 = version;

// node_modules/@instantdb/core/dist/module/Reactor.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var STATUS = {
  CONNECTING: "connecting",
  OPENED: "opened",
  AUTHENTICATED: "authenticated",
  CLOSED: "closed",
  ERRORED: "errored"
};
var QUERY_ONCE_TIMEOUT = 3e4;
var WS_CONNECTING_STATUS = 0;
var WS_OPEN_STATUS = 1;
var defaultConfig = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
};
var OAUTH_REDIRECT_PARAM = "_instant_oauth_redirect";
var currentUserKey = `currentUser`;
var _wsId = 0;
function createWebSocket(uri) {
  const ws = new WebSocket(uri);
  ws._id = _wsId++;
  return ws;
}
function isClient() {
  const hasWindow = typeof window !== "undefined";
  const isChrome = typeof chrome !== "undefined";
  return hasWindow || isChrome;
}
var ignoreLogging = {
  "set-presence": true,
  "set-presence-ok": true,
  "refresh-presence": true
};
function querySubsFromJSON(str) {
  var _a;
  const parsed = JSON.parse(str);
  for (const key in parsed) {
    const v = parsed[key];
    if ((_a = v === null || v === void 0 ? void 0 : v.result) === null || _a === void 0 ? void 0 : _a.store) {
      v.result.store = fromJSON(v.result.store);
    }
  }
  return parsed;
}
function querySubsToJSON(querySubs) {
  var _a;
  const jsonSubs = {};
  for (const key in querySubs) {
    const sub = querySubs[key];
    const jsonSub = Object.assign({}, sub);
    if ((_a = sub.result) === null || _a === void 0 ? void 0 : _a.store) {
      jsonSub.result = Object.assign(Object.assign({}, sub.result), { store: toJSON(sub.result.store) });
    }
    jsonSubs[key] = jsonSub;
  }
  return JSON.stringify(jsonSubs);
}
var Reactor = class {
  constructor(config, Storage2 = IndexedDBStorage, NetworkListener = WindowNetworkListener, versions) {
    this._isOnline = true;
    this._isShutdown = false;
    this.status = STATUS.CONNECTING;
    this.queryCbs = {};
    this.queryOnceDfds = {};
    this.authCbs = [];
    this.attrsCbs = [];
    this.mutationErrorCbs = [];
    this.connectionStatusCbs = [];
    this.mutationDeferredStore = /* @__PURE__ */ new Map();
    this._reconnectTimeoutId = null;
    this._reconnectTimeoutMs = 0;
    this._localIdPromises = {};
    this._errorMessage = null;
    this._oauthCallbackResponse = null;
    this._linkIndex = null;
    this._rooms = {};
    this._roomsPendingLeave = {};
    this._presence = {};
    this._broadcastQueue = [];
    this._broadcastSubs = {};
    this._currentUserCached = { isLoading: true, error: void 0, user: void 0 };
    this._beforeUnloadCbs = [];
    this._dataForQueryCache = {};
    this._onMergeQuerySubs = (_storageSubs, inMemorySubs) => {
      const storageSubs = _storageSubs || {};
      const ret = Object.assign({}, inMemorySubs);
      Object.entries(inMemorySubs).forEach(([hash, querySub]) => {
        var _a;
        const storageResult = (_a = storageSubs === null || storageSubs === void 0 ? void 0 : storageSubs[hash]) === null || _a === void 0 ? void 0 : _a.result;
        const memoryResult = querySub.result;
        if (storageResult && !memoryResult) {
          ret[hash].result = storageResult;
        }
      });
      const storageKsToAdd = Object.keys(storageSubs).filter((k) => !inMemorySubs[k]).slice(0, 10);
      storageKsToAdd.forEach((k) => {
        ret[k] = storageSubs[k];
      });
      this.querySubs.set((_) => ret);
      this.loadedNotifyAll();
    };
    this._onMergePendingMutations = (storageMuts, inMemoryMuts) => {
      const ret = new Map([...storageMuts.entries(), ...inMemoryMuts.entries()]);
      this.pendingMutations.set((_) => ret);
      this.loadedNotifyAll();
      const rewrittenStorageMuts = this._rewriteMutations(this.attrs, storageMuts);
      rewrittenStorageMuts.forEach((mut, k) => {
        if (!inMemoryMuts.has(k) && !mut["tx-id"]) {
          this._sendMutation(k, mut);
        }
      });
    };
    this.getPreviousResult = (q) => {
      const hash = weakHash(q);
      return this.dataForQuery(hash);
    };
    this.notifyOne = (hash) => {
      var _a, _b;
      const cbs = (_a = this.queryCbs[hash]) !== null && _a !== void 0 ? _a : [];
      const prevData = (_b = this._dataForQueryCache[hash]) === null || _b === void 0 ? void 0 : _b.data;
      const data = this.dataForQuery(hash);
      if (!data)
        return;
      if (areObjectsDeepEqual(data, prevData))
        return;
      cbs.forEach((r) => r.cb(data));
    };
    this.notifyOneQueryOnce = (hash) => {
      var _a;
      const dfds = (_a = this.queryOnceDfds[hash]) !== null && _a !== void 0 ? _a : [];
      const data = this.dataForQuery(hash);
      dfds.forEach((r) => {
        this._completeQueryOnce(r.q, hash, r.dfd);
        r.dfd.resolve(data);
      });
    };
    this.notifyQueryError = (hash, error) => {
      const cbs = this.queryCbs[hash] || [];
      cbs.forEach((r) => r.cb({ error }));
    };
    this.pushTx = (chunks) => {
      try {
        const txSteps = transform({ attrs: this.optimisticAttrs(), schema: this.config.schema }, chunks);
        return this.pushOps(txSteps);
      } catch (e) {
        return this.pushOps([], e);
      }
    };
    this.pushOps = (txSteps, error) => {
      const eventId = uuid_default();
      const mutation = {
        op: "transact",
        "tx-steps": txSteps,
        error
      };
      this.pendingMutations.set((prev) => {
        prev.set(eventId, mutation);
        return prev;
      });
      const dfd = new Deferred();
      this.mutationDeferredStore.set(eventId, dfd);
      this._sendMutation(eventId, mutation);
      this.notifyAll();
      return dfd.promise;
    };
    this._wsOnOpen = (e) => {
      const targetWs = e.target;
      if (this._ws !== targetWs) {
        log_default.info("[socket][open]", targetWs._id, "skip; this is no longer the current ws");
        return;
      }
      log_default.info("[socket][open]", this._ws._id);
      this._setStatus(STATUS.OPENED);
      this.getCurrentUser().then((resp) => {
        var _a;
        this._trySend(uuid_default(), {
          op: "init",
          "app-id": this.config.appId,
          "refresh-token": (_a = resp.user) === null || _a === void 0 ? void 0 : _a["refresh_token"],
          versions: this.versions,
          // If an admin token is provided for an app, we will
          // skip all permission checks. This is an advanced feature,
          // to let users write internal tools
          // This option is not exposed in `Config`, as it's
          // not ready for prme time
          "__admin-token": this.config.__adminToken
        });
      });
    };
    this._wsOnMessage = (e) => {
      const targetWs = e.target;
      const m = JSON.parse(e.data.toString());
      if (this._ws !== targetWs) {
        log_default.info("[socket][message]", targetWs._id, m, "skip; this is no longer the current ws");
        return;
      }
      this._handleReceive(targetWs._id, JSON.parse(e.data.toString()));
    };
    this._wsOnError = (e) => {
      const targetWs = e.target;
      if (this._ws !== targetWs) {
        log_default.info("[socket][error]", targetWs._id, "skip; this is no longer the current ws");
        return;
      }
      log_default.error("[socket][error]", targetWs._id, e);
    };
    this._wsOnClose = (e) => {
      const targetWs = e.target;
      if (this._ws !== targetWs) {
        log_default.info("[socket][close]", targetWs._id, "skip; this is no longer the current ws");
        return;
      }
      this._setStatus(STATUS.CLOSED);
      for (const room of Object.values(this._rooms)) {
        room.isConnected = false;
      }
      if (this._isShutdown) {
        log_default.info("[socket][close]", targetWs._id, "Reactor has been shut down and will not reconnect");
        return;
      }
      log_default.info("[socket][close]", targetWs._id, "schedule reconnect, ms =", this._reconnectTimeoutMs);
      setTimeout(() => {
        this._reconnectTimeoutMs = Math.min(this._reconnectTimeoutMs + 1e3, 1e4);
        if (!this._isOnline) {
          log_default.info("[socket][close]", targetWs._id, "we are offline, no need to start socket");
          return;
        }
        this._startSocket();
      }, this._reconnectTimeoutMs);
    };
    this.config = Object.assign(Object.assign({}, defaultConfig), config);
    this.versions = Object.assign(Object.assign({}, versions || {}), { "@instantdb/core": version_default2 });
    if (this.config.schema) {
      this._linkIndex = createLinkIndex(this.config.schema);
    }
    if (!isClient()) {
      return;
    }
    if (typeof BroadcastChannel === "function") {
      this._broadcastChannel = new BroadcastChannel("@instantdb");
      this._broadcastChannel.addEventListener("message", (e) => __awaiter7(this, void 0, void 0, function* () {
        var _a;
        if (((_a = e.data) === null || _a === void 0 ? void 0 : _a.type) === "auth") {
          const res = yield this.getCurrentUser();
          this.updateUser(res.user);
        }
      }));
    }
    this._oauthCallbackResponse = this._oauthLoginInit();
    this._initStorage(Storage2);
    this.getCurrentUser();
    NetworkListener.getIsOnline().then((isOnline) => {
      this._isOnline = isOnline;
      this._startSocket();
      NetworkListener.listen((isOnline2) => {
        if (isOnline2 === this._isOnline) {
          return;
        }
        log_default.info("[network] online =", isOnline2);
        this._isOnline = isOnline2;
        if (this._isOnline) {
          this._startSocket();
        }
      });
    });
    if (typeof addEventListener !== "undefined") {
      this._beforeUnload = this._beforeUnload.bind(this);
      addEventListener("beforeunload", this._beforeUnload);
    }
  }
  _initStorage(Storage2) {
    this._persister = new Storage2(`instant_${this.config.appId}_5`);
    this.querySubs = new PersistedObject(this._persister, "querySubs", {}, this._onMergeQuerySubs, querySubsToJSON, querySubsFromJSON);
    this.pendingMutations = new PersistedObject(this._persister, "pendingMutations", /* @__PURE__ */ new Map(), this._onMergePendingMutations, (x) => {
      return JSON.stringify([...x.entries()]);
    }, (x) => {
      return new Map(JSON.parse(x));
    });
    this._beforeUnloadCbs.push(() => {
      this.pendingMutations.flush();
      this.querySubs.flush();
    });
  }
  _beforeUnload() {
    for (const cb of this._beforeUnloadCbs) {
      cb();
    }
  }
  /**
   * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status
   * @param string clientId
   * @param {{message?: string, hint?: string, error?: Error}} [errDetails]
   */
  _finishTransaction(status, clientId, errDetails) {
    const dfd = this.mutationDeferredStore.get(clientId);
    this.mutationDeferredStore.delete(clientId);
    const ok = status !== "error" && status !== "timeout";
    if (!dfd && !ok) {
      console.error("Mutation failed", Object.assign({ status, clientId }, errDetails));
    }
    if (!dfd) {
      return;
    }
    if (ok) {
      dfd.resolve({ status, clientId });
    } else {
      dfd.reject(Object.assign({ status, clientId }, errDetails));
    }
  }
  _setStatus(status, err) {
    this.status = status;
    this._errorMessage = err;
    this.notifyConnectionStatusSubs(status);
  }
  _flushEnqueuedRoomData(roomId) {
    var _a, _b;
    const enqueuedUserPresence = (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b.user;
    const enqueuedBroadcasts = this._broadcastQueue[roomId];
    this._broadcastQueue[roomId] = [];
    if (enqueuedUserPresence) {
      this._trySetPresence(roomId, enqueuedUserPresence);
    }
    if (enqueuedBroadcasts) {
      for (const item of enqueuedBroadcasts) {
        const { topic, roomType, data } = item;
        this._tryBroadcast(roomId, roomType, topic, data);
      }
    }
  }
  _handleReceive(wsId, msg) {
    var _a, _b, _c, _d;
    const enableCardinalityInference = Boolean(this.config.schema) && ("cardinalityInference" in this.config ? Boolean(this.config.cardinalityInference) : true);
    if (!ignoreLogging[msg.op]) {
      log_default.info("[receive]", wsId, msg.op, msg);
    }
    switch (msg.op) {
      case "init-ok":
        this._setStatus(STATUS.AUTHENTICATED);
        this._reconnectTimeoutMs = 0;
        this._setAttrs(msg.attrs);
        this._flushPendingMessages();
        this._sessionId = msg["session-id"];
        for (const roomId2 of Object.keys(this._rooms)) {
          this._tryJoinRoom(roomId2);
        }
        break;
      case "add-query-exists":
        this.notifyOneQueryOnce(weakHash(msg.q));
        break;
      case "add-query-ok":
        const { q, result } = msg;
        const hash = weakHash(q);
        const pageInfo = (_b = (_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b["page-info"];
        const aggregate = (_d = (_c = result === null || result === void 0 ? void 0 : result[0]) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d["aggregate"];
        const triples = extractTriples(result);
        const store = createStore(this.attrs, triples, enableCardinalityInference, this._linkIndex);
        this.querySubs.set((prev) => {
          prev[hash].result = { store, pageInfo, aggregate };
          return prev;
        });
        this.notifyOne(hash);
        this.notifyOneQueryOnce(hash);
        break;
      case "refresh-ok":
        const { computations, attrs } = msg;
        this._setAttrs(attrs);
        const updates = computations.map((x) => {
          var _a2, _b2, _c2, _d2;
          const q2 = x["instaql-query"];
          const result2 = x["instaql-result"];
          const hash2 = weakHash(q2);
          const triples2 = extractTriples(result2);
          const store2 = createStore(this.attrs, triples2, enableCardinalityInference, this._linkIndex);
          const pageInfo2 = (_b2 = (_a2 = result2 === null || result2 === void 0 ? void 0 : result2[0]) === null || _a2 === void 0 ? void 0 : _a2.data) === null || _b2 === void 0 ? void 0 : _b2["page-info"];
          const aggregate2 = (_d2 = (_c2 = result2 === null || result2 === void 0 ? void 0 : result2[0]) === null || _c2 === void 0 ? void 0 : _c2.data) === null || _d2 === void 0 ? void 0 : _d2["aggregate"];
          return { hash: hash2, store: store2, pageInfo: pageInfo2, aggregate: aggregate2 };
        });
        updates.forEach(({ hash: hash2, store: store2, pageInfo: pageInfo2, aggregate: aggregate2 }) => {
          this.querySubs.set((prev) => {
            prev[hash2].result = { store: store2, pageInfo: pageInfo2, aggregate: aggregate2 };
            return prev;
          });
        });
        updates.forEach(({ hash: hash2 }) => {
          this.notifyOne(hash2);
        });
        break;
      case "transact-ok":
        const { "client-event-id": eventId, "tx-id": txId } = msg;
        const muts = this._rewriteMutations(this.attrs, this.pendingMutations.currentValue);
        const prevMutation = muts.get(eventId);
        if (!prevMutation) {
          break;
        }
        this.pendingMutations.set((prev) => {
          prev.delete(eventId);
          return prev;
        });
        const txStepsToApply = prevMutation["tx-steps"];
        this.querySubs.set((prev) => {
          var _a2;
          for (const [hash2, sub] of Object.entries(prev)) {
            const store2 = (_a2 = sub === null || sub === void 0 ? void 0 : sub.result) === null || _a2 === void 0 ? void 0 : _a2.store;
            if (!store2) {
              continue;
            }
            const newStore = transact(store2, txStepsToApply);
            prev[hash2].result.store = newStore;
          }
          return prev;
        });
        const newAttrs = prevMutation["tx-steps"].filter(([action, ..._args]) => action === "add-attr").map(([_action, attr]) => attr).concat(Object.values(this.attrs));
        this._setAttrs(newAttrs);
        this._finishTransaction("synced", eventId);
        break;
      case "refresh-presence":
        const roomId = msg["room-id"];
        this._setPresencePeers(roomId, msg.data);
        this._notifyPresenceSubs(roomId);
        break;
      case "server-broadcast":
        const room = msg["room-id"];
        const topic = msg.topic;
        this._notifyBroadcastSubs(room, topic, msg);
        break;
      case "join-room-ok":
        const loadingRoomId = msg["room-id"];
        const joinedRoom = this._rooms[loadingRoomId];
        if (!joinedRoom) {
          if (this._roomsPendingLeave[loadingRoomId]) {
            this._tryLeaveRoom(loadingRoomId);
            delete this._roomsPendingLeave[loadingRoomId];
          }
          break;
        }
        joinedRoom.isConnected = true;
        this._notifyPresenceSubs(loadingRoomId);
        this._flushEnqueuedRoomData(loadingRoomId);
        break;
      case "join-room-error":
        const errorRoomId = msg["room-id"];
        const errorRoom = this._rooms[errorRoomId];
        if (errorRoom) {
          errorRoom.error = msg["error"];
        }
        this._notifyPresenceSubs(errorRoomId);
        break;
      case "error":
        this._handleReceiveError(msg);
        break;
      default:
        break;
    }
  }
  /**
   * @param {'timeout' | 'error'} status
   * @param {string} eventId
   * @param {{message?: string, hint?: string, error?: Error}} errDetails
   */
  _handleMutationError(status, eventId, errDetails) {
    const mut = this.pendingMutations.currentValue.get(eventId);
    if (mut && (status !== "timeout" || !mut["tx-id"])) {
      this.pendingMutations.set((prev) => {
        prev.delete(eventId);
        return prev;
      });
      this.notifyAll();
      this.notifyAttrsSubs();
      this.notifyMutationErrorSubs(errDetails);
      this._finishTransaction(status, eventId, errDetails);
    }
  }
  _handleReceiveError(msg) {
    var _a, _b, _c, _d;
    const eventId = msg["client-event-id"];
    const prevMutation = this.pendingMutations.currentValue.get(eventId);
    const errorMessage = {
      message: msg.message || "Uh-oh, something went wrong. Ping Joe & Stopa."
    };
    if (msg.hint) {
      errorMessage.hint = msg.hint;
    }
    if (prevMutation) {
      const errDetails = {
        message: msg.message,
        hint: msg.hint
      };
      this._handleMutationError("error", eventId, errDetails);
      return;
    }
    const q = (_a = msg["original-event"]) === null || _a === void 0 ? void 0 : _a.q;
    if (q && ((_b = msg["original-event"]) === null || _b === void 0 ? void 0 : _b.op) === "add-query") {
      const hash = weakHash(q);
      this.notifyQueryError(weakHash(q), errorMessage);
      this.notifyQueryOnceError(q, hash, eventId, errorMessage);
      return;
    }
    const isInitError = ((_c = msg["original-event"]) === null || _c === void 0 ? void 0 : _c.op) === "init";
    if (isInitError) {
      if (msg.type === "record-not-found" && ((_d = msg.hint) === null || _d === void 0 ? void 0 : _d["record-type"]) === "app-user") {
        this.changeCurrentUser(null);
        return;
      }
      this._setStatus(STATUS.ERRORED, errorMessage);
      this.notifyAll();
      return;
    }
    const errorObj = Object.assign({}, msg);
    delete errorObj.message;
    delete errorObj.hint;
    console.error(msg.message, errorObj);
    if (msg.hint) {
      console.error("This error comes with some debugging information. Here it is: \n", msg.hint);
    }
  }
  notifyQueryOnceError(q, hash, eventId, e) {
    var _a;
    const r = (_a = this.queryOnceDfds[hash]) === null || _a === void 0 ? void 0 : _a.find((r2) => r2.eventId === eventId);
    if (!r)
      return;
    r.dfd.reject(e);
    this._completeQueryOnce(q, hash, r.dfd);
  }
  _setAttrs(attrs) {
    this.attrs = attrs.reduce((acc, attr) => {
      acc[attr.id] = attr;
      return acc;
    }, {});
    this.notifyAttrsSubs();
  }
  _startQuerySub(q, hash) {
    const eventId = uuid_default();
    this.querySubs.set((prev) => {
      prev[hash] = prev[hash] || { q, result: null, eventId };
      return prev;
    });
    this._trySendAuthed(eventId, { op: "add-query", q });
    return eventId;
  }
  /**
   *  When a user subscribes to a query the following side effects occur:
   *
   *  - We update querySubs to include the new query
   *  - We update queryCbs to include the new cb
   *  - If we already have a result for the query we call cb immediately
   *  - We send the server an `add-query` message
   *
   *  Returns an unsubscribe function
   */
  subscribeQuery(q, cb) {
    var _a;
    const hash = weakHash(q);
    const prevResult = this.getPreviousResult(q);
    if (prevResult) {
      cb(prevResult);
    }
    this.queryCbs[hash] = (_a = this.queryCbs[hash]) !== null && _a !== void 0 ? _a : [];
    this.queryCbs[hash].push({ q, cb });
    this._startQuerySub(q, hash);
    return () => {
      this._unsubQuery(q, hash, cb);
    };
  }
  queryOnce(q) {
    var _a;
    const dfd = new Deferred();
    if (!this._isOnline) {
      dfd.reject(new Error("We can't run `queryOnce`, because the device is offline."));
      return dfd.promise;
    }
    if (!this.querySubs) {
      dfd.reject(new Error("We can't run `queryOnce` on the backend. Use adminAPI.query instead: https://www.instantdb.com/docs/backend#query"));
      return dfd.promise;
    }
    const hash = weakHash(q);
    const eventId = this._startQuerySub(q, hash);
    this.queryOnceDfds[hash] = (_a = this.queryOnceDfds[hash]) !== null && _a !== void 0 ? _a : [];
    this.queryOnceDfds[hash].push({ q, dfd, eventId });
    setTimeout(() => dfd.reject(new Error("Query timed out")), QUERY_ONCE_TIMEOUT);
    return dfd.promise;
  }
  _completeQueryOnce(q, hash, dfd) {
    if (!this.queryOnceDfds[hash])
      return;
    this.queryOnceDfds[hash] = this.queryOnceDfds[hash].filter((r) => r.dfd !== dfd);
    this._cleanupQuery(q, hash);
  }
  _unsubQuery(q, hash, cb) {
    if (!this.queryCbs[hash])
      return;
    this.queryCbs[hash] = this.queryCbs[hash].filter((r) => r.cb !== cb);
    this._cleanupQuery(q, hash);
  }
  _cleanupQuery(q, hash) {
    var _a, _b;
    const hasListeners = ((_a = this.queryCbs[hash]) === null || _a === void 0 ? void 0 : _a.length) || ((_b = this.queryOnceDfds[hash]) === null || _b === void 0 ? void 0 : _b.length);
    if (hasListeners)
      return;
    delete this.queryCbs[hash];
    delete this.queryOnceDfds[hash];
    this._trySendAuthed(uuid_default(), { op: "remove-query", q });
  }
  // When we `pushTx`, it's possible that we don't yet have `this.attrs`
  // This means that `tx-steps` in `pendingMutations` will include `add-attr`
  // commands for attrs that already exist.
  //
  // This will also affect `add-triple` and `retract-triple` which
  // reference attr-ids that do not match the server.
  //
  // We fix this by rewriting `tx-steps` in each `pendingMutation`.
  // We remove `add-attr` commands for attrs that already exist.
  // We update `add-triple` and `retract-triple` commands to use the
  // server attr-ids.
  _rewriteMutations(attrs, muts) {
    if (!attrs)
      return muts;
    const findExistingAttr = (attr) => {
      const [_, etype, label] = attr["forward-identity"];
      const existing = getAttrByFwdIdentName2(attrs, etype, label);
      return existing;
    };
    const findReverseAttr = (attr) => {
      const [_, etype, label] = attr["forward-identity"];
      const revAttr = getAttrByReverseIdentName2(attrs, etype, label);
      return revAttr;
    };
    const mapping = { attrIdMap: {}, refSwapAttrIds: /* @__PURE__ */ new Set() };
    const rewriteTxSteps = (txSteps) => {
      const retTxSteps = [];
      for (const txStep of txSteps) {
        const [action] = txStep;
        if (action === "add-attr") {
          const [_action, attr] = txStep;
          const existing = findExistingAttr(attr);
          if (existing) {
            mapping.attrIdMap[attr.id] = existing.id;
            continue;
          }
          if (attr["value-type"] === "ref") {
            const revAttr = findReverseAttr(attr);
            if (revAttr) {
              mapping.attrIdMap[attr.id] = revAttr.id;
              mapping.refSwapAttrIds.add(attr.id);
              continue;
            }
          }
        }
        const newTxStep = rewriteStep(mapping, txStep);
        retTxSteps.push(newTxStep);
      }
      return retTxSteps;
    };
    const rewritten = /* @__PURE__ */ new Map();
    for (const [k, mut] of muts.entries()) {
      rewritten.set(k, Object.assign(Object.assign({}, mut), { "tx-steps": rewriteTxSteps(mut["tx-steps"]) }));
    }
    return rewritten;
  }
  // ---------------------------
  // Transact
  optimisticAttrs() {
    var _a;
    const pendingMutationSteps = [
      ...this.pendingMutations.currentValue.values()
    ].flatMap((x) => x["tx-steps"]);
    const deletedAttrIds = new Set(pendingMutationSteps.filter(([action, _attr]) => action === "delete-attr").map(([_action, id2]) => id2));
    const pendingAttrs = [];
    for (const [_action, attr] of pendingMutationSteps) {
      if (_action === "add-attr") {
        pendingAttrs.push(attr);
      } else if (_action === "update-attr" && attr.id && ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a[attr.id])) {
        const fullAttr = Object.assign(Object.assign({}, this.attrs[attr.id]), attr);
        pendingAttrs.push(fullAttr);
      }
    }
    const attrsWithoutDeleted = [
      ...Object.values(this.attrs || {}),
      ...pendingAttrs
    ].filter((a) => !deletedAttrIds.has(a.id));
    const attrsRecord = Object.fromEntries(attrsWithoutDeleted.map((a) => [a.id, a]));
    return attrsRecord;
  }
  /** Runs instaql on a query and a store */
  dataForQuery(hash) {
    const errorMessage = this._errorMessage;
    if (errorMessage) {
      return { error: errorMessage };
    }
    if (!this.querySubs)
      return;
    if (!this.pendingMutations)
      return;
    const querySubVersion = this.querySubs.version();
    const querySubs = this.querySubs.currentValue;
    const pendingMutationsVersion = this.pendingMutations.version();
    const pendingMutations = this.pendingMutations.currentValue;
    const { q, result } = querySubs[hash] || {};
    if (!result)
      return;
    const cached = this._dataForQueryCache[hash];
    if (cached && querySubVersion === cached.querySubVersion && pendingMutationsVersion === cached.pendingMutationsVersion) {
      return cached.data;
    }
    const { store, pageInfo, aggregate } = result;
    const muts = this._rewriteMutations(store.attrs, pendingMutations);
    const txSteps = [...muts.values()].flatMap((x) => x["tx-steps"]);
    const newStore = transact(store, txSteps);
    const resp = query2({ store: newStore, pageInfo, aggregate }, q);
    this._dataForQueryCache[hash] = {
      querySubVersion,
      pendingMutationsVersion,
      data: resp
    };
    return resp;
  }
  /** Re-compute all subscriptions */
  notifyAll() {
    Object.keys(this.queryCbs).forEach((hash) => {
      this.notifyOne(hash);
    });
  }
  loadedNotifyAll() {
    if (this.pendingMutations.isLoading() || this.querySubs.isLoading())
      return;
    this.notifyAll();
  }
  shutdown() {
    this._isShutdown = true;
    this._ws.close();
  }
  /**
   * Sends mutation to server and schedules a timeout to cancel it if
   * we don't hear back in time.
   * Note: If we're offline we don't schedule a timeout, we'll schedule it
   * later once we're back online and send the mutation again
   *
   */
  _sendMutation(eventId, mutation) {
    if (mutation.error) {
      this._handleMutationError("error", eventId, {
        error: mutation.error,
        message: mutation.error.message
      });
      return;
    }
    if (this.status !== STATUS.AUTHENTICATED) {
      this._finishTransaction("enqueued", eventId);
      return;
    }
    const timeoutMs = Math.max(5e3, this.pendingMutations.currentValue.size * 5e3);
    if (!this._isOnline) {
      this._finishTransaction("enqueued", eventId);
    } else {
      this._trySend(eventId, mutation);
      setTimeout(() => {
        this._finishTransaction("pending", eventId);
      }, 3e3);
      setTimeout(() => {
        if (!this._isOnline) {
          return;
        }
        this._handleMutationError("timeout", eventId, {
          message: "transaction timed out"
        });
      }, timeoutMs);
    }
  }
  // ---------------------------
  // Websocket
  /** Send messages we accumulated while we were connecting */
  _flushPendingMessages() {
    const subs = Object.keys(this.queryCbs).map((hash) => {
      return this.querySubs.currentValue[hash];
    });
    const safeSubs = subs.filter((x) => x);
    safeSubs.forEach(({ eventId, q }) => {
      this._trySendAuthed(eventId, { op: "add-query", q });
    });
    Object.values(this.queryOnceDfds).flat().forEach(({ eventId, q }) => {
      this._trySendAuthed(eventId, { op: "add-query", q });
    });
    const muts = this._rewriteMutations(this.attrs, this.pendingMutations.currentValue);
    muts.forEach((mut, eventId) => {
      if (!mut["tx-id"]) {
        this._sendMutation(eventId, mut);
      }
    });
  }
  _trySendAuthed(...args) {
    if (this.status !== STATUS.AUTHENTICATED) {
      return;
    }
    this._trySend(...args);
  }
  _trySend(eventId, msg, opts) {
    if (this._ws.readyState !== WS_OPEN_STATUS) {
      return;
    }
    if (!ignoreLogging[msg.op]) {
      log_default.info("[send]", this._ws._id, msg.op, msg);
    }
    this._ws.send(JSON.stringify(Object.assign({ "client-event-id": eventId }, msg)));
  }
  _startSocket() {
    if (this._ws && this._ws.readyState == WS_CONNECTING_STATUS) {
      log_default.info("[socket][start]", this._ws._id, "maintained as current ws, we were still in a connecting state");
      return;
    }
    const prevWs = this._ws;
    this._ws = createWebSocket(`${this.config.websocketURI}?app_id=${this.config.appId}`);
    this._ws.onopen = this._wsOnOpen;
    this._ws.onmessage = this._wsOnMessage;
    this._ws.onclose = this._wsOnClose;
    this._ws.onerror = this._wsOnError;
    log_default.info("[socket][start]", this._ws._id);
    if ((prevWs === null || prevWs === void 0 ? void 0 : prevWs.readyState) === WS_OPEN_STATUS) {
      log_default.info("[socket][start]", this._ws._id, "close previous ws id = ", prevWs._id);
      prevWs.close();
    }
  }
  /**
   * Given a key, returns a stable local id, unique to this device and app.
   *
   * This can be useful if you want to create guest ids for example.
   *
   * Note: If the user deletes their local storage, this id will change.
   *
   * We use this._localIdPromises to ensure that we only generate a local
   * id once, even if multiple callers call this function concurrently.
   */
  getLocalId(name) {
    return __awaiter7(this, void 0, void 0, function* () {
      const k = `localToken_${name}`;
      const id2 = yield this._persister.getItem(k);
      if (id2)
        return id2;
      if (this._localIdPromises[k]) {
        return this._localIdPromises[k];
      }
      const newId = uuid_default();
      this._localIdPromises[k] = this._persister.setItem(k, newId).then(() => newId);
      return this._localIdPromises[k];
    });
  }
  // ----
  // Auth
  _replaceUrlAfterOAuth() {
    if (typeof URL === "undefined") {
      return;
    }
    const url = new URL(window.location.href);
    if (url.searchParams.get(OAUTH_REDIRECT_PARAM)) {
      const startUrl = url.toString();
      url.searchParams.delete(OAUTH_REDIRECT_PARAM);
      url.searchParams.delete("code");
      url.searchParams.delete("error");
      const newPath = url.pathname + (url.searchParams.size ? "?" + url.searchParams : "") + url.hash;
      history.replaceState(history.state, "", newPath);
      if (
        // @ts-ignore (waiting for ts support)
        typeof navigation === "object" && // @ts-ignore (waiting for ts support)
        typeof navigation.addEventListener === "function" && // @ts-ignore (waiting for ts support)
        typeof navigation.removeEventListener === "function"
      ) {
        let ran = false;
        const listener = (e) => {
          var _a;
          if (!ran) {
            ran = true;
            navigation.removeEventListener("navigate", listener);
            if (!e.userInitiated && e.navigationType === "replace" && ((_a = e.destination) === null || _a === void 0 ? void 0 : _a.url) === startUrl) {
              history.replaceState(history.state, "", newPath);
            }
          }
        };
        navigation.addEventListener("navigate", listener);
      }
    }
  }
  /**
   *
   * @returns Promise<null | {error: {message: string}}>
   */
  _oauthLoginInit() {
    return __awaiter7(this, void 0, void 0, function* () {
      var _a, _b, _c, _d;
      if (typeof window === "undefined" || typeof window.location === "undefined" || typeof URLSearchParams === "undefined") {
        return null;
      }
      const params = new URLSearchParams(window.location.search);
      if (!params.get(OAUTH_REDIRECT_PARAM)) {
        return null;
      }
      const error = params.get("error");
      if (error) {
        this._replaceUrlAfterOAuth();
        return { error: { message: error } };
      }
      const code = params.get("code");
      if (!code) {
        return null;
      }
      this._replaceUrlAfterOAuth();
      try {
        const { user } = yield exchangeCodeForToken({
          apiURI: this.config.apiURI,
          appId: this.config.appId,
          code
        });
        this.setCurrentUser(user);
        return null;
      } catch (e) {
        if (((_a = e === null || e === void 0 ? void 0 : e.body) === null || _a === void 0 ? void 0 : _a.type) === "record-not-found" && ((_c = (_b = e === null || e === void 0 ? void 0 : e.body) === null || _b === void 0 ? void 0 : _b.hint) === null || _c === void 0 ? void 0 : _c["record-type"]) === "app-oauth-code" && (yield this._hasCurrentUser())) {
          return null;
        }
        const message = ((_d = e === null || e === void 0 ? void 0 : e.body) === null || _d === void 0 ? void 0 : _d.message) || "Error logging in.";
        return { error: { message } };
      }
    });
  }
  _waitForOAuthCallbackResponse() {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this._oauthCallbackResponse;
    });
  }
  __subscribeMutationErrors(cb) {
    this.mutationErrorCbs.push(cb);
    return () => {
      this.mutationErrorCbs = this.mutationErrorCbs.filter((x) => x !== cb);
    };
  }
  subscribeAuth(cb) {
    this.authCbs.push(cb);
    const currUserCached = this._currentUserCached;
    if (!currUserCached.isLoading) {
      cb(this._currentUserCached);
    }
    let unsubbed = false;
    this.getCurrentUser().then((resp) => {
      if (unsubbed)
        return;
      if (areObjectsDeepEqual(resp, currUserCached))
        return;
      cb(resp);
    });
    return () => {
      unsubbed = true;
      this.authCbs = this.authCbs.filter((x) => x !== cb);
    };
  }
  subscribeConnectionStatus(cb) {
    this.connectionStatusCbs.push(cb);
    return () => {
      this.connectionStatusCbs = this.connectionStatusCbs.filter((x) => x !== cb);
    };
  }
  subscribeAttrs(cb) {
    this.attrsCbs.push(cb);
    if (this.attrs) {
      cb(this.attrs);
    }
    return () => {
      this.attrsCbs = this.attrsCbs.filter((x) => x !== cb);
    };
  }
  notifyAuthSubs(user) {
    this.authCbs.forEach((cb) => cb(user));
  }
  notifyMutationErrorSubs(error) {
    this.mutationErrorCbs.forEach((cb) => cb(error));
  }
  notifyAttrsSubs() {
    if (!this.attrs)
      return;
    const oas = this.optimisticAttrs();
    this.attrsCbs.forEach((cb) => cb(oas));
  }
  notifyConnectionStatusSubs(status) {
    this.connectionStatusCbs.forEach((cb) => cb(status));
  }
  setCurrentUser(user) {
    return __awaiter7(this, void 0, void 0, function* () {
      yield this._persister.setItem(currentUserKey, JSON.stringify(user));
    });
  }
  getCurrentUserCached() {
    return this._currentUserCached;
  }
  getCurrentUser() {
    return __awaiter7(this, void 0, void 0, function* () {
      const oauthResp = yield this._waitForOAuthCallbackResponse();
      if (oauthResp === null || oauthResp === void 0 ? void 0 : oauthResp.error) {
        const errorV = { error: oauthResp.error, user: void 0 };
        this._currentUserCached = Object.assign({ isLoading: false }, errorV);
        return errorV;
      }
      const user = yield this._persister.getItem(currentUserKey);
      const userV = { user: JSON.parse(user), error: void 0 };
      this._currentUserCached = Object.assign({ isLoading: false }, userV);
      return userV;
    });
  }
  _hasCurrentUser() {
    return __awaiter7(this, void 0, void 0, function* () {
      const user = yield this._persister.getItem(currentUserKey);
      return JSON.parse(user) != null;
    });
  }
  changeCurrentUser(newUser) {
    return __awaiter7(this, void 0, void 0, function* () {
      var _a;
      const { user: oldUser } = yield this.getCurrentUser();
      if (areObjectsDeepEqual(oldUser, newUser)) {
        return;
      }
      yield this.setCurrentUser(newUser);
      this.updateUser(newUser);
      try {
        (_a = this._broadcastChannel) === null || _a === void 0 ? void 0 : _a.postMessage({ type: "auth" });
      } catch (error) {
        console.error("Error posting message to broadcast channel", error);
      }
    });
  }
  updateUser(newUser) {
    const newV = { error: void 0, user: newUser };
    this._currentUserCached = Object.assign({ isLoading: false }, newV);
    this._dataForQueryCache = {};
    this.querySubs.set((prev) => {
      Object.keys(prev).forEach((k) => {
        delete prev[k].result;
      });
      return prev;
    });
    this._reconnectTimeoutMs = 0;
    this._ws.close();
    this._oauthCallbackResponse = null;
    this.notifyAuthSubs(newV);
  }
  sendMagicCode({ email }) {
    return sendMagicCode({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email
    });
  }
  signInWithMagicCode(_a) {
    return __awaiter7(this, arguments, void 0, function* ({ email, code }) {
      const res = yield verifyMagicCode({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        email,
        code
      });
      yield this.changeCurrentUser(res.user);
      return res;
    });
  }
  signInWithCustomToken(authToken) {
    return __awaiter7(this, void 0, void 0, function* () {
      const res = yield verifyRefreshToken({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        refreshToken: authToken
      });
      yield this.changeCurrentUser(res.user);
      return res;
    });
  }
  signOut() {
    return __awaiter7(this, void 0, void 0, function* () {
      var _a;
      const currentUser = yield this.getCurrentUser();
      const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;
      if (refreshToken) {
        try {
          yield signOut({
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            refreshToken
          });
        } catch (e) {
        }
      }
      yield this.changeCurrentUser(null);
    });
  }
  /**
   * Creates an OAuth authorization URL.
   * @param {Object} params - The parameters to create the authorization URL.
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.redirectURL - The URL to redirect users to after authorization.
   * @returns {string} The created authorization URL.
   */
  createAuthorizationURL({ clientName, redirectURL }) {
    const { apiURI, appId } = this.config;
    return `${apiURI}/runtime/oauth/start?app_id=${appId}&client_name=${clientName}&redirect_uri=${redirectURL}`;
  }
  exchangeCodeForToken(_a) {
    return __awaiter7(this, arguments, void 0, function* ({ code, codeVerifier }) {
      const res = yield exchangeCodeForToken({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        code,
        codeVerifier
      });
      yield this.changeCurrentUser(res.user);
      return res;
    });
  }
  issuerURI() {
    const { apiURI, appId } = this.config;
    return `${apiURI}/runtime/${appId}`;
  }
  /**
   * @param {Object} params
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.idToken - The id_token from the external service
   * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service
   */
  signInWithIdToken(_a) {
    return __awaiter7(this, arguments, void 0, function* ({ idToken, clientName, nonce }) {
      var _b;
      const currentUser = yield this.getCurrentUser();
      const refreshToken = (_b = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _b === void 0 ? void 0 : _b.refresh_token;
      const res = yield signInWithIdToken({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        idToken,
        clientName,
        nonce,
        refreshToken
      });
      yield this.changeCurrentUser(res.user);
      return res;
    });
  }
  // --------
  // Rooms
  joinRoom(roomId) {
    if (!this._rooms[roomId]) {
      this._rooms[roomId] = {
        isConnected: false,
        error: void 0
      };
    }
    this._presence[roomId] = this._presence[roomId] || {};
    this._tryJoinRoom(roomId);
    return () => {
      this._cleanupRoom(roomId);
    };
  }
  _cleanupRoom(roomId) {
    var _a, _b, _c, _d;
    if (!((_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.length) && !Object.keys((_c = this._broadcastSubs[roomId]) !== null && _c !== void 0 ? _c : {}).length) {
      const isConnected = (_d = this._rooms[roomId]) === null || _d === void 0 ? void 0 : _d.isConnected;
      delete this._rooms[roomId];
      delete this._presence[roomId];
      delete this._broadcastSubs[roomId];
      if (isConnected) {
        this._tryLeaveRoom(roomId);
      } else {
        this._roomsPendingLeave[roomId] = true;
      }
    }
  }
  // --------
  // Presence
  // TODO: look into typing again
  getPresence(roomType, roomId, opts = {}) {
    const room = this._rooms[roomId];
    const presence = this._presence[roomId];
    if (!room || !presence || !presence.result)
      return null;
    return Object.assign(Object.assign({}, buildPresenceSlice(presence.result, opts, this._sessionId)), { isLoading: !room.isConnected, error: room.error });
  }
  // TODO: look into typing again
  publishPresence(roomType, roomId, partialData) {
    const room = this._rooms[roomId];
    const presence = this._presence[roomId];
    if (!room || !presence) {
      return;
    }
    presence.result = presence.result || {};
    const data = Object.assign(Object.assign({}, presence.result.user), partialData);
    presence.result.user = data;
    if (!room.isConnected) {
      return;
    }
    this._trySetPresence(roomId, data);
    this._notifyPresenceSubs(roomId);
  }
  _trySetPresence(roomId, data) {
    this._trySendAuthed(uuid_default(), {
      op: "set-presence",
      "room-id": roomId,
      data
    });
  }
  _tryJoinRoom(roomId) {
    this._trySendAuthed(uuid_default(), { op: "join-room", "room-id": roomId });
    delete this._roomsPendingLeave[roomId];
  }
  _tryLeaveRoom(roomId) {
    this._trySendAuthed(uuid_default(), { op: "leave-room", "room-id": roomId });
  }
  // TODO: look into typing again
  subscribePresence(roomType, roomId, opts, cb) {
    const leaveRoom = this.joinRoom(roomId);
    const handler = Object.assign(Object.assign({}, opts), { roomId, cb, prev: null });
    this._presence[roomId] = this._presence[roomId] || {};
    this._presence[roomId].handlers = this._presence[roomId].handlers || [];
    this._presence[roomId].handlers.push(handler);
    this._notifyPresenceSub(roomId, handler);
    return () => {
      var _a, _b, _c;
      this._presence[roomId].handlers = (_c = (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.filter((x) => x !== handler)) !== null && _c !== void 0 ? _c : [];
      leaveRoom();
    };
  }
  _notifyPresenceSubs(roomId) {
    var _a, _b;
    (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.forEach((handler) => {
      this._notifyPresenceSub(roomId, handler);
    });
  }
  _notifyPresenceSub(roomId, handler) {
    const slice = this.getPresence("", roomId, handler);
    if (!slice) {
      return;
    }
    if (handler.prev && !hasPresenceResponseChanged(slice, handler.prev)) {
      return;
    }
    handler.prev = slice;
    handler.cb(slice);
  }
  _setPresencePeers(roomId, data) {
    const sessions = Object.assign({}, data);
    delete sessions[this._sessionId];
    const peers = Object.fromEntries(Object.entries(sessions).map(([k, v]) => [k, v.data]));
    this._presence[roomId] = this._presence[roomId] || {};
    this._presence[roomId].result = this._presence[roomId].result || {};
    this._presence[roomId].result.peers = peers;
  }
  // --------
  // Broadcast
  publishTopic({ roomType, roomId, topic, data }) {
    var _a;
    const room = this._rooms[roomId];
    if (!room) {
      return;
    }
    if (!room.isConnected) {
      this._broadcastQueue[roomId] = (_a = this._broadcastQueue[roomId]) !== null && _a !== void 0 ? _a : [];
      this._broadcastQueue[roomId].push({ topic, roomType, data });
      return;
    }
    this._tryBroadcast(roomId, roomType, topic, data);
  }
  _tryBroadcast(roomId, roomType, topic, data) {
    this._trySendAuthed(uuid_default(), {
      op: "client-broadcast",
      "room-id": roomId,
      roomType,
      topic,
      data
    });
  }
  subscribeTopic(roomId, topic, cb) {
    const leaveRoom = this.joinRoom(roomId);
    this._broadcastSubs[roomId] = this._broadcastSubs[roomId] || {};
    this._broadcastSubs[roomId][topic] = this._broadcastSubs[roomId][topic] || [];
    this._broadcastSubs[roomId][topic].push(cb);
    this._presence[roomId] = this._presence[roomId] || {};
    return () => {
      this._broadcastSubs[roomId][topic] = this._broadcastSubs[roomId][topic].filter((x) => x !== cb);
      if (!this._broadcastSubs[roomId][topic].length) {
        delete this._broadcastSubs[roomId][topic];
      }
      leaveRoom();
    };
  }
  _notifyBroadcastSubs(room, topic, msg) {
    var _a, _b, _c;
    (_c = (_b = (_a = this._broadcastSubs) === null || _a === void 0 ? void 0 : _a[room]) === null || _b === void 0 ? void 0 : _b[topic]) === null || _c === void 0 ? void 0 : _c.forEach((cb) => {
      var _a2, _b2, _c2, _d, _e, _f;
      const data = (_a2 = msg.data) === null || _a2 === void 0 ? void 0 : _a2.data;
      const peer = msg.data["peer-id"] === this._sessionId ? (_c2 = (_b2 = this._presence[room]) === null || _b2 === void 0 ? void 0 : _b2.result) === null || _c2 === void 0 ? void 0 : _c2.user : (_f = (_e = (_d = this._presence[room]) === null || _d === void 0 ? void 0 : _d.result) === null || _e === void 0 ? void 0 : _e.peers) === null || _f === void 0 ? void 0 : _f[msg.data["peer-id"]];
      return cb(data, peer);
    });
  }
  // --------
  // Storage
  upload(path, file) {
    return __awaiter7(this, void 0, void 0, function* () {
      var _a;
      const currentUser = yield this.getCurrentUser();
      const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;
      const fileName = path || file.name;
      const url = yield getSignedUploadUrl({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        fileName,
        refreshToken
      });
      const isSuccess = yield upload(url, file);
      return isSuccess;
    });
  }
  getDownloadUrl(path) {
    return __awaiter7(this, void 0, void 0, function* () {
      var _a;
      const currentUser = yield this.getCurrentUser();
      const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;
      const url = yield getDownloadUrl({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        path,
        refreshToken
      });
      return url;
    });
  }
  deleteFile(path) {
    return __awaiter7(this, void 0, void 0, function* () {
      var _a;
      const currentUser = yield this.getCurrentUser();
      const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;
      const result = yield deleteFile({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        path,
        refreshToken
      });
      return result;
    });
  }
};

// node_modules/@instantdb/core/dist/module/schemaTypes.js
var DataAttrDef = class _DataAttrDef {
  constructor(valueType, required, config = { indexed: false, unique: false }) {
    this.valueType = valueType;
    this.required = required;
    this.config = config;
  }
  optional() {
    return new _DataAttrDef(this.valueType, false);
  }
  unique() {
    return new _DataAttrDef(this.valueType, this.required, Object.assign(Object.assign({}, this.config), { unique: true }));
  }
  indexed() {
    return new _DataAttrDef(this.valueType, this.required, Object.assign(Object.assign({}, this.config), { indexed: true }));
  }
};
var EntityDef = class _EntityDef {
  constructor(attrs, links) {
    this.attrs = attrs;
    this.links = links;
  }
  asType() {
    return new _EntityDef(this.attrs, this.links);
  }
};
var InstantSchemaDef = class _InstantSchemaDef {
  constructor(entities, links, rooms) {
    this.entities = entities;
    this.links = links;
    this.rooms = rooms;
  }
  /**
   * @deprecated
   * `withRoomSchema` is deprecated. Define your schema in `rooms` directly:
   *
   * @example
   * // Before:
   * const schema = i.schema({
   *   // ...
   * }).withRoomSchema<RoomSchema>()
   *
   * // After
   * const schema = i.schema({
   *  rooms: {
   *    // ...
   *  }
   * })
   *
   * @see https://instantdb.com/docs/presence-and-topics#typesafety
   */
  withRoomSchema() {
    return new _InstantSchemaDef(this.entities, this.links, {});
  }
};

// node_modules/@instantdb/core/dist/module/schema.js
function graph(entities, links) {
  return new InstantSchemaDef(
    enrichEntitiesWithLinks(entities, links),
    // (XXX): LinksDef<any> stems from TypeScripts inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    links,
    void 0
  );
}
function entity(attrs) {
  return new EntityDef(attrs, {});
}
function string() {
  return new DataAttrDef("string", true);
}
function number() {
  return new DataAttrDef("number", true);
}
function boolean() {
  return new DataAttrDef("boolean", true);
}
function date() {
  return new DataAttrDef("date", true);
}
function json() {
  return new DataAttrDef("json", true);
}
function any() {
  return new DataAttrDef("json", true);
}
function enrichEntitiesWithLinks(entities, links) {
  var _a, _b, _c, _d;
  const linksIndex = { fwd: {}, rev: {} };
  for (const linkDef of Object.values(links)) {
    (_a = linksIndex.fwd)[_b = linkDef.forward.on] || (_a[_b] = {});
    (_c = linksIndex.rev)[_d = linkDef.reverse.on] || (_c[_d] = {});
    linksIndex.fwd[linkDef.forward.on][linkDef.forward.label] = {
      entityName: linkDef.reverse.on,
      cardinality: linkDef.forward.has
    };
    linksIndex.rev[linkDef.reverse.on][linkDef.reverse.label] = {
      entityName: linkDef.forward.on,
      cardinality: linkDef.reverse.has
    };
  }
  const enrichedEntities = Object.fromEntries(Object.entries(entities).map(([name, def]) => [
    name,
    new EntityDef(def.attrs, Object.assign(Object.assign({}, linksIndex.fwd[name]), linksIndex.rev[name]))
  ]));
  return enrichedEntities;
}
function schema({ entities, links, rooms }) {
  const linksDef = links !== null && links !== void 0 ? links : {};
  const roomsDef = rooms !== null && rooms !== void 0 ? rooms : {};
  return new InstantSchemaDef(
    enrichEntitiesWithLinks(entities, linksDef),
    // (XXX): LinksDef<any> stems from TypeScripts inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    linksDef,
    roomsDef
  );
}
var i = {
  // constructs
  graph,
  schema,
  entity,
  // value types
  string,
  number,
  boolean,
  date,
  json,
  any
};

// node_modules/@instantdb/core/dist/module/devtool.js
var currentDevtool;
function createDevtool(appId) {
  currentDevtool === null || currentDevtool === void 0 ? void 0 : currentDevtool.dispose();
  const container = createContainer();
  const toggler = createToggler(toggleView);
  const iframe = createIframe(getSrc(appId));
  function onPostMessage(event) {
    var _a;
    if (event.source !== iframe.element.contentWindow)
      return;
    if (((_a = event.data) === null || _a === void 0 ? void 0 : _a.type) === "close" && container.isVisible()) {
      toggleView();
    }
  }
  function onKeyDown(event) {
    const isToggleShortcut = event.shiftKey && event.ctrlKey && event.key === "0";
    const isEsc = event.key === "Escape" || event.key === "Esc";
    if (isToggleShortcut) {
      toggleView();
    } else if (isEsc && container.isVisible()) {
      toggleView();
    }
  }
  function toggleView() {
    if (container.isVisible()) {
      container.element.style.display = "none";
    } else {
      container.element.style.display = "block";
      if (!container.element.contains(iframe.element)) {
        container.element.appendChild(iframe.element);
      }
    }
  }
  function dispose() {
    container.element.remove();
    toggler.element.remove();
    removeEventListener("keydown", onKeyDown);
    removeEventListener("message", onPostMessage);
  }
  function create2() {
    document.body.appendChild(container.element);
    document.body.appendChild(toggler.element);
    addEventListener("keydown", onKeyDown);
    addEventListener("message", onPostMessage);
    currentDevtool = {
      dispose
    };
  }
  return create2();
}
function getSrc(appId) {
  const isDev = window.DEV_DEVTOOL;
  const src = `${isDev ? "http://localhost:3000" : "https://instantdb.com"}/_devtool?appId=${appId}`;
  return src;
}
function createIframe(src) {
  const element = document.createElement("iframe");
  element.src = src;
  element.className = "instant-devtool-iframe";
  Object.assign(element.style, {
    width: "100%",
    height: "100%",
    borderRadius: "4px",
    backgroundColor: "white",
    border: "none"
  });
  return { element };
}
function createToggler(onClick) {
  const logoSVG = `
    <svg width="32" height="32" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect width="512" height="512" fill="black"/>
      <rect x="97.0973" y="91.3297" width="140" height="330" fill="white"/>
    </svg>
  `;
  const element = document.createElement("button");
  element.innerHTML = logoSVG;
  element.className = "instant-devtool-toggler";
  Object.assign(element.style, {
    // pos
    position: "fixed",
    bottom: "24px",
    left: "24px",
    height: "32px",
    width: "32px",
    // layout
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    // look
    padding: "0",
    margin: "0",
    border: "none",
    cursor: "pointer"
  });
  element.addEventListener("click", onClick);
  return { element };
}
function createContainer() {
  const element = document.createElement("div");
  Object.assign(element.style, {
    position: "fixed",
    bottom: "24px",
    right: "24px",
    left: "60px",
    top: "72px",
    display: "block",
    borderRadius: "4px",
    border: "1px #ccc solid",
    boxShadow: "0px 0px 8px #00000044",
    backgroundColor: "#eee",
    zIndex: "999990"
  });
  element.style.display = "none";
  element.className = "instant-devtool-container";
  function isVisible() {
    return element.style.display !== "none";
  }
  return { element, isVisible };
}

// node_modules/@instantdb/core/dist/module/index.js
var defaultOpenDevtool = true;
var defaultConfig2 = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
};
function initGlobalInstantCoreStore() {
  var _a;
  globalThis.__instantDbStore = (_a = globalThis.__instantDbStore) !== null && _a !== void 0 ? _a : {};
  return globalThis.__instantDbStore;
}
var globalInstantCoreStore = initGlobalInstantCoreStore();
var Auth = class {
  constructor(db) {
    this.db = db;
    this.sendMagicCode = (params) => {
      return this.db.sendMagicCode(params);
    };
    this.signInWithMagicCode = (params) => {
      return this.db.signInWithMagicCode(params);
    };
    this.signInWithToken = (token) => {
      return this.db.signInWithCustomToken(token);
    };
    this.createAuthorizationURL = (params) => {
      return this.db.createAuthorizationURL(params);
    };
    this.signInWithIdToken = (params) => {
      return this.db.signInWithIdToken(params);
    };
    this.exchangeOAuthCode = (params) => {
      return this.db.exchangeCodeForToken(params);
    };
    this.issuerURI = () => {
      return this.db.issuerURI();
    };
    this.signOut = () => {
      return this.db.signOut();
    };
  }
};
var Storage = class {
  constructor(db) {
    this.db = db;
    this.upload = (pathname, file) => {
      return this.db.upload(pathname, file);
    };
    this.put = this.upload;
    this.getDownloadUrl = (pathname) => {
      return this.db.getDownloadUrl(pathname);
    };
    this.delete = (pathname) => {
      return this.db.deleteFile(pathname);
    };
  }
};
function coerceQuery(o) {
  return JSON.parse(JSON.stringify(o));
}
var InstantCoreDatabase = class {
  constructor(reactor) {
    this.tx = txInit();
    this._reactor = reactor;
    this.auth = new Auth(this._reactor);
    this.storage = new Storage(this._reactor);
  }
  /**
   * Use this to write data! You can create, update, delete, and link objects
   *
   * @see https://instantdb.com/docs/instaml
   *
   * @example
   *   // Create a new object in the `goals` namespace
   *   const goalId = id();
   *   db.transact(tx.goals[goalId].update({title: "Get fit"}))
   *
   *   // Update the title
   *   db.transact(tx.goals[goalId].update({title: "Get super fit"}))
   *
   *   // Delete it
   *   db.transact(tx.goals[goalId].delete())
   *
   *   // Or create an association:
   *   todoId = id();
   *   db.transact([
   *    tx.todos[todoId].update({ title: 'Go on a run' }),
   *    tx.goals[goalId].link({todos: todoId}),
   *  ])
   */
  transact(chunks) {
    return this._reactor.pushTx(chunks);
  }
  getLocalId(name) {
    return this._reactor.getLocalId(name);
  }
  /**
   * Use this to query your data!
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  // listen to all goals
   *  db.subscribeQuery({ goals: {} }, (resp) => {
   *    console.log(resp.data.goals)
   *  })
   *
   *  // goals where the title is "Get Fit"
   *  db.subscribeQuery(
   *    { goals: { $: { where: { title: "Get Fit" } } } },
   *    (resp) => {
   *      console.log(resp.data.goals)
   *    }
   *  )
   *
   *  // all goals, _alongside_ their todos
   *  db.subscribeQuery({ goals: { todos: {} } }, (resp) => {
   *    console.log(resp.data.goals)
   *  });
   */
  subscribeQuery(query3, cb) {
    return this._reactor.subscribeQuery(query3, cb);
  }
  /**
   * Listen for the logged in state. This is useful
   * for deciding when to show a login screen.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const unsub = db.subscribeAuth((auth) => {
   *     if (auth.user) {
   *     console.log('logged in as', auth.user.email)
   *    } else {
   *      console.log('logged out')
   *    }
   *  })
   */
  subscribeAuth(cb) {
    return this._reactor.subscribeAuth(cb);
  }
  /**
   * Listen for connection status changes to Instant. This is useful
   * for building things like connectivity indicators
   *
   * @see https://www.instantdb.com/docs/patterns#connection-status
   * @example
   *   const unsub = db.subscribeConnectionStatus((status) => {
   *     const connectionState =
   *       status === 'connecting' || status === 'opened'
   *         ? 'authenticating'
   *       : status === 'authenticated'
   *         ? 'connected'
   *       : status === 'closed'
   *         ? 'closed'
   *       : status === 'errored'
   *         ? 'errored'
   *       : 'unexpected state';
   *
   *     console.log('Connection status:', connectionState);
   *   });
   */
  subscribeConnectionStatus(cb) {
    return this._reactor.subscribeConnectionStatus(cb);
  }
  /**
   * Join a room to publish and subscribe to topics and presence.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   * @example
   * // init
   * const db = init();
   * const room = db.joinRoom(roomType, roomId);
   * // usage
   * const unsubscribeTopic = room.subscribeTopic("foo", console.log);
   * const unsubscribePresence = room.subscribePresence({}, console.log);
   * room.publishTopic("hello", { message: "hello world!" });
   * room.publishPresence({ name: "joe" });
   * // later
   * unsubscribePresence();
   * unsubscribeTopic();
   * room.leaveRoom();
   */
  joinRoom(roomType = "_defaultRoomType", roomId = "_defaultRoomId") {
    const leaveRoom = this._reactor.joinRoom(roomId);
    return {
      leaveRoom,
      subscribeTopic: (topic, onEvent) => this._reactor.subscribeTopic(roomId, topic, onEvent),
      subscribePresence: (opts, onChange) => this._reactor.subscribePresence(roomType, roomId, opts, onChange),
      publishTopic: (topic, data) => this._reactor.publishTopic({ roomType, roomId, topic, data }),
      publishPresence: (data) => this._reactor.publishPresence(roomType, roomId, data),
      getPresence: (opts) => this._reactor.getPresence(roomType, roomId, opts)
    };
  }
  shutdown() {
    delete globalInstantCoreStore[this._reactor.config.appId];
    this._reactor.shutdown();
  }
  /**
   * Use this for one-off queries.
   * Returns local data if available, otherwise fetches from the server.
   * Because we want to avoid stale data, this method will throw an error
   * if the user is offline or there is no active connection to the server.
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *
   *  const resp = await db.queryOnce({ goals: {} });
   *  console.log(resp.data.goals)
   */
  queryOnce(query3) {
    return this._reactor.queryOnce(query3);
  }
};
function init(config, Storage2, NetworkListener, versions) {
  const existingClient = globalInstantCoreStore[config.appId];
  if (existingClient) {
    return existingClient;
  }
  const reactor = new Reactor(Object.assign(Object.assign(Object.assign({}, defaultConfig2), config), { cardinalityInference: config.schema ? true : false }), Storage2 || IndexedDBStorage, NetworkListener || WindowNetworkListener, Object.assign(Object.assign({}, versions || {}), { "@instantdb/core": version_default2 }));
  const client = new InstantCoreDatabase(reactor);
  globalInstantCoreStore[config.appId] = client;
  if (typeof window !== "undefined" && typeof window.location !== "undefined") {
    const showDevtool = (
      // show widget by default?
      ("devtool" in config ? Boolean(config.devtool) : defaultOpenDevtool) && // only run on localhost (dev env)
      window.location.hostname === "localhost" && // used by dash and other internal consumers
      !Boolean(globalThis._nodevtool)
    );
    if (showDevtool) {
      createDevtool(config.appId);
    }
  }
  return client;
}

// node_modules/@instantdb/react/dist/module/InstantReactAbstractDatabase.js
var import_react3 = __toESM(require_react());

// node_modules/@instantdb/react/dist/module/useQuery.js
var import_react = __toESM(require_react());
var defaultState = {
  isLoading: true,
  data: void 0,
  pageInfo: void 0,
  error: void 0
};
function stateForResult(result) {
  return Object.assign({ isLoading: !Boolean(result), data: void 0, pageInfo: void 0, error: void 0 }, result ? result : {});
}
function useQueryInternal(_core, _query) {
  const query3 = _query ? coerceQuery(_query) : null;
  const queryHash = weakHash(query3);
  const resultCacheRef = (0, import_react.useRef)(stateForResult(_core._reactor.getPreviousResult(query3)));
  const subscribe = (0, import_react.useCallback)(
    (cb) => {
      if (!query3) {
        const unsubscribe2 = () => {
        };
        return unsubscribe2;
      }
      const unsubscribe = _core.subscribeQuery(query3, (result) => {
        resultCacheRef.current = Object.assign({ isLoading: !Boolean(result), data: void 0, pageInfo: void 0, error: void 0 }, result);
        cb();
      });
      return unsubscribe;
    },
    // Build a new subscribe function if the query changes
    [queryHash]
  );
  const state = (0, import_react.useSyncExternalStore)(subscribe, () => resultCacheRef.current, () => defaultState);
  return { state, query: query3 };
}

// node_modules/@instantdb/react/dist/module/useTimeout.js
var import_react2 = __toESM(require_react());
function useTimeout() {
  const timeoutRef = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    clear();
  }, []);
  function set2(delay, fn) {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(fn, delay);
  }
  function clear() {
    clearTimeout(timeoutRef.current);
  }
  return { set: set2, clear };
}

// node_modules/@instantdb/react/dist/module/InstantReactAbstractDatabase.js
var defaultActivityStopTimeout = 1e3;
var InstantReactRoom = class {
  constructor(_core, type, id2) {
    this.useTopicEffect = (topic, onEvent) => {
      (0, import_react3.useEffect)(() => {
        const unsub = this._core._reactor.subscribeTopic(this.id, topic, (event, peer) => {
          onEvent(event, peer);
        });
        return unsub;
      }, [this.id, topic]);
    };
    this.usePublishTopic = (topic) => {
      (0, import_react3.useEffect)(() => this._core._reactor.joinRoom(this.id), [this.id]);
      const publishTopic = (0, import_react3.useCallback)((data) => {
        this._core._reactor.publishTopic({
          roomType: this.type,
          roomId: this.id,
          topic,
          data
        });
      }, [this.id, topic]);
      return publishTopic;
    };
    this.usePresence = (opts = {}) => {
      var _a, _b;
      const [state, setState] = (0, import_react3.useState)(() => {
        var _a2;
        return (_a2 = this._core._reactor.getPresence(this.type, this.id, opts)) !== null && _a2 !== void 0 ? _a2 : {
          peers: {},
          isLoading: true
        };
      });
      (0, import_react3.useEffect)(() => {
        const unsub = this._core._reactor.subscribePresence(this.type, this.id, opts, (data) => {
          setState(data);
        });
        return unsub;
      }, [this.id, opts.user, (_a = opts.peers) === null || _a === void 0 ? void 0 : _a.join(), (_b = opts.keys) === null || _b === void 0 ? void 0 : _b.join()]);
      return Object.assign(Object.assign({}, state), { publishPresence: (data) => {
        this._core._reactor.publishPresence(this.type, this.id, data);
      } });
    };
    this.useSyncPresence = (data, deps) => {
      (0, import_react3.useEffect)(() => this._core._reactor.joinRoom(this.id), [this.id]);
      (0, import_react3.useEffect)(() => {
        return this._core._reactor.publishPresence(this.type, this.id, data);
      }, [this.type, this.id, deps !== null && deps !== void 0 ? deps : JSON.stringify(data)]);
    };
    this.useTypingIndicator = (inputName, opts = {}) => {
      const timeout = useTimeout();
      const onservedPresence = this.usePresence({
        keys: [inputName]
      });
      const active = (0, import_react3.useMemo)(() => {
        var _a;
        const presenceSnapshot = this._core._reactor.getPresence(this.type, this.id);
        return (opts === null || opts === void 0 ? void 0 : opts.writeOnly) ? [] : Object.values((_a = presenceSnapshot === null || presenceSnapshot === void 0 ? void 0 : presenceSnapshot.peers) !== null && _a !== void 0 ? _a : {}).filter((p) => p[inputName] === true);
      }, [opts === null || opts === void 0 ? void 0 : opts.writeOnly, onservedPresence]);
      const setActive = (isActive) => {
        var _a;
        this._core._reactor.publishPresence(this.type, this.id, {
          [inputName]: isActive
        });
        if (!isActive)
          return;
        if ((opts === null || opts === void 0 ? void 0 : opts.timeout) === null || (opts === null || opts === void 0 ? void 0 : opts.timeout) === 0)
          return;
        timeout.set((_a = opts === null || opts === void 0 ? void 0 : opts.timeout) !== null && _a !== void 0 ? _a : defaultActivityStopTimeout, () => {
          this._core._reactor.publishPresence(this.type, this.id, {
            [inputName]: null
          });
        });
      };
      return {
        active,
        setActive: (a) => {
          setActive(a);
        },
        inputProps: {
          onKeyDown: (e) => {
            const isEnter = (opts === null || opts === void 0 ? void 0 : opts.stopOnEnter) && e.key === "Enter";
            const isActive = !isEnter;
            setActive(isActive);
          },
          onBlur: () => {
            setActive(false);
          }
        }
      };
    };
    this._core = _core;
    this.type = type;
    this.id = id2;
  }
};
var defaultAuthState = {
  isLoading: true,
  user: void 0,
  error: void 0
};
var InstantReactAbstractDatabase = class {
  constructor(config, versions) {
    this.tx = txInit();
    this.getLocalId = (name) => {
      return this._core.getLocalId(name);
    };
    this.transact = (chunks) => {
      return this._core.transact(chunks);
    };
    this.useQuery = (query3) => {
      return useQueryInternal(this._core, query3).state;
    };
    this.useAuth = () => {
      const resultCacheRef = (0, import_react3.useRef)(this._core._reactor._currentUserCached);
      const subscribe = (0, import_react3.useCallback)((cb) => {
        const unsubscribe = this._core.subscribeAuth((auth) => {
          resultCacheRef.current = Object.assign({ isLoading: false }, auth);
          cb();
        });
        return unsubscribe;
      }, []);
      const state = (0, import_react3.useSyncExternalStore)(subscribe, () => resultCacheRef.current, () => defaultAuthState);
      return state;
    };
    this.useConnectionStatus = () => {
      const statusRef = (0, import_react3.useRef)(this._core._reactor.status);
      const subscribe = (0, import_react3.useCallback)((cb) => {
        const unsubscribe = this._core.subscribeConnectionStatus((newStatus) => {
          if (newStatus !== statusRef.current) {
            statusRef.current = newStatus;
            cb();
          }
        });
        return unsubscribe;
      }, []);
      const status = (0, import_react3.useSyncExternalStore)(
        subscribe,
        () => statusRef.current,
        // For SSR, always return 'connecting' as the initial state
        () => "connecting"
      );
      return status;
    };
    this.queryOnce = (query3) => {
      return this._core.queryOnce(query3);
    };
    this._core = init(
      config,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.Storage,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.NetworkListener,
      versions
    );
    this.auth = this._core.auth;
    this.storage = this._core.storage;
  }
  /**
   * Obtain a handle to a room, which allows you to listen to topics and presence data
   *
   * If you don't provide a `type` or `id`, Instant will default to `_defaultRoomType` and `_defaultRoomId`
   * as the room type and id, respectively.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   *
   * @example
   *  const {
   *   useTopicEffect,
   *   usePublishTopic,
   *   useSyncPresence,
   *   useTypingIndicator,
   * } = db.room(roomType, roomId);
   */
  room(type = "_defaultRoomType", id2 = "_defaultRoomId") {
    return new InstantReactRoom(this._core, type, id2);
  }
};

// node_modules/@instantdb/react/dist/module/InstantReactWebDatabase.js
var InstantReactWebDatabase = class extends InstantReactAbstractDatabase {
};

// node_modules/@instantdb/react/dist/module/version.js
var version2 = "v0.17.3";
var version_default3 = version2;

// node_modules/@instantdb/react/dist/module/init.js
function init2(config) {
  return new InstantReactWebDatabase(config, {
    "@instantdb/react": version_default3
  });
}
var init_experimental = init2;

// node_modules/@instantdb/react/dist/module/Cursors.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react4 = __toESM(require_react());
function Cursors({ as = "div", spaceId: _spaceId, room, className, style, userCursorColor, children, renderCursor, propagate, zIndex }) {
  const spaceId = _spaceId || `cursors-space-default--${String(room.type)}-${room.id}`;
  const cursorsPresence = room.usePresence({
    keys: [spaceId]
  });
  const fullPresence = room._core._reactor.getPresence(room.type, room.id);
  function publishCursor(rect, touch) {
    const x = touch.clientX;
    const y = touch.clientY;
    const xPercent = (x - rect.left) / rect.width * 100;
    const yPercent = (y - rect.top) / rect.height * 100;
    cursorsPresence.publishPresence({
      [spaceId]: {
        x,
        y,
        xPercent,
        yPercent,
        color: userCursorColor
      }
    });
  }
  function onMouseMove(e) {
    if (!propagate) {
      e.stopPropagation();
    }
    const rect = e.currentTarget.getBoundingClientRect();
    publishCursor(rect, e);
  }
  function onMouseOut(e) {
    cursorsPresence.publishPresence({
      [spaceId]: void 0
    });
  }
  function onTouchMove(e) {
    if (e.touches.length !== 1) {
      return;
    }
    const touch = e.touches[0];
    if (touch.target instanceof Element) {
      if (!propagate) {
        e.stopPropagation();
      }
      const rect = touch.target.getBoundingClientRect();
      publishCursor(rect, touch);
    }
  }
  function onTouchEnd(e) {
    cursorsPresence.publishPresence({
      [spaceId]: void 0
    });
  }
  return (0, import_react4.createElement)(as, {
    onMouseMove,
    onMouseOut,
    onTouchMove,
    onTouchEnd,
    className,
    style: Object.assign({ position: "relative" }, style)
  }, [
    children,
    (0, import_jsx_runtime.jsx)("div", { style: Object.assign(Object.assign(Object.assign({}, absStyles), inertStyles), { zIndex: zIndex !== void 0 ? zIndex : defaultZ }), children: Object.entries(cursorsPresence.peers).map(([id2, presence]) => {
      const cursor = presence[spaceId];
      if (!cursor)
        return null;
      return (0, import_jsx_runtime.jsx)("div", { style: Object.assign(Object.assign({}, absStyles), { transform: `translate(${cursor.xPercent}%, ${cursor.yPercent}%)`, transformOrigin: "0 0", transition: "transform 100ms" }), children: renderCursor ? renderCursor({
        color: cursor.color,
        presence: fullPresence.peers[id2]
      }) : (0, import_jsx_runtime.jsx)(Cursor, Object.assign({}, cursor)) }, id2);
    }) }, spaceId)
  ]);
}
function Cursor({ color }) {
  const size = 35;
  const fill = color || "black";
  return (0, import_jsx_runtime.jsxs)("svg", { style: { height: size, width: size }, viewBox: `0 0 ${size} ${size}`, fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsxs)("g", { fill: "rgba(0,0,0,.2)", transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)", children: [(0, import_jsx_runtime.jsx)("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }), (0, import_jsx_runtime.jsx)("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })] }), (0, import_jsx_runtime.jsxs)("g", { fill: "white", transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)", children: [(0, import_jsx_runtime.jsx)("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }), (0, import_jsx_runtime.jsx)("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })] }), (0, import_jsx_runtime.jsxs)("g", { fill, transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)", children: [(0, import_jsx_runtime.jsx)("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }), (0, import_jsx_runtime.jsx)("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })] })] });
}
var absStyles = {
  position: "absolute",
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};
var inertStyles = {
  overflow: "hidden",
  pointerEvents: "none",
  userSelect: "none"
};
var defaultZ = 99999;
export {
  Cursors,
  InstantReactAbstractDatabase,
  InstantReactWebDatabase,
  i,
  uuid_default as id,
  init2 as init,
  init_experimental,
  lookup,
  tx
};
//# sourceMappingURL=@instantdb_react.js.map
