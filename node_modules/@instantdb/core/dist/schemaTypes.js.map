{"version":3,"file":"schemaTypes.js","sourceRoot":"","sources":["../src/schemaTypes.ts"],"names":[],"mappings":";;;AAEA,MAAa,WAAW;IACtB,YACS,SAAqB,EACrB,QAAoB,EACpB,SAIH,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE;QAN9B,cAAS,GAAT,SAAS,CAAY;QACrB,aAAQ,GAAR,QAAQ,CAAY;QACpB,WAAM,GAAN,MAAM,CAIwB;IACpC,CAAC;IAEJ,QAAQ;QACN,OAAO,IAAI,WAAW,CAAmB,IAAI,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;IAClE,CAAC;IAED,MAAM;QACJ,OAAO,IAAI,WAAW,CACpB,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,QAAQ,kCAER,IAAI,CAAC,MAAM,KACd,MAAM,EAAE,IAAI,IAEf,CAAC;IACJ,CAAC;IAED,OAAO;QACL,OAAO,IAAI,WAAW,CACpB,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,QAAQ,kCAER,IAAI,CAAC,MAAM,KACd,OAAO,EAAE,IAAI,IAEhB,CAAC;IACJ,CAAC;CAQF;AA3CD,kCA2CC;AASD,MAAa,WAAW;IAItB,YACS,WAAwB,EACxB,UAAsB;QADtB,gBAAW,GAAX,WAAW,CAAa;QACxB,eAAU,GAAV,UAAU,CAAY;IAC5B,CAAC;CACL;AARD,kCAQC;AAmBD,MAAa,SAAS;IAKpB,YACS,KAAY,EACZ,KAAY;QADZ,UAAK,GAAL,KAAK,CAAO;QACZ,UAAK,GAAL,KAAK,CAAO;IAClB,CAAC;IAEJ,MAAM;QAKJ,OAAO,IAAI,SAAS,CAAwB,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;IACtE,CAAC;CACF;AAjBD,8BAiBC;AAmMD,MAAa,gBAAgB;IAM3B,YACS,QAAkB,EAClB,KAAY,EACZ,KAAY;QAFZ,aAAQ,GAAR,QAAQ,CAAU;QAClB,UAAK,GAAL,KAAK,CAAO;QACZ,UAAK,GAAL,KAAK,CAAO;IAClB,CAAC;IAEJ;;;;;;;;;;;;;;;;;;OAkBG;IACH,cAAc;QAEZ,OAAO,IAAI,gBAAgB,CACzB,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,KAAK,EACV,EAAU,CACX,CAAC;IACJ,CAAC;CACF;AAvCD,4CAuCC;AAED;;;;;GAKG;AACH,MAAa,YAAY;IAMvB,YACS,QAAkB,EAClB,KAAY;QADZ,aAAQ,GAAR,QAAQ,CAAU;QAClB,UAAK,GAAL,KAAK,CAAO;IAClB,CAAC;IAEJ,cAAc;QACZ,OAAO,IAAI,YAAY,CACrB,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,KAAK,CACX,CAAC;IACJ,CAAC;CACF;AAjBD,oCAiBC","sourcesContent":["import type { RoomSchemaShape } from \"./presence\";\n\nexport class DataAttrDef<ValueType, IsRequired extends boolean> {\n  constructor(\n    public valueType: ValueTypes,\n    public required: IsRequired,\n    public config: {\n      indexed: boolean;\n      unique: boolean;\n      // clientValidator?: (value: ValueType) => boolean;\n    } = { indexed: false, unique: false },\n  ) {}\n\n  optional() {\n    return new DataAttrDef<ValueType, false>(this.valueType, false);\n  }\n\n  unique() {\n    return new DataAttrDef<ValueType, IsRequired>(\n      this.valueType,\n      this.required,\n      {\n        ...this.config,\n        unique: true,\n      },\n    );\n  }\n\n  indexed() {\n    return new DataAttrDef<ValueType, IsRequired>(\n      this.valueType,\n      this.required,\n      {\n        ...this.config,\n        indexed: true,\n      },\n    );\n  }\n\n  // clientValidate(clientValidator: (value: ValueType) => boolean) {\n  //   return new DataAttrDef(this.valueType, this.required, {\n  //     ...this.config,\n  //     clientValidator,\n  //   });\n  // }\n}\n\ntype ExtractValueType<T> =\n  T extends DataAttrDef<infer ValueType, infer isRequired>\n    ? isRequired extends true\n      ? ValueType\n      : ValueType | undefined\n    : never;\n\nexport class LinkAttrDef<\n  Cardinality extends CardinalityKind,\n  EntityName extends string,\n> {\n  constructor(\n    public cardinality: Cardinality,\n    public entityName: EntityName,\n  ) {}\n}\n\nexport interface IContainEntitiesAndLinks<\n  Entities extends EntitiesDef,\n  Links extends LinksDef<Entities>,\n> {\n  entities: Entities;\n  links: Links;\n}\n\n// ==========\n// base types\n\nexport type ValueTypes = \"string\" | \"number\" | \"boolean\" | \"date\" | \"json\";\n\nexport type CardinalityKind = \"one\" | \"many\";\n\nexport type AttrsDefs = Record<string, DataAttrDef<any, any>>;\n\nexport class EntityDef<\n  Attrs extends AttrsDefs,\n  Links extends Record<string, LinkAttrDef<any, any>>,\n  AsType,\n> {\n  constructor(\n    public attrs: Attrs,\n    public links: Links,\n  ) {}\n\n  asType<\n    _AsType extends Partial<{\n      [AttrName in keyof Attrs]: ExtractValueType<Attrs[AttrName]>;\n    }>,\n  >() {\n    return new EntityDef<Attrs, Links, _AsType>(this.attrs, this.links);\n  }\n}\n\nexport type EntitiesDef = Record<string, EntityDef<any, any, any>>;\n\nexport type LinksDef<Entities extends EntitiesDef> = Record<\n  string,\n  LinkDef<\n    Entities,\n    keyof Entities,\n    string,\n    CardinalityKind,\n    keyof Entities,\n    string,\n    CardinalityKind\n  >\n>;\n\nexport type LinkDef<\n  Entities extends EntitiesDef,\n  FwdEntity extends keyof Entities,\n  FwdAttr extends string,\n  FwdCardinality extends CardinalityKind,\n  RevEntity extends keyof Entities,\n  RevAttr extends string,\n  RevCardinality extends CardinalityKind,\n> = {\n  forward: {\n    on: FwdEntity;\n    label: FwdAttr;\n    has: FwdCardinality;\n  };\n  reverse: {\n    on: RevEntity;\n    label: RevAttr;\n    has: RevCardinality;\n  };\n};\n\n// ==========\n// derived types\n\nexport type EntitiesWithLinks<\n  Entities extends EntitiesDef,\n  Links extends LinksDef<Entities>,\n> = {\n  [EntityName in keyof Entities]: EntityDef<\n    Entities[EntityName][\"attrs\"],\n    EntityForwardLinksMap<EntityName, Entities, Links> &\n      EntityReverseLinksMap<EntityName, Entities, Links>,\n    Entities[EntityName] extends EntityDef<any, any, infer O>\n      ? O extends void\n        ? void\n        : O\n      : void\n  >;\n};\n\ntype EntityForwardLinksMap<\n  EntityName extends keyof Entities,\n  Entities extends EntitiesDef,\n  Links extends LinksDef<Entities>,\n  LinkIndexFwd = LinksIndexedByEntity<Entities, Links, \"reverse\">,\n> = EntityName extends keyof LinkIndexFwd\n  ? {\n      [LinkName in keyof LinkIndexFwd[EntityName]]: LinkIndexFwd[EntityName][LinkName] extends LinkDef<\n        Entities,\n        infer RelatedEntityName,\n        any,\n        any,\n        any,\n        any,\n        infer Cardinality\n      >\n        ? {\n            entityName: RelatedEntityName;\n            cardinality: Cardinality;\n          }\n        : never;\n    }\n  : {};\n\ntype EntityReverseLinksMap<\n  EntityName extends keyof Entities,\n  Entities extends EntitiesDef,\n  Links extends LinksDef<Entities>,\n  RevLinkIndex = LinksIndexedByEntity<Entities, Links, \"forward\">,\n> = EntityName extends keyof RevLinkIndex\n  ? {\n      [LinkName in keyof RevLinkIndex[EntityName]]: RevLinkIndex[EntityName][LinkName] extends LinkDef<\n        Entities,\n        any,\n        any,\n        infer Cardinality,\n        infer RelatedEntityName,\n        any,\n        any\n      >\n        ? {\n            entityName: RelatedEntityName;\n            cardinality: Cardinality;\n          }\n        : never;\n    }\n  : {};\n\ntype LinksIndexedByEntity<\n  Entities extends EntitiesDef,\n  Links extends LinksDef<Entities>,\n  Direction extends \"forward\" | \"reverse\",\n> = {\n  [FwdEntity in keyof Entities]: {\n    [LinkName in keyof Links as Links[LinkName][Direction][\"on\"] extends FwdEntity\n      ? Links[LinkName][Direction][\"label\"]\n      : never]: Links[LinkName] extends LinkDef<\n      Entities,\n      infer FwdEntity,\n      infer FwdAttr,\n      infer FwdCardinality,\n      infer RevEntity,\n      infer RevAttr,\n      infer RevCardinality\n    >\n      ? LinkDef<\n          Entities,\n          FwdEntity,\n          FwdAttr,\n          FwdCardinality,\n          RevEntity,\n          RevAttr,\n          RevCardinality\n        >\n      : never;\n  };\n};\n\nexport type ResolveEntityAttrs<\n  EDef extends EntityDef<any, any, any>,\n  ResolvedAttrs = {\n    [AttrName in keyof EDef[\"attrs\"]]: ExtractValueType<\n      EDef[\"attrs\"][AttrName]\n    >;\n  },\n> =\n  EDef extends EntityDef<any, any, infer AsType>\n    ? AsType extends void\n      ? ResolvedAttrs\n      : Omit<ResolvedAttrs, keyof AsType> & AsType\n    : ResolvedAttrs;\n\nexport type ResolveAttrs<\n  Entities extends EntitiesDef,\n  EntityName extends keyof Entities,\n> = ResolveEntityAttrs<Entities[EntityName]>;\n\nexport type RoomsFromDef<RDef extends RoomsDef> = {\n  [RoomName in keyof RDef]: {\n    presence: ResolveEntityAttrs<RDef[RoomName][\"presence\"]>;\n    topics: {\n      [TopicName in keyof RDef[RoomName][\"topics\"]]: ResolveEntityAttrs<\n        RDef[RoomName][\"topics\"][TopicName]\n      >;\n    };\n  };\n};\n\nexport type RoomsOf<S> =\n  S extends InstantSchemaDef<any, any, infer RDef> ? RoomsFromDef<RDef> : never;\n\nexport type PresenceOf<\n  S,\n  RoomType extends keyof RoomsOf<S>,\n> = RoomsOf<S>[RoomType] extends { presence: infer P } ? P : {};\n\nexport type TopicsOf<\n  S,\n  RoomType extends keyof RoomsOf<S>,\n> = RoomsOf<S>[RoomType] extends { topics: infer T } ? T : {};\n\nexport type TopicOf<\n  S,\n  RoomType extends keyof RoomsOf<S>,\n  TopicType extends keyof TopicsOf<S, RoomType>,\n> = TopicsOf<S, RoomType>[TopicType];\n\ninterface RoomDef {\n  presence: EntityDef<any, any, any>;\n  topics?: {\n    [TopicName: string]: EntityDef<any, any, any>;\n  };\n}\n\nexport interface RoomsDef {\n  [RoomType: string]: RoomDef;\n}\n\nexport class InstantSchemaDef<\n  Entities extends EntitiesDef,\n  Links extends LinksDef<Entities>,\n  Rooms extends RoomsDef,\n> implements IContainEntitiesAndLinks<Entities, Links>\n{\n  constructor(\n    public entities: Entities,\n    public links: Links,\n    public rooms: Rooms,\n  ) {}\n\n  /**\n   * @deprecated\n   * `withRoomSchema` is deprecated. Define your schema in `rooms` directly:\n   *\n   * @example\n   * // Before:\n   * const schema = i.schema({\n   *   // ...\n   * }).withRoomSchema<RoomSchema>()\n   *\n   * // After\n   * const schema = i.schema({\n   *  rooms: {\n   *    // ...\n   *  }\n   * })\n   *\n   * @see https://instantdb.com/docs/presence-and-topics#typesafety\n   */\n  withRoomSchema<_RoomSchema extends RoomSchemaShape>() {\n    type RDef = RoomDefFromShape<_RoomSchema>;\n    return new InstantSchemaDef<Entities, Links, RDef>(\n      this.entities,\n      this.links,\n      {} as RDef,\n    );\n  }\n}\n\n/**\n * @deprecated\n * `i.graph` is deprecated. Use `i.schema` instead.\n *\n * @see https://instantdb.com/docs/modeling-data\n */\nexport class InstantGraph<\n  Entities extends EntitiesDef,\n  Links extends LinksDef<Entities>,\n  RoomSchema extends RoomSchemaShape = {},\n> implements IContainEntitiesAndLinks<Entities, Links>\n{\n  constructor(\n    public entities: Entities,\n    public links: Links,\n  ) {}\n\n  withRoomSchema<_RoomSchema extends RoomSchemaShape>() {\n    return new InstantGraph<Entities, Links, _RoomSchema>(\n      this.entities,\n      this.links,\n    );\n  }\n}\n\ntype EntityDefFromRoomSlice<Shape extends { [k: string]: any }> = EntityDef<\n  {\n    [AttrName in keyof Shape]: DataAttrDef<\n      Shape[AttrName],\n      Shape[AttrName] extends undefined ? false : true\n    >;\n  },\n  any,\n  void\n>;\n\ntype RoomDefFromShape<RoomSchema extends RoomSchemaShape> = {\n  [RoomName in keyof RoomSchema]: {\n    presence: EntityDefFromRoomSlice<RoomSchema[RoomName][\"presence\"]>;\n    topics: {\n      [TopicName in keyof RoomSchema[RoomName][\"topics\"]]: EntityDefFromRoomSlice<\n        RoomSchema[RoomName][\"topics\"][TopicName]\n      >;\n    };\n  };\n};\n\ntype EntityDefFromShape<Shape, K extends keyof Shape> = EntityDef<\n  {\n    [AttrName in keyof Shape[K]]: DataAttrDef<\n      Shape[K][AttrName],\n      Shape[K][AttrName] extends undefined ? false : true\n    >;\n  },\n  {\n    [LinkName in keyof Shape]: LinkAttrDef<\n      \"many\",\n      LinkName extends string ? LinkName : string\n    >;\n  },\n  void\n>;\n\n/**\n * If you were using the old `schema` types, you can use this to help you\n * migrate.\n *\n * @example\n * // Before\n * const db = init<Schema, Rooms>({...})\n *\n * // After\n * const db = init<BackwardsCompatibleSchema<Schema, Rooms>>({...})\n */\nexport type BackwardsCompatibleSchema<\n  Shape extends { [k: string]: any },\n  RoomSchema extends RoomSchemaShape = {},\n> = InstantSchemaDef<\n  { [K in keyof Shape]: EntityDefFromShape<Shape, K> },\n  UnknownLinks<EntitiesDef>,\n  RoomDefFromShape<RoomSchema>\n>;\n\n// ----------\n// InstantUnknownSchema\n\nexport type UnknownEntity = EntityDef<\n  {\n    id: DataAttrDef<string, true>;\n    [AttrName: string]: DataAttrDef<any, any>;\n  },\n  { [LinkName: string]: LinkAttrDef<\"many\", string> },\n  void\n>;\n\nexport type UnknownEntities = {\n  [EntityName: string]: UnknownEntity;\n};\n\nexport interface UnknownLinks<Entities extends EntitiesDef> {\n  [LinkName: string]: LinkDef<\n    Entities,\n    string,\n    string,\n    \"many\",\n    string,\n    string,\n    \"many\"\n  >;\n}\n\nexport interface UnknownRooms {\n  [RoomName: string]: {\n    presence: EntityDef<any, any, any>;\n    topics: {\n      [TopicName: string]: EntityDef<any, any, any>;\n    };\n  };\n}\n\nexport type InstantUnknownSchema = InstantSchemaDef<\n  UnknownEntities,\n  UnknownLinks<UnknownEntities>,\n  UnknownRooms\n>;\n\nexport type UpdateParams<\n  Schema extends IContainEntitiesAndLinks<any, any>,\n  EntityName extends keyof Schema[\"entities\"],\n> = {\n  [AttrName in keyof Schema[\"entities\"][EntityName][\"attrs\"]]?: Schema[\"entities\"][EntityName][\"attrs\"][AttrName] extends DataAttrDef<\n    infer ValueType,\n    infer IsRequired\n  >\n    ? IsRequired extends true\n      ? ValueType\n      : ValueType | null\n    : never;\n};\n\nexport type LinkParams<\n  Schema extends IContainEntitiesAndLinks<any, any>,\n  EntityName extends keyof Schema[\"entities\"],\n> = {\n  [LinkName in keyof Schema[\"entities\"][EntityName][\"links\"]]?: Schema[\"entities\"][EntityName][\"links\"][LinkName] extends LinkAttrDef<\n    infer Cardinality,\n    any\n  >\n    ? Cardinality extends \"one\"\n      ? string\n      : string | string[]\n    : never;\n};\n"]}