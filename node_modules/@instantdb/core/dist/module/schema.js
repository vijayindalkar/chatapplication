import { EntityDef, DataAttrDef, InstantSchemaDef, } from "./schemaTypes";
// ==========
// API
/**
 * @deprecated
 * `i.graph` is deprecated. Use `i.schema` instead.
 *
 * @example
 * // Before
 * i.graph(entities, links).withRoomSchema<RoomType>();
 *
 * // After
 * i.schema({ entities, links, rooms })
 *
 * @see
 * https://instantdb.com/docs/schema
 */
function graph(entities, links) {
    return new InstantSchemaDef(enrichEntitiesWithLinks(entities, links), 
    // (XXX): LinksDef<any> stems from TypeScript’s inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    links, undefined);
}
/**
 * Creates an entity definition, to be used in conjunction with `i.graph`.
 *
 * @see https://instantdb.com/docs/schema
 * @example
 *   {
 *     posts: i.entity({
 *       title: i.string(),
 *       body: i.string(),
 *     }),
 *     comments: i.entity({
 *       body: i.string(),
 *     })
 *   }
 */
function entity(attrs) {
    return new EntityDef(attrs, {});
}
function string() {
    return new DataAttrDef("string", true);
}
function number() {
    return new DataAttrDef("number", true);
}
function boolean() {
    return new DataAttrDef("boolean", true);
}
function date() {
    return new DataAttrDef("date", true);
}
function json() {
    return new DataAttrDef("json", true);
}
function any() {
    return new DataAttrDef("json", true);
}
// ==========
// internal
function enrichEntitiesWithLinks(entities, links) {
    var _a, _b, _c, _d;
    const linksIndex = { fwd: {}, rev: {} };
    for (const linkDef of Object.values(links)) {
        (_a = linksIndex.fwd)[_b = linkDef.forward.on] || (_a[_b] = {});
        (_c = linksIndex.rev)[_d = linkDef.reverse.on] || (_c[_d] = {});
        linksIndex.fwd[linkDef.forward.on][linkDef.forward.label] = {
            entityName: linkDef.reverse.on,
            cardinality: linkDef.forward.has,
        };
        linksIndex.rev[linkDef.reverse.on][linkDef.reverse.label] = {
            entityName: linkDef.forward.on,
            cardinality: linkDef.reverse.has,
        };
    }
    const enrichedEntities = Object.fromEntries(Object.entries(entities).map(([name, def]) => [
        name,
        new EntityDef(def.attrs, Object.assign(Object.assign({}, linksIndex.fwd[name]), linksIndex.rev[name])),
    ]));
    return enrichedEntities;
}
/**
 * Lets you define a schema for your database.
 *
 * You can define entities, links between entities, and if you use
 * presence, you can define rooms.
 *
 * You can push this schema to your database with the CLI,
 * or use it inside `init`, to get typesafety and autocompletion.
 *
 * @see https://instantdb.com/docs/schema
 * @example
 *   i.schema({
 *     entities: { },
 *     links: { },
 *     rooms: { }
 *   });
 */
function schema({ entities, links, rooms, }) {
    const linksDef = links !== null && links !== void 0 ? links : {};
    const roomsDef = rooms !== null && rooms !== void 0 ? rooms : {};
    return new InstantSchemaDef(enrichEntitiesWithLinks(entities, linksDef), 
    // (XXX): LinksDef<any> stems from TypeScript’s inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    linksDef, roomsDef);
}
export const i = {
    // constructs
    graph,
    schema,
    entity,
    // value types
    string,
    number,
    boolean,
    date,
    json,
    any,
};
//# sourceMappingURL=schema.js.map