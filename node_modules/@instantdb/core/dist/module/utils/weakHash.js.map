{"version":3,"file":"weakHash.js","sourceRoot":"","sources":["../../../src/utils/weakHash.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;GAWG;AACH,MAAM,CAAC,OAAO,UAAU,QAAQ,CAAC,KAAU;IACzC,kEAAkE;IAClE,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,+CAA+C;QAC/C,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IAC3D,CAAC;IACD,IAAI,OAAO,KAAK,KAAK,SAAS;QAAE,OAAO,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;IACzD,IAAI,KAAK,KAAK,IAAI;QAAE,OAAO,MAAM,CAAC;IAClC,IAAI,KAAK,KAAK,SAAS;QAAE,OAAO,WAAW,CAAC;IAE5C,oCAAoC;IACpC,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,IAAI,IAAI,GAAG,UAAU,CAAC,CAAC,4BAA4B;QACnD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACtC,IAAI,IAAI,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC;YAC7E,IAAI,GAAG,IAAI,KAAK,CAAC,CAAC,CAAC,kDAAkD;QACvE,CAAC;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IAC3B,CAAC;IAED,qCAAqC;IACrC,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;QACzB,IAAI,IAAI,GAAG,UAAU,CAAC;QACtB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACtC,yCAAyC;YACzC,IAAI,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU,CAAC;YAC7B,kCAAkC;YAClC,MAAM,WAAW,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACvC,6CAA6C;YAC7C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBAC5C,IAAI,IAAI,WAAW,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBAClC,IAAI,IAAI,QAAQ,CAAC,CAAC,qBAAqB;gBACvC,IAAI,GAAG,IAAI,KAAK,CAAC,CAAC;YACpB,CAAC;QACH,CAAC;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IAC3B,CAAC;IAED,oCAAoC;IACpC,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;QAC9B,IAAI,IAAI,GAAG,UAAU,CAAC;QACtB,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,uBAAuB;QAE/D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACrC,MAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YACpB,iCAAiC;YACjC,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;YAC9B,IAAI,IAAI,QAAQ,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC;YAC9B,IAAI,IAAI,QAAQ,CAAC;YACjB,IAAI,GAAG,IAAI,KAAK,CAAC,CAAC;YAElB,6BAA6B;YAC7B,MAAM,SAAS,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;YACvC,IAAI,IAAI,QAAQ,CAAC,SAAS,EAAE,EAAE,CAAC,CAAC;YAChC,IAAI,IAAI,QAAQ,CAAC;YACjB,IAAI,GAAG,IAAI,KAAK,CAAC,CAAC;QACpB,CAAC;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IAC3B,CAAC;IAED,2BAA2B;IAC3B,OAAO,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;AACjC,CAAC","sourcesContent":["/**\n *\n * Unique Hashing implementation inspired by djb2/fnv1a algorithms,\n * where we are not concerned with the hash being decoded.\n * Focuses on speed while maintaining good hash distribution\n *\n * Note: We could also use something like Murmurhash instead\n * https://github.com/jensyt/imurmurhash-js/blob/master/imurmurhash.js\n *\n * @param {any} input - Value to hash\n * @returns {string} - Hash in hex format\n */\nexport default function weakHash(input: any): string {\n  // Handle primitives without JSON stringify for better performance\n  if (typeof input === 'number') {\n    // Use a larger number space for numeric values\n    return (Math.abs(input * 2654435761) >>> 0).toString(16);\n  }\n  if (typeof input === 'boolean') return input ? '1' : '0';\n  if (input === null) return 'null';\n  if (input === undefined) return 'undefined';\n\n  // For strings, use FNV-1a algorithm\n  if (typeof input === 'string') {\n    let hash = 0x811C9DC5; // FNV offset basis (32 bit)\n    for (let i = 0; i < input.length; i++) {\n      hash ^= input.charCodeAt(i);\n      hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n      hash = hash >>> 0; // Convert to unsigned 32-bit after each iteration\n    }\n    return hash.toString(16);\n  }\n\n  // For arrays, hash elements directly\n  if (Array.isArray(input)) {\n    let hash = 0x811C9DC5;\n    for (let i = 0; i < input.length; i++) {\n      // Add array position to hash calculation\n      hash ^= (i + 1) * 2654435761;\n      // Recursively hash array elements\n      const elementHash = weakHash(input[i]);\n      // Mix the element hash into the running hash\n      for (let j = 0; j < elementHash.length; j++) {\n        hash ^= elementHash.charCodeAt(j);\n        hash *= 16777619; // FNV prime (32 bit)\n        hash = hash >>> 0;\n      }\n    }\n    return hash.toString(16);\n  }\n\n  // For objects, hash keys and values\n  if (typeof input === 'object') {\n    let hash = 0x811C9DC5;\n    const keys = Object.keys(input).sort(); // Sort for consistency\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      // Hash the key using string hash\n      const keyHash = weakHash(key);\n      hash ^= parseInt(keyHash, 16);\n      hash *= 16777619;\n      hash = hash >>> 0;\n\n      // Hash the value recursively\n      const valueHash = weakHash(input[key]);\n      hash ^= parseInt(valueHash, 16);\n      hash *= 16777619;\n      hash = hash >>> 0;\n    }\n    return hash.toString(16);\n  }\n\n  // Fallback for other types\n  return weakHash(String(input));\n}\n"]}