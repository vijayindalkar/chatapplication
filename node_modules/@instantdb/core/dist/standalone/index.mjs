var fn = Object.defineProperty;
var ln = (t, e, n) => e in t ? fn(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var p = (t, e, n) => ln(t, typeof e != "symbol" ? e + "" : e, n);
let he = !1;
typeof window < "u" && typeof window.localStorage < "u" && (he = !!window.localStorage.getItem("devBackend") || !!window.localStorage.getItem("__instantLogging"));
const E = {
  info: he ? console.info.bind(console) : () => {
  },
  debug: he ? console.debug.bind(console) : () => {
  },
  error: he ? console.error.bind(console) : () => {
  }
};
function x(t) {
  if (typeof t == "number")
    return (Math.abs(t * 2654435761) >>> 0).toString(16);
  if (typeof t == "boolean") return t ? "1" : "0";
  if (t === null) return "null";
  if (t === void 0) return "undefined";
  if (typeof t == "string") {
    let e = 2166136261;
    for (let n = 0; n < t.length; n++)
      e ^= t.charCodeAt(n), e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24), e = e >>> 0;
    return e.toString(16);
  }
  if (Array.isArray(t)) {
    let e = 2166136261;
    for (let n = 0; n < t.length; n++) {
      e ^= (n + 1) * 2654435761;
      const r = x(t[n]);
      for (let s = 0; s < r.length; s++)
        e ^= r.charCodeAt(s), e *= 16777619, e = e >>> 0;
    }
    return e.toString(16);
  }
  if (typeof t == "object") {
    let e = 2166136261;
    const n = Object.keys(t).sort();
    for (let r = 0; r < n.length; r++) {
      const s = n[r], i = x(s);
      e ^= parseInt(i, 16), e *= 16777619, e = e >>> 0;
      const o = x(t[s]);
      e ^= parseInt(o, 16), e *= 16777619, e = e >>> 0;
    }
    return e.toString(16);
  }
  return x(String(t));
}
const M = {
  Remove: "remove",
  Replace: "replace",
  Add: "add"
}, Tt = Symbol.for("__MUTATIVE_PROXY_DRAFT__"), dn = Symbol("__MUTATIVE_RAW_RETURN_SYMBOL__"), pe = Symbol.iterator, I = {
  mutable: "mutable",
  immutable: "immutable"
}, He = {};
function T(t) {
  var e;
  return (e = t.copy) !== null && e !== void 0 ? e : t.original;
}
function ee(t) {
  return !!m(t);
}
function m(t) {
  return typeof t != "object" ? null : t == null ? void 0 : t[Tt];
}
function Ge(t) {
  var e;
  const n = m(t);
  return n ? (e = n.copy) !== null && e !== void 0 ? e : n.original : t;
}
function N(t, e) {
  if (!t || typeof t != "object")
    return !1;
  let n;
  return Object.getPrototypeOf(t) === Object.prototype || Array.isArray(t) || t instanceof Map || t instanceof Set || !!(e != null && e.mark) && ((n = e.mark(t, I)) === I.immutable || typeof n == "function");
}
function It(t, e = []) {
  if (Object.hasOwnProperty.call(t, "key")) {
    const n = m(J(t.parent.copy, t.key));
    if (n !== null && (n == null ? void 0 : n.original) !== t.original)
      return null;
    e.push(t.parent.type === 3 ? Array.from(t.parent.setMap.keys()).indexOf(t.key) : t.key);
  }
  if (t.parent)
    return It(t.parent, e);
  e.reverse();
  try {
    hn(t.copy, e);
  } catch {
    return null;
  }
  return e;
}
function te(t) {
  return Array.isArray(t) ? 1 : t instanceof Map ? 2 : t instanceof Set ? 3 : 0;
}
function J(t, e) {
  return te(t) === 2 ? t.get(e) : t[e];
}
function ue(t, e, n) {
  te(t) === 2 ? t.set(e, n) : t[e] = n;
}
function Pe(t, e) {
  const n = m(t);
  return (n ? T(n) : t)[e];
}
function Q(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function Te(t) {
  if (t)
    for (; t.finalities.revoke.length > 0; )
      t.finalities.revoke.pop()();
}
function X(t, e) {
  return e ? t : [""].concat(t).map((n) => {
    const r = `${n}`;
    return r.indexOf("/") === -1 && r.indexOf("~") === -1 ? r : r.replace(/~/g, "~0").replace(/\//g, "~1");
  }).join("/");
}
function hn(t, e) {
  for (let n = 0; n < e.length - 1; n += 1) {
    const r = e[n];
    if (t = J(te(t) === 3 ? Array.from(t) : t, r), typeof t != "object")
      throw new Error(`Cannot resolve patch at '${e.join("/")}'.`);
  }
  return t;
}
function pn(t) {
  const e = Object.create(Object.getPrototypeOf(t));
  return Reflect.ownKeys(t).forEach((n) => {
    let r = Reflect.getOwnPropertyDescriptor(t, n);
    if (r.enumerable && r.configurable && r.writable) {
      e[n] = t[n];
      return;
    }
    r.writable || (r.writable = !0, r.configurable = !0), (r.get || r.set) && (r = {
      configurable: !0,
      writable: !0,
      enumerable: r.enumerable,
      value: t[n]
    }), Reflect.defineProperty(e, n, r);
  }), e;
}
const yn = Object.prototype.propertyIsEnumerable;
function xt(t, e) {
  let n;
  if (Array.isArray(t))
    return Array.prototype.concat.call(t);
  if (t instanceof Set)
    return new Set(t.values());
  if (t instanceof Map)
    return new Map(t);
  if (e != null && e.mark && (n = e.mark(t, I), n !== void 0) && n !== I.mutable) {
    if (n === I.immutable)
      return pn(t);
    if (typeof n == "function") {
      if (e.enablePatches || e.enableAutoFreeze)
        throw new Error("You can't use mark and patches or auto freeze together.");
      return n();
    }
    throw new Error(`Unsupported mark result: ${n}`);
  } else if (typeof t == "object" && Object.getPrototypeOf(t) === Object.prototype) {
    const r = {};
    return Object.keys(t).forEach((s) => {
      r[s] = t[s];
    }), Object.getOwnPropertySymbols(t).forEach((s) => {
      yn.call(t, s) && (r[s] = t[s]);
    }), r;
  } else
    throw new Error("Please check mark() to ensure that it is a stable marker draftable function.");
}
function P(t) {
  t.copy || (t.copy = xt(t.original, t.options));
}
function oe(t) {
  if (!N(t))
    return Ge(t);
  if (Array.isArray(t))
    return t.map(oe);
  if (t instanceof Map)
    return new Map(Array.from(t.entries()).map(([n, r]) => [n, oe(r)]));
  if (t instanceof Set)
    return new Set(Array.from(t).map(oe));
  const e = Object.create(Object.getPrototypeOf(t));
  for (const n in t)
    e[n] = oe(t[n]);
  return e;
}
function ye(t) {
  return ee(t) ? oe(t) : t;
}
function z(t) {
  var e;
  t.assignedMap = (e = t.assignedMap) !== null && e !== void 0 ? e : /* @__PURE__ */ new Map(), t.operated || (t.operated = !0, t.parent && z(t.parent));
}
function lt() {
  throw new Error("Cannot modify frozen object");
}
function re(t, e, n, r, s) {
  {
    n = n ?? /* @__PURE__ */ new WeakMap(), r = r ?? [], s = s ?? [];
    const o = n.has(t) ? n.get(t) : t;
    if (r.length > 0) {
      const a = r.indexOf(o);
      if (o && typeof o == "object" && a !== -1)
        throw r[0] === o ? new Error("Forbids circular reference") : new Error(`Forbids circular reference: ~/${s.slice(0, a).map((c, u) => {
          if (typeof c == "symbol")
            return `[${c.toString()}]`;
          const f = r[u];
          return typeof c == "object" && (f instanceof Map || f instanceof Set) ? Array.from(f.keys()).indexOf(c) : c;
        }).join("/")}`);
      r.push(o), s.push(e);
    } else
      r.push(o);
  }
  if (Object.isFrozen(t) || ee(t)) {
    r.pop(), s.pop();
    return;
  }
  switch (te(t)) {
    case 2:
      for (const [a, c] of t)
        re(a, a, n, r, s), re(c, a, n, r, s);
      t.set = t.clear = t.delete = lt;
      break;
    case 3:
      for (const a of t)
        re(a, a, n, r, s);
      t.add = t.clear = t.delete = lt;
      break;
    case 1:
      Object.freeze(t);
      let o = 0;
      for (const a of t)
        re(a, o, n, r, s), o += 1;
      break;
    default:
      Object.freeze(t), Object.keys(t).forEach((a) => {
        const c = t[a];
        re(c, a, n, r, s);
      });
  }
  r.pop(), s.pop();
}
function be(t, e) {
  return t instanceof Map ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function dt(t, e) {
  if (e in t) {
    let n = Reflect.getPrototypeOf(t);
    for (; n; ) {
      const r = Reflect.getOwnPropertyDescriptor(n, e);
      if (r)
        return r;
      n = Reflect.getPrototypeOf(n);
    }
  }
}
function Ye(t, e) {
  const n = te(t);
  if (n === 0)
    Reflect.ownKeys(t).forEach((r) => {
      e(r, t[r], t);
    });
  else if (n === 1) {
    let r = 0;
    for (const s of t)
      e(r, s, t), r += 1;
  } else
    t.forEach((r, s) => e(s, r, t));
}
function Ut(t, e, n) {
  if (ee(t) || !N(t, n) || e.has(t) || Object.isFrozen(t))
    return;
  const r = t instanceof Set, s = r ? /* @__PURE__ */ new Map() : void 0;
  if (e.add(t), Ye(t, (i, o) => {
    var a;
    if (ee(o)) {
      const c = m(o);
      P(c);
      const u = !((a = c.assignedMap) === null || a === void 0) && a.size || c.operated ? c.copy : c.original;
      ue(r ? s : t, i, u);
    } else
      Ut(o, e, n);
  }), s) {
    const i = t, o = Array.from(i);
    i.clear(), o.forEach((a) => {
      i.add(s.has(a) ? s.get(a) : a);
    });
  }
}
function bn(t, e) {
  const n = t.type === 3 ? t.setMap : t.copy;
  t.finalities.revoke.length > 1 && t.assignedMap.get(e) && n && Ut(J(n, e), t.finalities.handledSet, t.options);
}
function Ie(t) {
  t.type === 3 && t.copy && (t.copy.clear(), t.setMap.forEach((e) => {
    t.copy.add(Ge(e));
  }));
}
function xe(t, e, n, r) {
  if (t.operated && t.assignedMap && t.assignedMap.size > 0 && !t.finalized) {
    if (n && r) {
      const i = It(t);
      i && e(t, i, n, r);
    }
    t.finalized = !0;
  }
}
function Xe(t, e, n, r) {
  const s = m(n);
  s && (s.callbacks || (s.callbacks = []), s.callbacks.push((i, o) => {
    var a;
    const c = t.type === 3 ? t.setMap : t.copy;
    if (Q(J(c, e), n)) {
      let u = s.original;
      s.copy && (u = s.copy), Ie(t), xe(t, r, i, o), t.options.enableAutoFreeze && (t.options.updatedValues = (a = t.options.updatedValues) !== null && a !== void 0 ? a : /* @__PURE__ */ new WeakMap(), t.options.updatedValues.set(u, s.original)), ue(c, e, u);
    }
  }), t.options.enableAutoFreeze && s.finalities !== t.finalities && (t.options.enableAutoFreeze = !1)), N(n, t.options) && t.finalities.draft.push(() => {
    const i = t.type === 3 ? t.setMap : t.copy;
    Q(J(i, e), n) && bn(t, e);
  });
}
function _n(t, e, n, r, s) {
  let { original: i, assignedMap: o, options: a } = t, c = t.copy;
  c.length < i.length && ([i, c] = [c, i], [n, r] = [r, n]);
  for (let u = 0; u < i.length; u += 1)
    if (o.get(u.toString()) && c[u] !== i[u]) {
      const f = e.concat([u]), l = X(f, s);
      n.push({
        op: M.Replace,
        path: l,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: ye(c[u])
      }), r.push({
        op: M.Replace,
        path: l,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: ye(i[u])
      });
    }
  for (let u = i.length; u < c.length; u += 1) {
    const f = e.concat([u]), l = X(f, s);
    n.push({
      op: M.Add,
      path: l,
      // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
      value: ye(c[u])
    });
  }
  if (i.length < c.length) {
    const { arrayLengthAssignment: u = !0 } = a.enablePatches;
    if (u) {
      const f = e.concat(["length"]), l = X(f, s);
      r.push({
        op: M.Replace,
        path: l,
        value: i.length
      });
    } else
      for (let f = c.length; i.length < f; f -= 1) {
        const l = e.concat([f - 1]), d = X(l, s);
        r.push({
          op: M.Remove,
          path: d
        });
      }
  }
}
function wn({ original: t, copy: e, assignedMap: n }, r, s, i, o) {
  n.forEach((a, c) => {
    const u = J(t, c), f = ye(J(e, c)), l = a ? be(t, c) ? M.Replace : M.Add : M.Remove;
    if (Q(u, f) && l === M.Replace)
      return;
    const d = r.concat(c), h = X(d, o);
    s.push(l === M.Remove ? { op: l, path: h } : { op: l, path: h, value: f }), i.push(l === M.Add ? { op: M.Remove, path: h } : l === M.Remove ? { op: M.Add, path: h, value: u } : { op: M.Replace, path: h, value: u });
  });
}
function gn({ original: t, copy: e }, n, r, s, i) {
  let o = 0;
  t.forEach((a) => {
    if (!e.has(a)) {
      const c = n.concat([o]), u = X(c, i);
      r.push({
        op: M.Remove,
        path: u,
        value: a
      }), s.unshift({
        op: M.Add,
        path: u,
        value: a
      });
    }
    o += 1;
  }), o = 0, e.forEach((a) => {
    if (!t.has(a)) {
      const c = n.concat([o]), u = X(c, i);
      r.push({
        op: M.Add,
        path: u,
        value: a
      }), s.unshift({
        op: M.Remove,
        path: u,
        value: a
      });
    }
    o += 1;
  });
}
function ce(t, e, n, r) {
  const { pathAsArray: s = !0 } = t.options.enablePatches;
  switch (t.type) {
    case 0:
    case 2:
      return wn(t, e, n, r, s);
    case 1:
      return _n(t, e, n, r, s);
    case 3:
      return gn(t, e, n, r, s);
  }
}
let mn = !1;
const we = (t, e, n = !1) => {
  if (typeof t == "object" && t !== null && (!N(t, e) || n) && !mn)
    throw new Error("Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.");
}, Ue = {
  get size() {
    return T(m(this)).size;
  },
  has(t) {
    return T(m(this)).has(t);
  },
  set(t, e) {
    const n = m(this), r = T(n);
    return (!r.has(t) || !Q(r.get(t), e)) && (P(n), z(n), n.assignedMap.set(t, !0), n.copy.set(t, e), Xe(n, t, e, ce)), this;
  },
  delete(t) {
    if (!this.has(t))
      return !1;
    const e = m(this);
    return P(e), z(e), e.original.has(t) ? e.assignedMap.set(t, !1) : e.assignedMap.delete(t), e.copy.delete(t), !0;
  },
  clear() {
    const t = m(this);
    if (this.size) {
      P(t), z(t), t.assignedMap = /* @__PURE__ */ new Map();
      for (const [e] of t.original)
        t.assignedMap.set(e, !1);
      t.copy.clear();
    }
  },
  forEach(t, e) {
    const n = m(this);
    T(n).forEach((r, s) => {
      t.call(e, this.get(s), s, this);
    });
  },
  get(t) {
    var e, n;
    const r = m(this), s = T(r).get(t), i = ((n = (e = r.options).mark) === null || n === void 0 ? void 0 : n.call(e, s, I)) === I.mutable;
    if (r.options.strict && we(s, r.options, i), i || r.finalized || !N(s, r.options) || s !== r.original.get(t))
      return s;
    const o = He.createDraft({
      original: s,
      parentDraft: r,
      key: t,
      finalities: r.finalities,
      options: r.options
    });
    return P(r), r.copy.set(t, o), o;
  },
  keys() {
    return T(m(this)).keys();
  },
  values() {
    const t = this.keys();
    return {
      [pe]: () => this.values(),
      next: () => {
        const e = t.next();
        return e.done ? e : {
          done: !1,
          value: this.get(e.value)
        };
      }
    };
  },
  entries() {
    const t = this.keys();
    return {
      [pe]: () => this.entries(),
      next: () => {
        const e = t.next();
        if (e.done)
          return e;
        const n = this.get(e.value);
        return {
          done: !1,
          value: [e.value, n]
        };
      }
    };
  },
  [pe]() {
    return this.entries();
  }
}, Sn = Reflect.ownKeys(Ue), ht = (t, e, { isValuesIterator: n }) => () => {
  var r, s;
  const i = e.next();
  if (i.done)
    return i;
  const o = i.value;
  let a = t.setMap.get(o);
  const c = m(a), u = ((s = (r = t.options).mark) === null || s === void 0 ? void 0 : s.call(r, a, I)) === I.mutable;
  if (t.options.strict && we(o, t.options, u), !u && !c && N(o, t.options) && !t.finalized && t.original.has(o)) {
    const f = He.createDraft({
      original: o,
      parentDraft: t,
      key: o,
      finalities: t.finalities,
      options: t.options
    });
    t.setMap.set(o, f), a = f;
  } else c && (a = c.proxy);
  return {
    done: !1,
    value: n ? a : [a, a]
  };
}, $e = {
  get size() {
    return m(this).setMap.size;
  },
  has(t) {
    const e = m(this);
    if (e.setMap.has(t))
      return !0;
    P(e);
    const n = m(t);
    return !!(n && e.setMap.has(n.original));
  },
  add(t) {
    const e = m(this);
    return this.has(t) || (P(e), z(e), e.assignedMap.set(t, !0), e.setMap.set(t, t), Xe(e, t, t, ce)), this;
  },
  delete(t) {
    if (!this.has(t))
      return !1;
    const e = m(this);
    P(e), z(e);
    const n = m(t);
    return n && e.setMap.has(n.original) ? (e.assignedMap.set(n.original, !1), e.setMap.delete(n.original)) : (!n && e.setMap.has(t) ? e.assignedMap.set(t, !1) : e.assignedMap.delete(t), e.setMap.delete(t));
  },
  clear() {
    if (!this.size)
      return;
    const t = m(this);
    P(t), z(t);
    for (const e of t.original)
      t.assignedMap.set(e, !1);
    t.setMap.clear();
  },
  values() {
    const t = m(this);
    P(t);
    const e = t.setMap.keys();
    return {
      [Symbol.iterator]: () => this.values(),
      next: ht(t, e, { isValuesIterator: !0 })
    };
  },
  entries() {
    const t = m(this);
    P(t);
    const e = t.setMap.keys();
    return {
      [Symbol.iterator]: () => this.entries(),
      next: ht(t, e, {
        isValuesIterator: !1
      })
    };
  },
  keys() {
    return this.values();
  },
  [pe]() {
    return this.values();
  },
  forEach(t, e) {
    const n = this.values();
    let r = n.next();
    for (; !r.done; )
      t.call(e, r.value, r.value, this), r = n.next();
  }
}, On = Reflect.ownKeys($e), $t = /* @__PURE__ */ new WeakSet(), Dt = {
  get(t, e, n) {
    var r, s;
    const i = (r = t.copy) === null || r === void 0 ? void 0 : r[e];
    if (i && $t.has(i))
      return i;
    if (e === Tt)
      return t;
    let o;
    if (t.options.mark) {
      const u = e === "size" && (t.original instanceof Map || t.original instanceof Set) ? Reflect.get(t.original, e) : Reflect.get(t.original, e, n);
      if (o = t.options.mark(u, I), o === I.mutable)
        return t.options.strict && we(u, t.options, !0), u;
    }
    const a = T(t);
    if (a instanceof Map && Sn.includes(e)) {
      if (e === "size")
        return Object.getOwnPropertyDescriptor(Ue, "size").get.call(t.proxy);
      const u = Ue[e];
      if (u)
        return u.bind(t.proxy);
    }
    if (a instanceof Set && On.includes(e)) {
      if (e === "size")
        return Object.getOwnPropertyDescriptor($e, "size").get.call(t.proxy);
      const u = $e[e];
      if (u)
        return u.bind(t.proxy);
    }
    if (!be(a, e)) {
      const u = dt(a, e);
      return u ? "value" in u ? u.value : (
        // !case: support for getter
        (s = u.get) === null || s === void 0 ? void 0 : s.call(t.proxy)
      ) : void 0;
    }
    const c = a[e];
    if (t.options.strict && we(c, t.options), t.finalized || !N(c, t.options))
      return c;
    if (c === Pe(t.original, e)) {
      if (P(t), t.copy[e] = Ze({
        original: t.original[e],
        parentDraft: t,
        key: t.type === 1 ? Number(e) : e,
        finalities: t.finalities,
        options: t.options
      }), typeof o == "function") {
        const u = m(t.copy[e]);
        return P(u), z(u), u.copy;
      }
      return t.copy[e];
    }
    return c;
  },
  set(t, e, n) {
    var r;
    if (t.type === 3 || t.type === 2)
      throw new Error("Map/Set draft does not support any property assignment.");
    let s;
    if (t.type === 1 && e !== "length" && !(Number.isInteger(s = Number(e)) && s >= 0 && (e === 0 || s === 0 || String(s) === String(e))))
      throw new Error("Only supports setting array indices and the 'length' property.");
    const i = dt(T(t), e);
    if (i != null && i.set)
      return i.set.call(t.proxy, n), !0;
    const o = Pe(T(t), e), a = m(o);
    return a && Q(a.original, n) ? (t.copy[e] = n, t.assignedMap = (r = t.assignedMap) !== null && r !== void 0 ? r : /* @__PURE__ */ new Map(), t.assignedMap.set(e, !1), !0) : (Q(n, o) && (n !== void 0 || be(t.original, e)) || (P(t), z(t), be(t.original, e) && Q(n, t.original[e]) ? t.assignedMap.delete(e) : t.assignedMap.set(e, !0), t.copy[e] = n, Xe(t, e, n, ce)), !0);
  },
  has(t, e) {
    return e in T(t);
  },
  ownKeys(t) {
    return Reflect.ownKeys(T(t));
  },
  getOwnPropertyDescriptor(t, e) {
    const n = T(t), r = Reflect.getOwnPropertyDescriptor(n, e);
    return r && {
      writable: !0,
      configurable: t.type !== 1 || e !== "length",
      enumerable: r.enumerable,
      value: n[e]
    };
  },
  getPrototypeOf(t) {
    return Reflect.getPrototypeOf(t.original);
  },
  setPrototypeOf() {
    throw new Error("Cannot call 'setPrototypeOf()' on drafts");
  },
  defineProperty() {
    throw new Error("Cannot call 'defineProperty()' on drafts");
  },
  deleteProperty(t, e) {
    var n;
    return t.type === 1 ? Dt.set.call(this, t, e, void 0, t.proxy) : (Pe(t.original, e) !== void 0 || e in t.original ? (P(t), z(t), t.assignedMap.set(e, !1)) : (t.assignedMap = (n = t.assignedMap) !== null && n !== void 0 ? n : /* @__PURE__ */ new Map(), t.assignedMap.delete(e)), t.copy && delete t.copy[e], !0);
  }
};
function Ze(t) {
  const { original: e, parentDraft: n, key: r, finalities: s, options: i } = t, o = te(e), a = {
    type: o,
    finalized: !1,
    parent: n,
    original: e,
    copy: null,
    proxy: null,
    finalities: s,
    options: i,
    // Mapping of draft Set items to their corresponding draft values.
    setMap: o === 3 ? new Map(e.entries()) : void 0
  };
  (r || "key" in t) && (a.key = r);
  const { proxy: c, revoke: u } = Proxy.revocable(o === 1 ? Object.assign([], a) : a, Dt);
  if (s.revoke.push(u), $t.add(c), a.proxy = c, n) {
    const f = n;
    f.finalities.draft.push((l, d) => {
      var h, y;
      const b = m(c);
      let w = f.type === 3 ? f.setMap : f.copy;
      const _ = J(w, r), S = m(_);
      if (S) {
        let O = S.original;
        S.operated && (O = Ge(_)), Ie(S), xe(S, ce, l, d), f.options.enableAutoFreeze && (f.options.updatedValues = (h = f.options.updatedValues) !== null && h !== void 0 ? h : /* @__PURE__ */ new WeakMap(), f.options.updatedValues.set(O, S.original)), ue(w, r, O);
      }
      (y = b.callbacks) === null || y === void 0 || y.forEach((O) => {
        O(l, d);
      });
    });
  } else {
    const f = m(c);
    f.finalities.draft.push((l, d) => {
      Ie(f), xe(f, ce, l, d);
    });
  }
  return c;
}
He.createDraft = Ze;
function vn(t, e, n, r, s) {
  var i;
  const o = m(t), a = (i = o == null ? void 0 : o.original) !== null && i !== void 0 ? i : t, c = !!e.length;
  if (o != null && o.operated)
    for (; o.finalities.draft.length > 0; )
      o.finalities.draft.pop()(n, r);
  const u = c ? e[0] : o ? o.operated ? o.copy : o.original : t;
  return o && Te(o), s && re(u, u, o == null ? void 0 : o.options.updatedValues), [
    u,
    n && c ? [{ op: M.Replace, path: [], value: e[0] }] : n,
    r && c ? [{ op: M.Replace, path: [], value: a }] : r
  ];
}
function Mn(t, e) {
  var n;
  const r = {
    draft: [],
    revoke: [],
    handledSet: /* @__PURE__ */ new WeakSet()
  };
  let s, i;
  e.enablePatches && (s = [], i = []);
  const a = ((n = e.mark) === null || n === void 0 ? void 0 : n.call(e, t, I)) === I.mutable || !N(t, e) ? t : Ze({
    original: t,
    parentDraft: null,
    finalities: r,
    options: e
  });
  return [
    a,
    (c = []) => {
      const [u, f, l] = vn(a, c, s, i, e.enableAutoFreeze);
      return e.enablePatches ? [u, f, l] : u;
    }
  ];
}
function De(t) {
  const { rootDraft: e, value: n, useRawReturn: r = !1, isRoot: s = !0 } = t;
  Ye(n, (i, o, a) => {
    const c = m(o);
    if (c && e && c.finalities === e.finalities) {
      t.isContainDraft = !0;
      const u = c.original;
      if (a instanceof Set) {
        const f = Array.from(a);
        a.clear(), f.forEach((l) => a.add(i === l ? u : l));
      } else
        ue(a, i, u);
    } else typeof o == "object" && o !== null && (t.value = o, t.isRoot = !1, De(t));
  }), s && (t.isContainDraft || console.warn("The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance."), r && console.warn("The return value contains drafts, please don't use 'rawReturn()' to wrap the return value."));
}
function qt(t) {
  const e = m(t);
  if (!N(t, e == null ? void 0 : e.options))
    return t;
  const n = te(t);
  if (e && !e.operated)
    return e.original;
  let r;
  function s() {
    r = n === 2 ? new Map(t) : n === 3 ? Array.from(e.setMap.values()) : xt(t, e == null ? void 0 : e.options);
  }
  if (e) {
    e.finalized = !0;
    try {
      s();
    } finally {
      e.finalized = !1;
    }
  } else
    r = t;
  return Ye(r, (i, o) => {
    if (e && Q(J(e.original, i), o))
      return;
    const a = qt(o);
    a !== o && (r === t && s(), ue(r, i, a));
  }), n === 3 ? new Set(r) : r;
}
function pt(t) {
  if (!ee(t))
    throw new Error(`current() is only used for Draft, parameter: ${t}`);
  return qt(t);
}
const An = (t) => function e(n, r, s) {
  var i, o, a;
  if (typeof n == "function" && typeof r != "function")
    return function(g, ...R) {
      return e(g, (L) => n.call(this, L, ...R), r);
    };
  const c = n, u = r;
  let f = s;
  if (typeof r != "function" && (f = r), f !== void 0 && Object.prototype.toString.call(f) !== "[object Object]")
    throw new Error(`Invalid options: ${f}, 'options' should be an object.`);
  f = Object.assign(Object.assign({}, t), f);
  const l = ee(c) ? pt(c) : c, d = Array.isArray(f.mark) ? (g, R) => {
    for (const L of f.mark) {
      if (typeof L != "function")
        throw new Error(`Invalid mark: ${L}, 'mark' should be a function.`);
      const K = L(g, R);
      if (K)
        return K;
    }
  } : f.mark, h = (i = f.enablePatches) !== null && i !== void 0 ? i : !1, y = (o = f.strict) !== null && o !== void 0 ? o : !1, w = {
    enableAutoFreeze: (a = f.enableAutoFreeze) !== null && a !== void 0 ? a : !1,
    mark: d,
    strict: y,
    enablePatches: h
  };
  if (!N(l, w) && typeof l == "object" && l !== null)
    throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");
  const [_, S] = Mn(l, w);
  if (typeof r != "function") {
    if (!N(l, w))
      throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");
    return [_, S];
  }
  let O;
  try {
    O = u(_);
  } catch (g) {
    throw Te(m(_)), g;
  }
  const V = (g) => {
    const R = m(_);
    if (!ee(g)) {
      if (g !== void 0 && !Q(g, _) && (R != null && R.operated))
        throw new Error("Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.");
      const K = g == null ? void 0 : g[dn];
      if (K) {
        const Ce = K[0];
        return w.strict && typeof g == "object" && g !== null && De({
          rootDraft: R,
          value: g,
          useRawReturn: !0
        }), S([Ce]);
      }
      if (g !== void 0)
        return typeof g == "object" && g !== null && De({ rootDraft: R, value: g }), S([g]);
    }
    if (g === _ || g === void 0)
      return S([]);
    const L = m(g);
    if (w === L.options) {
      if (L.operated)
        throw new Error("Cannot return a modified child draft.");
      return S([pt(g)]);
    }
    return S([g]);
  };
  return O instanceof Promise ? O.then(V, (g) => {
    throw Te(m(_)), g;
  }) : V(O);
}, Cn = An();
Object.prototype.constructor.toString();
function Nt(t, e) {
  const n = Object.keys(t), r = Object.keys(e);
  return n.length === r.length && Object.keys(t).every((s) => e.hasOwnProperty(s));
}
function yt(t, e) {
  return Object.keys(t).length === Object.keys(e).length && Object.keys(t).every(
    (n) => e.hasOwnProperty(n) && t[n] === e[n]
  );
}
function _e(t, e) {
  return typeof t != "object" || typeof e != "object" || t === null || e === null ? t === e : Nt(t, e) ? Object.keys(t).every(
    (n) => _e(t[n], e[n])
  ) : !1;
}
function Lt(t, e) {
  if (!se(t) || !se(e))
    return e;
  const n = {};
  for (const r of Object.keys(t))
    e[r] !== null && (n[r] = t[r]);
  for (const r of Object.keys(e)) {
    if (e[r] === null) continue;
    const s = se(t[r]) && se(e[r]);
    n[r] = s ? Lt(t[r], e[r]) : e[r];
  }
  return n;
}
function zt(t, e, n) {
  if (!se(t))
    return t;
  const r = {};
  for (const [s, i] of Object.entries(t))
    r[s] = se(i) ? zt(i, e, n) : i === e ? n : i;
  return r;
}
function se(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
function En(t) {
  return t.cardinality === "one";
}
function et(t) {
  return t["value-type"] === "ref";
}
function Ft(t) {
  return t["value-type"] === "blob";
}
function Se(t, e) {
  return t[e];
}
function tt(t, e) {
  return e.reduce((n, r) => n && n.get(r), t);
}
function q(t, e) {
  if (e.length === 0) throw new Error("path must have at least one element");
  if (e.length === 1) {
    t.delete(e[0]);
    return;
  }
  const [n, ...r] = e;
  t.has(n) && q(t.get(n), r);
}
function k(t, e, n) {
  if (e.length === 0) throw new Error("path must have at least one element");
  if (e.length === 1) {
    t.set(e[0], n);
    return;
  }
  const [r, ...s] = e;
  let i = t.get(r);
  i || (i = /* @__PURE__ */ new Map(), t.set(r, i)), k(i, s, n);
}
function Vt(t, e) {
  const n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  for (const i of e) {
    const [o, a, c, u] = i, f = Se(t, a);
    if (!f) {
      console.warn("no such attr", o, t);
      continue;
    }
    et(f) && k(s, [c, a, o], i), k(n, [o, a, c], i), k(r, [a, o, c], i);
  }
  return { eav: n, aev: r, vae: s };
}
function Wt(t) {
  const e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  for (const i of Object.values(t)) {
    const o = i["forward-identity"], [a, c, u] = o, f = i["reverse-identity"];
    if (k(r, [c, u], i), Ft(i) && k(e, [c, u], i), i["primary?"] && k(n, [c], i), f) {
      const [l, d, h] = f;
      k(s, [d, h], i);
    }
  }
  return { blobAttrs: e, primaryKeys: n, forwardIdents: r, revIdents: s };
}
function Pn(t) {
  return {
    __type: t.__type,
    attrs: t.attrs,
    triples: U(t.eav, 3),
    cardinalityInference: t.cardinalityInference,
    linkIndex: t.linkIndex
  };
}
function Rn(t) {
  return qe(
    t.attrs,
    t.triples,
    t.cardinalityInference,
    t.linkIndex
  );
}
function nt(t) {
  t.attrIndexes = Wt(t.attrs);
}
function qe(t, e, n, r) {
  const s = Vt(t, e);
  return s.attrs = t, s.attrIndexes = Wt(t), s.cardinalityInference = n, s.linkIndex = r, s.__type = "store", s;
}
function Oe(t, e) {
  var s, i;
  let n;
  if (Array.isArray(e[0])) {
    const [o, a] = e[0], c = t.aev.get(o);
    if (!c)
      return null;
    n = (s = U(c, 2).find((f) => f[2] === a)) == null ? void 0 : s[0];
  } else
    n = e[0];
  if (!n)
    return null;
  const r = e[2];
  if (Array.isArray(r) && r.length === 2 && t.aev.get(r[0])) {
    const [o, a] = r, c = t.aev.get(o);
    if (!c)
      return null;
    const f = (i = U(c, 2).find((b) => b[2] === a)) == null ? void 0 : i[0];
    if (!f)
      return null;
    const [l, d, h, ...y] = e;
    return [n, d, f, ...y];
  } else {
    const [o, ...a] = e;
    return [n, ...a];
  }
}
function kn(t, e) {
  const n = Oe(t, e);
  if (!n)
    return;
  const [r, s, i] = n, o = Se(t.attrs, s);
  o && (q(t.eav, [r, s, i]), q(t.aev, [s, r, i]), et(o) && q(t.vae, [i, s, r]));
}
let jn = 0;
function Qt(t, e, n) {
  const [r, s, i] = n;
  let o;
  const a = tt(t.ea, [r, s, i]);
  return a && (o = a[3]), o || Date.now() * 10 + jn++;
}
function Tn(t, e) {
  const n = Oe(t, e);
  if (!n)
    return;
  const [r, s, i] = n, o = Se(t.attrs, s);
  if (!o)
    return;
  const a = tt(t.eav, [r, s, i]), c = (a == null ? void 0 : a[3]) ?? Qt(t, o, n), u = [r, s, i, c];
  En(o) ? (k(t.eav, [r, s], /* @__PURE__ */ new Map([[i, u]])), k(t.aev, [s, r], /* @__PURE__ */ new Map([[i, u]]))) : (k(t.eav, [r, s, i], u), k(t.aev, [s, r, i], u)), et(o) && k(t.vae, [i, s, r], u);
}
function In(t, e) {
  var d;
  const n = Oe(t, e);
  if (!n)
    return;
  const [r, s, i] = n, o = Se(t.attrs, s);
  if (!o) return;
  if (!Ft(o))
    throw new Error("merge operation is not supported for links");
  const a = tt(t.eav, [r, s]);
  if (!a) return;
  const c = (d = a.values().next()) == null ? void 0 : d.value;
  if (!c) return;
  const u = c[2], f = Lt(u, i), l = [
    r,
    s,
    f,
    Qt(t, o, c)
  ];
  k(t.eav, [r, s], /* @__PURE__ */ new Map([[f, l]]));
}
function xn(t, e) {
  var c, u;
  const [n, r] = e, s = Oe(t, [n]);
  if (!s)
    return;
  const [i] = s, o = t.eav.get(i);
  if (o) {
    for (const f of o.keys()) {
      const l = t.attrs[f];
      // Fall back to deleting everything if we've rehydrated tx-steps from
      // the store that didn't set `etype` in deleteEntity
      (!r || // If we don't know about the attr, let's just get rid of it
      !l || // Make sure it matches the etype
      ((c = l["forward-identity"]) == null ? void 0 : c[1]) === r) && (q(t.aev, [f, i]), q(t.eav, [i, f]));
    }
    o.size === 0 && q(t.eav, [i]);
  }
  const a = t.vae.get(i) && U(t.vae.get(i), 2);
  a && a.forEach((f) => {
    var b;
    const [l, d, h] = f, y = t.attrs[d];
    (!r || !y || ((b = y["reverse-identity"]) == null ? void 0 : b[1]) === r) && (q(t.eav, [l, d, h]), q(t.aev, [d, l, h]), q(t.vae, [h, d, l]));
  }), ((u = t.vae.get(i)) == null ? void 0 : u.size) === 0 && q(t.vae, [i]);
}
function Jt(t, e) {
  const n = Vt(t.attrs, e);
  Object.keys(n).forEach((r) => {
    t[r] = n[r];
  });
}
function Un(t, [e]) {
  t.attrs[e.id] = e, nt(t);
}
function Bt(t) {
  return U(t.eav, 3);
}
function $n(t, [e]) {
  if (!t.attrs[e]) return;
  const n = Bt(t).filter(([r, s]) => s !== e);
  delete t.attrs[e], nt(t), Jt(t, n);
}
function Dn(t, [e]) {
  const n = t.attrs[e.id];
  n && (t.attrs[e.id] = { ...n, ...e }, nt(t), Jt(t, Bt(t)));
}
function qn(t, e) {
  const [n, ...r] = e;
  switch (n) {
    case "add-triple":
      Tn(t, r);
      break;
    case "deep-merge-triple":
      In(t, r);
      break;
    case "retract-triple":
      kn(t, r);
      break;
    case "delete-entity":
      xn(t, r);
      break;
    case "add-attr":
      Un(t, r);
      break;
    case "delete-attr":
      $n(t, r);
      break;
    case "update-attr":
      Dn(t, r);
      break;
    default:
      throw new Error(`unhandled transaction action: ${n}`);
  }
}
function U(t, e, n = []) {
  if (!t || e === 0)
    return n;
  if (e === 1) {
    for (const r of t.values())
      n.push(r);
    return n;
  }
  for (const r of t.values())
    U(r, e - 1, n);
  return n;
}
function fe(t, e, n) {
  var i, o;
  const r = [];
  if (n != null && n.hasOwnProperty("$not")) {
    for (const a of e.keys())
      n.$not !== a && r.push(e.get(a));
    return r;
  }
  if (n != null && n.hasOwnProperty("$isNull")) {
    const { attrId: a, isNull: c, reverse: u } = n.$isNull;
    if (u)
      for (const f of e.keys()) {
        const l = t.vae.get(f), d = !l || ((i = l.get(a)) == null ? void 0 : i.get(null)) || !l.get(a);
        (c ? d : !d) && r.push(e.get(f));
      }
    else {
      const f = t.aev.get(a);
      for (const l of e.keys()) {
        const d = !f || ((o = f.get(l)) == null ? void 0 : o.get(null)) || !f.get(l);
        (c ? d : !d) && r.push(e.get(l));
      }
    }
    return r;
  }
  if (n != null && n.$comparator)
    return U(e, 1).filter(n.$op);
  const s = n.in || n.$in || [n];
  for (const a of s) {
    const c = e.get(a);
    c && r.push(c);
  }
  return r;
}
function Nn(t, e, n) {
  let r = "";
  return t !== void 0 && (r += "e"), e !== void 0 && (r += "a"), n !== void 0 && (r += "v"), r;
}
function Ln(t, [e, n, r]) {
  var i, o;
  switch (Nn(e, n, r)) {
    case "e": {
      const a = t.eav.get(e);
      return U(a, 2);
    }
    case "ea": {
      const a = (i = t.eav.get(e)) == null ? void 0 : i.get(n);
      return U(a, 1);
    }
    case "eav": {
      const a = (o = t.eav.get(e)) == null ? void 0 : o.get(n);
      return a ? fe(t, a, r) : [];
    }
    case "ev": {
      const a = t.eav.get(e);
      if (!a)
        return [];
      const c = [];
      for (const u of a.values())
        c.push(...fe(t, u, r));
      return c;
    }
    case "a": {
      const a = t.aev.get(n);
      return U(a, 2);
    }
    case "av": {
      const a = t.aev.get(n);
      if (!a)
        return [];
      const c = [];
      for (const u of a.values())
        c.push(...fe(t, u, r));
      return c;
    }
    case "v": {
      const a = [];
      for (const c of t.eav.values())
        for (const u of c.values())
          a.push(...fe(t, u, r));
    }
    default:
      return U(t.eav, 3);
  }
}
function zn(t, e, n) {
  var i;
  const r = t.attrIndexes.blobAttrs.get(e), s = {};
  for (const [o, a] of r.entries()) {
    const c = (i = t.eav.get(n)) == null ? void 0 : i.get(a.id), u = U(c, 1);
    for (const f of u)
      s[o] = f[2];
  }
  return s;
}
function ge(t, e, n) {
  var r;
  return (r = t.attrIndexes.forwardIdents.get(e)) == null ? void 0 : r.get(n);
}
function Kt(t, e, n) {
  var r;
  return (r = t.attrIndexes.revIdents.get(e)) == null ? void 0 : r.get(n);
}
function Fn(t, e) {
  var r;
  const n = t.attrIndexes.primaryKeys.get(e);
  return n || ((r = t.attrIndexes.forwardIdents.get(e)) == null ? void 0 : r.get("id"));
}
function bt(t, e) {
  return Cn(t, (n) => {
    e.forEach((r) => {
      qn(n, r);
    });
  });
}
function Vn(t) {
  return typeof t == "string" && t.startsWith("?");
}
function Wn(t, e, n) {
  if (n.hasOwnProperty(t)) {
    const r = n[t];
    return Ht(r, e, n);
  }
  return { ...n, [t]: e };
}
function _t(t, e, n) {
  return t === e ? n : null;
}
function Qn(t) {
  switch (typeof t) {
    case "string":
      return t.startsWith("?") ? Wn : _t;
    default:
      return _t;
  }
}
const Jn = [
  "in",
  "$in",
  "$not",
  "$isNull",
  "$comparator"
  // covers all of $gt, $lt, etc.
];
function Bn(t) {
  for (const e of Jn)
    if (t.hasOwnProperty(e))
      return !0;
  return !1;
}
function Ht(t, e, n) {
  return n ? typeof t == "object" ? Bn(t) ? n : null : Qn(t)(t, e, n) : null;
}
function Kn(t, e, n) {
  return t.reduce((r, s, i) => {
    const o = e[i];
    return Ht(s, o, r);
  }, n);
}
function Hn(t, e, n) {
  return Xn(t, e, n).map((r) => Kn(e, r, n)).filter((r) => r);
}
function Gn(t, e, n) {
  return e.or ? e.or.patterns.flatMap((r) => Ne(t, r, n)) : e.and ? e.and.patterns.reduce((r, s) => Ne(t, s, r), n) : n.flatMap((r) => Hn(t, e, r));
}
function Ne(t, e, n = [{}]) {
  return e.reduce((r, s) => Gn(t, s, r), n);
}
function rt(t, e) {
  return Array.isArray(e) ? e.map((n) => rt(t, n)) : Vn(e) ? t[e] : e;
}
function Yn(t, { find: e, where: n }) {
  return Ne(t, n).map((s) => rt(s, e));
}
function Xn(t, e, n) {
  return Ln(t, rt(n, e));
}
let le;
const Zn = new Uint8Array(16);
function er() {
  if (!le && (le = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !le))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return le(Zn);
}
const A = [];
for (let t = 0; t < 256; ++t)
  A.push((t + 256).toString(16).slice(1));
function tr(t, e = 0) {
  return A[t[e + 0]] + A[t[e + 1]] + A[t[e + 2]] + A[t[e + 3]] + "-" + A[t[e + 4]] + A[t[e + 5]] + "-" + A[t[e + 6]] + A[t[e + 7]] + "-" + A[t[e + 8]] + A[t[e + 9]] + "-" + A[t[e + 10]] + A[t[e + 11]] + A[t[e + 12]] + A[t[e + 13]] + A[t[e + 14]] + A[t[e + 15]];
}
const nr = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), wt = {
  randomUUID: nr
};
function rr(t, e, n) {
  if (wt.randomUUID && !e && !t)
    return wt.randomUUID();
  t = t || {};
  const r = t.random || (t.rng || er)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, tr(r);
}
function gt(t) {
  const e = t.replace(/-/g, ""), n = [];
  for (let r = 0; r < e.length; r += 2)
    n.push(parseInt(e.substring(r, r + 2), 16));
  return n;
}
function sr(t, e) {
  for (let n = 0; n < t.length; n++) {
    if (t[n] < e[n]) return -1;
    if (t[n] > e[n]) return 1;
  }
  return 0;
}
function ir(t, e) {
  return sr(gt(t), gt(e));
}
function C() {
  return rr();
}
let or = 0;
function ae(t) {
  return ve(`_${t}`, or++);
}
function ve(t, e) {
  return `?${t}-${e}`;
}
class ie extends Error {
  constructor(e) {
    super(e), this.name = "AttrNotFoundError";
  }
}
function ar(t, e) {
  const n = Fn(t, e);
  if (!n)
    throw new ie(`Could not find id attr for ${e}`);
  return n;
}
function mt(t, e, n, r) {
  return [cr(t, e, n, r)];
}
function cr(t, e, n, r) {
  return [
    t(n, r),
    ar(e, n).id,
    t(n, r),
    t("time", r)
  ];
}
function ur(t, e, n) {
  return t.map((r) => r === e ? n : r);
}
function Gt(t, e, n, r, s) {
  const i = ge(e, n, s), o = Kt(e, n, s), a = i || o;
  if (!a)
    throw new ie(`Could not find attr for ${[n, s]}`);
  if (a["value-type"] !== "ref")
    throw new Error(`Attr ${a.id} is not a ref`);
  const [c, u] = a["forward-identity"], [f, l] = a["reverse-identity"], d = r + 1, h = i ? [
    t(u, r),
    a.id,
    t(l, d),
    ae("time")
  ] : [
    t(u, d),
    a.id,
    t(l, r),
    ae("time")
  ];
  return [i ? l : u, d, h, a, !!i];
}
function St(t, e) {
  if (typeof e != "string")
    return function(i) {
      return !1;
    };
  const n = e.replace(/%/g, ".*").replace(/_/g, "."), r = new RegExp(
    `^${n}$`,
    t ? void 0 : "i"
  );
  return function(i) {
    return typeof i != "string" ? !1 : r.test(i);
  };
}
function fr(t, e) {
  if (typeof e != "object" || e.hasOwnProperty("$in") || e.hasOwnProperty("in"))
    return e;
  const n = t["checked-data-type"] === "date";
  if (e.hasOwnProperty("$gt"))
    return {
      $comparator: !0,
      $op: n ? function(s) {
        return new Date(s[2]) > new Date(e.$gt);
      } : function(s) {
        return s[2] > e.$gt;
      }
    };
  if (e.hasOwnProperty("$gte"))
    return {
      $comparator: !0,
      $op: n ? function(s) {
        return new Date(s[2]) >= new Date(e.$gte);
      } : function(s) {
        return s[2] >= e.$gte;
      }
    };
  if (e.hasOwnProperty("$lt"))
    return {
      $comparator: !0,
      $op: n ? function(s) {
        return new Date(s[2]) < new Date(e.$lt);
      } : function(s) {
        return s[2] < e.$lt;
      }
    };
  if (e.hasOwnProperty("$lte"))
    return {
      $comparator: !0,
      $op: n ? function(s) {
        return new Date(s[2]) <= new Date(e.$lte);
      } : function(s) {
        return s[2] <= e.$lte;
      }
    };
  if (e.hasOwnProperty("$like")) {
    const r = St(!0, e.$like);
    return {
      $comparator: !0,
      $op: function(i) {
        return r(i[2]);
      }
    };
  }
  if (e.hasOwnProperty("$ilike")) {
    const r = St(!1, e.$ilike);
    return {
      $comparator: !0,
      $op: function(i) {
        return r(i[2]);
      }
    };
  }
  return e;
}
function lr(t, e, n, r, s, i) {
  const o = ge(e, n, s), a = Kt(e, n, s), c = o || a;
  if (!c)
    throw new ie(
      `No attr for etype = ${n} label = ${s}`
    );
  if (i != null && i.hasOwnProperty("$isNull")) {
    const u = ge(e, n, "id");
    if (!u)
      throw new ie(
        `No attr for etype = ${n} label = id`
      );
    return [
      t(n, r),
      u.id,
      { $isNull: { attrId: c.id, isNull: i.$isNull, reverse: !o } },
      ae("time")
    ];
  }
  return o ? [
    t(n, r),
    c.id,
    fr(c, i),
    ae("time")
  ] : [i, c.id, t(n, r), ae("time")];
}
function dr(t, e, n, r, s) {
  const [i, o, a] = s.reduce(
    (c, u) => {
      const [f, l, d] = c, [h, y, b] = Gt(
        t,
        e,
        f,
        l,
        u
      );
      return [h, y, [...d, b]];
    },
    [n, r, []]
  );
  return [i, o, a];
}
function Le(t, e, n, r, s, i) {
  const o = s.slice(0, s.length - 1), a = s[s.length - 1], [c, u, f] = dr(
    t,
    e,
    n,
    r,
    o
  ), l = lr(
    t,
    e,
    c,
    u,
    a,
    i
  );
  return f.concat([l]);
}
function hr(t, e) {
  return e ? [e].concat(t) : t;
}
function pr([t, e]) {
  return t === "or" && Array.isArray(e);
}
function yr([t, e]) {
  return t === "and" && Array.isArray(e);
}
function br(t, e, n) {
  return (r, s) => r == e ? t(r, s) : `${t(r, s)}-${n}`;
}
function Ot(t, e, n, r, s, i) {
  const o = i.map((c, u) => {
    const f = br(t, r, u);
    return Yt(f, n, r, s, c);
  }), a = t(r, s);
  return { [e]: { patterns: o, joinSym: a } };
}
function _r(t) {
  const e = [];
  for (let n = 1; n <= t.length; n++)
    e.push(t.slice(0, n));
  return e;
}
function vt(t, e, n, r, s) {
  return _r(s).map(
    (i) => Le(t, e, n, r, i, { $isNull: !0 })
  );
}
function Yt(t, e, n, r, s) {
  return Object.entries(s).flatMap(([i, o]) => {
    if (pr([i, o]))
      return Ot(t, "or", e, n, r, o);
    if (yr([i, o]))
      return Ot(t, "and", e, n, r, o);
    const a = i.split(".");
    if (o != null && o.hasOwnProperty("$not")) {
      const c = Le(t, e, n, r, a, o), u = vt(
        t,
        e,
        n,
        r,
        a
      );
      return [
        {
          or: {
            patterns: [c, ...u],
            joinSym: t(n, r)
          }
        }
      ];
    }
    return o != null && o.hasOwnProperty("$isNull") && o.$isNull === !0 && a.length > 1 ? [
      {
        or: {
          patterns: vt(
            t,
            e,
            n,
            r,
            a
          ),
          joinSym: t(n, r)
        }
      }
    ] : Le(t, e, n, r, a, o);
  });
}
function wr(t, e, n, r) {
  const s = ve;
  return r ? Yt(s, t, e, n, r).concat(mt(s, t, e, n)) : mt(s, t, e, n);
}
function gr(t, e, n) {
  return [t(e, n), t("time", n)];
}
function mr(t, e, n, r, s, i) {
  const [o, a, c, u, f] = Gt(
    t,
    e,
    n,
    r,
    s
  ), l = ur(c, t(n, r), i);
  return [o, a, l, u, f];
}
function Sr(t, e, { etype: n, level: r, form: s }, i) {
  const o = Object.keys(s).filter((a) => a !== "$");
  return o.length ? Object.entries(i).map(function([c, u]) {
    return o.map(function(d) {
      var y, b, w;
      const h = !!(e.cardinalityInference && ((w = (b = (y = e.linkIndex) == null ? void 0 : y[n]) == null ? void 0 : b[d]) != null && w.isSingular));
      try {
        const [_, S, O] = mr(
          t,
          e,
          n,
          r,
          d,
          c
        ), V = Xt(e, {
          etype: _,
          level: S,
          form: s[d],
          join: O
        }), g = h ? V[0] : V;
        return { [d]: g };
      } catch (_) {
        if (_ instanceof ie)
          return { [d]: h ? void 0 : [] };
        throw _;
      }
    }).reduce(function(d, h) {
      return { ...d, ...h };
    }, u);
  }) : Object.values(i);
}
function me([t, e], [n, r]) {
  return e === r || e == null && r == null ? ir(t, n) : r == null ? 1 : e == null ? -1 : e > r ? 1 : -1;
}
function ze(t) {
  return t == null ? t : new Date(t).getTime();
}
function Or(t, e, n, r) {
  var h;
  const [s, i, o, a] = t, c = n === "desc" ? 1 : -1;
  if (((h = e["forward-identity"]) == null ? void 0 : h[2]) === "id")
    return me(r, [s, a]) === c;
  const [u, f] = r, l = e["checked-data-type"] === "date" ? ze(f) : f, d = e["checked-data-type"] === "date" ? ze(o) : o;
  return me([u, l], [s, d]) === c;
}
function vr(t, e) {
  const n = e[1];
  return t.attrs[n];
}
function Mr(t, e, n) {
  const r = Object.keys(n)[0];
  return ge(t, e, r);
}
function Ar(t, e, n, r) {
  if (n)
    return vr(t, n);
  if (r)
    return Mr(t, e, r);
}
function Cr(t, e, n, r, s, i) {
  var f;
  let o = Yn(t, i);
  const a = r == null ? void 0 : r["start-cursor"], c = Ar(t, e, a, s);
  if (c && ((f = c == null ? void 0 : c["forward-identity"]) == null ? void 0 : f[2]) !== "id") {
    const l = c["checked-data-type"] === "date", d = c.id;
    o = o.map(([h]) => {
      var b, w, _, S, O;
      let y = (O = (S = (_ = (w = (b = t.eav.get(h)) == null ? void 0 : b.get(d)) == null ? void 0 : w.values()) == null ? void 0 : _.next()) == null ? void 0 : S.value) == null ? void 0 : O[2];
      return l && (y = ze(y)), [h, y];
    });
  }
  o.sort(
    n === "asc" ? function(d, h) {
      return me(d, h);
    } : function(d, h) {
      return me(h, d);
    }
  );
  let u = {};
  for (const l of o) {
    const [d] = l;
    if (u[d] || a && c && Or(a, c, n, l))
      continue;
    const h = zn(t, e, d);
    h && (u[d] = h);
  }
  return u;
}
function Er(t) {
  var n;
  const e = (n = t.$) == null ? void 0 : n.order;
  return e && e[Object.keys(e)[0]] || "asc";
}
function Pr(t, { etype: e, level: n, form: r, join: s, pageInfo: i }) {
  var y, b, w, _, S, O, V, g;
  const o = ((y = r.$) == null ? void 0 : y.limit) || ((b = r.$) == null ? void 0 : b.first) || ((w = r.$) == null ? void 0 : w.last), a = (_ = r.$) == null ? void 0 : _.offset, c = (S = r.$) == null ? void 0 : S.before, u = (O = r.$) == null ? void 0 : O.after, f = (V = r.$) == null ? void 0 : V.order;
  if ((a || c || u) && (!i || !i["start-cursor"]))
    return [];
  const l = hr(wr(t, e, n, (g = r.$) == null ? void 0 : g.where), s), d = gr(ve, e, n), h = Cr(
    t,
    e,
    Er(r),
    i,
    f,
    { where: l, find: d }
  );
  if (o != null) {
    const R = Object.entries(h);
    return R.length <= o ? h : Object.fromEntries(R.slice(0, o));
  }
  return h;
}
function Rr(t, e) {
  try {
    return Pr(t, e);
  } catch (n) {
    if (n instanceof ie)
      return {};
    throw n;
  }
}
function Xt(t, e) {
  const n = Rr(t, e);
  return Sr(ve, t, e, n);
}
function kr(t) {
  const e = {};
  for (const [n, r] of Object.entries(t))
    e[n] = {
      startCursor: r["start-cursor"],
      endCursor: r["end-cursor"],
      hasNextPage: r["has-next-page?"],
      hasPreviousPage: r["has-previous-page?"]
    };
  return e;
}
function jr({ store: t, pageInfo: e, aggregate: n }, r) {
  const i = { data: Object.keys(r).reduce(function(a, c) {
    return n != null && n[c] || (a[c] = Xt(t, {
      etype: c,
      form: r[c],
      level: 0,
      pageInfo: e == null ? void 0 : e[c]
    })), a;
  }, {}) };
  return e && (i.pageInfo = kr(e)), n && (i.aggregate = n), i;
}
function Fe(t, e, n) {
  return new Proxy({}, {
    get: (r, s) => s === "__ops" ? n : (i) => Fe(t, e, [
      ...n,
      [s, t, e, i]
    ])
  });
}
function Qs(t, e) {
  return `lookup__${t}__${JSON.stringify(e)}`;
}
function Ve(t) {
  return t.startsWith("lookup__");
}
function Zt(t) {
  const [e, n, ...r] = t.split("__");
  return [n, JSON.parse(r.join("__"))];
}
function Tr(t) {
  return new Proxy(
    {},
    {
      get(e, n) {
        return Ve(n) ? Fe(t, Zt(n), []) : Fe(t, n, []);
      }
    }
  );
}
function en() {
  return new Proxy(
    {},
    {
      get(t, e) {
        return Tr(e);
      }
    }
  );
}
const Js = en();
function Ir(t) {
  return t.__ops;
}
function xr(t, e) {
  const { attrIdMap: n, refSwapAttrIds: r } = t, s = [];
  for (const o of e) {
    const a = n[o];
    if (a)
      s.push(a);
    else if (Array.isArray(o) && o.length == 2 && n[o[0]]) {
      const [c, u] = o;
      s.push([n[c], u]);
    } else
      s.push(o);
  }
  const [i] = e;
  if ((i === "add-triple" || i === "retract-triple") && r.has(e[2])) {
    const o = s[1];
    s[1] = s[3], s[3] = o;
  }
  return s;
}
function j(t, e, n) {
  return Object.values(t).find((r) => {
    const [s, i, o] = r["forward-identity"];
    return i === e && o === n;
  });
}
function Z(t, e, n) {
  return Object.values(t).find((r) => {
    const s = r["reverse-identity"];
    if (!s) return !1;
    const [i, o, a] = s;
    return o === e && a === n;
  });
}
function Ur(t) {
  if (Array.isArray(t))
    return t;
  const e = Object.entries(t);
  if (e.length !== 1)
    throw new Error(
      "lookup must be an object with a single unique attr and value."
    );
  return e[0];
}
function We(t, e, n) {
  return n.indexOf(".") !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
  // before assuming it's a ref lookup.
  !j(t, e, n);
}
function Qe(t) {
  const [e, n, ...r] = t.split(".");
  if (r.length > 0 || n !== "id")
    throw new Error(`${t} is not a valid lookup attribute.`);
  return e;
}
function $r(t, e, n) {
  if (!We(t, e, n))
    return j(t, e, n);
  const r = Qe(n), s = j(t, e, r) || Z(t, e, r);
  if (s && s["value-type"] !== "ref")
    throw new Error(`${n} does not reference a valid link attribute.`);
  return s;
}
function Je(t) {
  return typeof t == "string" && !Ve(t) ? null : typeof t == "string" && Ve(t) ? Zt(t) : Ur(t);
}
function $(t, e, n) {
  const r = Je(n);
  if (r === null)
    return n;
  const [s, i] = r, o = $r(t, e, s);
  if (!o || !o["unique?"])
    throw new Error(`${s} is not a unique attribute.`);
  return [o.id, i];
}
function Dr(t, [e, n, r]) {
  return Object.entries(r).flatMap(([i, o]) => {
    const a = Array.isArray(o) ? o : [o], c = j(t, e, i), u = Z(t, e, i);
    return a.map((f) => c ? [
      "add-triple",
      $(t, e, n),
      c.id,
      $(t, c["reverse-identity"][1], f)
    ] : [
      "add-triple",
      $(t, u["forward-identity"][1], f),
      u.id,
      $(t, e, n)
    ]);
  });
}
function qr(t, [e, n, r]) {
  return Object.entries(r).flatMap(([i, o]) => {
    const a = Array.isArray(o) ? o : [o], c = j(t, e, i), u = Z(t, e, i);
    return a.map((f) => c ? [
      "retract-triple",
      $(t, e, n),
      c.id,
      $(t, c["reverse-identity"][1], f)
    ] : [
      "retract-triple",
      $(t, u["forward-identity"][1], f),
      u.id,
      $(t, e, n)
    ]);
  });
}
function Nr(t, [e, n, r]) {
  const s = $(t, e, n);
  return [["id", $(t, e, n)]].concat(Object.entries(r)).map(([o, a]) => {
    const c = j(t, e, o);
    return ["add-triple", s, c.id, a];
  });
}
function Lr(t, [e, n]) {
  return [["delete-entity", $(t, e, n), e]];
}
function zr(t, [e, n, r]) {
  const s = $(t, e, n), i = Object.entries(r).map(([a, c]) => {
    const u = j(t, e, a), f = zt(c, void 0, null);
    return ["deep-merge-triple", s, u.id, f];
  });
  return [[
    "add-triple",
    s,
    j(t, e, "id").id,
    s
  ]].concat(i);
}
function Fr(t) {
  const [e, n, r, s] = t;
  if (!s)
    return t;
  const i = { ...s };
  return delete i.id, [e, n, r, i];
}
function Vr(t, e) {
  const [n, ...r] = Fr(e);
  switch (n) {
    case "merge":
      return zr(t, r);
    case "update":
      return Nr(t, r);
    case "link":
      return Dr(t, r);
    case "unlink":
      return qr(t, r);
    case "delete":
      return Lr(t, r);
    default:
      throw new Error(`unsupported action ${n}`);
  }
}
function Wr(t) {
  switch (t) {
    case "string":
    case "date":
    case "boolean":
    case "number":
      return t;
    default:
      return;
  }
}
function Qr(t, e, n) {
  var a, c;
  const r = (c = (a = t.entities[e]) == null ? void 0 : a.attrs) == null ? void 0 : c[n];
  if (n === "id") return null;
  if (!r)
    throw new Error(`${e}.${n} does not exist in your schema`);
  const { unique: s, indexed: i } = r == null ? void 0 : r.config, o = Wr(r == null ? void 0 : r.valueType);
  return {
    "index?": i,
    "unique?": s,
    "checked-data-type": o
  };
}
function Re(t, e, n, r) {
  const s = t ? Qr(t, e, n) : null, i = C(), a = [C(), e, n];
  return {
    id: i,
    "forward-identity": a,
    "value-type": "blob",
    cardinality: "one",
    "unique?": !1,
    "index?": !1,
    isUnsynced: !0,
    ...s || {},
    ...r || {}
  };
}
function Jr(t, e, n) {
  return Object.values(t.links).find((s) => s.forward.on === e && s.forward.label === n || s.reverse.on === e && s.reverse.label === n);
}
function Br(t, e, n) {
  const r = Jr(t, e, n);
  if (!r)
    throw new Error(`Couldn't find the link ${e}.${n} in your schema`);
  const { forward: s, reverse: i } = r;
  return {
    "forward-identity": [C(), s.on, s.label],
    "reverse-identity": [C(), i.on, i.label],
    cardinality: s.has === "one" ? "one" : "many",
    "unique?": i.has === "one"
  };
}
function Mt(t, e, n, r) {
  const s = t ? Br(t, e, n) : null, i = C(), o = [C(), e, n], a = [C(), n, e];
  return {
    id: i,
    "forward-identity": o,
    "reverse-identity": a,
    "value-type": "ref",
    cardinality: "many",
    "unique?": !1,
    "index?": !1,
    isUnsynced: !0,
    ...s || {},
    ...r || {}
  };
}
const Kr = /* @__PURE__ */ new Set(["update", "merge", "link", "unlink"]), Hr = /* @__PURE__ */ new Set(["link", "unlink"]), Gr = /* @__PURE__ */ new Set(["update", "merge"]), Yr = /* @__PURE__ */ new Set([
  "link",
  "unlink",
  "update",
  "merge",
  "delete"
]), Be = { "unique?": !0, "index?": !0 }, Xr = { ...Be, cardinality: "one" };
function Zr(t) {
  const e = [], [n, r, s, i] = t;
  if (!Yr.has(n))
    return e;
  const o = Je(s);
  if (o && e.push({ etype: r, lookupPair: o }), n === "link")
    for (const [a, c] of Object.entries(i)) {
      const u = Array.isArray(c) ? c : [c];
      for (const f of u) {
        const l = Je(f);
        l && e.push({
          etype: r,
          lookupPair: l,
          linkLabel: a
        });
      }
    }
  return e;
}
function es({ attrs: t, schema: e }, n) {
  var u, f;
  const [r, s, i] = [/* @__PURE__ */ new Set(), { ...t }, []];
  function o(l) {
    s[l.id] = l, i.push(["add-attr", l]), r.add(l.id);
  }
  function a(l) {
    l != null && l.isUnsynced && !r.has(l.id) && (i.push(["add-attr", l]), r.add(l.id));
  }
  function c(l, d) {
    const h = j(s, l, d), y = Z(s, l, d);
    a(h), a(y), !h && !y && o(Mt(e, l, d, Xr));
  }
  for (const l of n)
    for (const { etype: d, lookupPair: h, linkLabel: y } of Zr(l)) {
      const b = h[0];
      if (y) {
        c(d, y);
        const w = j(s, d, y), _ = Z(s, d, y);
        a(w), a(_);
        const S = ((u = w == null ? void 0 : w["reverse-identity"]) == null ? void 0 : u[1]) || ((f = _ == null ? void 0 : _["forward-identity"]) == null ? void 0 : f[1]) || y;
        if (We(s, S, b))
          c(S, Qe(b));
        else {
          const O = j(s, S, b);
          O || o(
            Re(e, S, b, Be)
          ), a(O);
        }
      } else if (We(s, d, b))
        c(d, Qe(b));
      else {
        const w = j(s, d, b);
        w || o(Re(e, d, b, Be)), a(w);
      }
    }
  for (const l of n) {
    const [d, h, y, b] = l;
    if (Kr.has(d)) {
      const w = Object.keys(b);
      w.push("id");
      for (const _ of w) {
        const S = j(s, h, _);
        if (a(S), Gr.has(d) && (S || o(
          Re(
            e,
            h,
            _,
            _ === "id" ? { "unique?": !0 } : null
          )
        )), Hr.has(d)) {
          const O = Z(s, h, _);
          !S && !O && o(Mt(e, h, _)), a(O);
        }
      }
    }
  }
  return [s, i];
}
function ts(t, e) {
  const r = (Array.isArray(e) ? e : [e]).flatMap((a) => Ir(a)), [s, i] = es(t, r), o = r.flatMap((a) => Vr(s, a));
  return [...i, ...o];
}
class tn {
  constructor(e) {
    this.dbName = e, this._storeName = "kv", this._dbPromise = this._init();
  }
  _init() {
    return new Promise((e, n) => {
      const r = indexedDB.open(this.dbName, 1);
      r.onerror = (s) => {
        n(s);
      }, r.onsuccess = (s) => {
        e(s.target.result);
      }, r.onupgradeneeded = (s) => {
        s.target.result.createObjectStore(this._storeName);
      };
    });
  }
  async getItem(e) {
    const n = await this._dbPromise;
    return new Promise((r, s) => {
      const a = n.transaction([this._storeName], "readonly").objectStore(this._storeName).get(e);
      a.onerror = (c) => {
        s(c);
      }, a.onsuccess = (c) => {
        a.result ? r(a.result) : r(null);
      };
    });
  }
  async setItem(e, n) {
    const r = await this._dbPromise;
    return new Promise((s, i) => {
      const c = r.transaction([this._storeName], "readwrite").objectStore(this._storeName).put(n, e);
      c.onerror = (u) => {
        i(u);
      }, c.onsuccess = (u) => {
        s();
      };
    });
  }
}
class nn {
  static async getIsOnline() {
    return navigator.onLine;
  }
  static listen(e) {
    const n = () => {
      e(!0);
    }, r = () => {
      e(!1);
    };
    return addEventListener("online", n), addEventListener("offline", r), () => {
      removeEventListener("online", n), removeEventListener("offline", r);
    };
  }
}
async function B(t, e) {
  const n = await fetch(t, e), r = await n.json();
  return n.status === 200 ? Promise.resolve(r) : Promise.reject({ status: n.status, body: r });
}
function ns({ apiURI: t, appId: e, email: n }) {
  return B(`${t}/runtime/auth/send_magic_code`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ "app-id": e, email: n })
  });
}
async function rs({ apiURI: t, appId: e, email: n, code: r }) {
  return await B(`${t}/runtime/auth/verify_magic_code`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ "app-id": e, email: n, code: r })
  });
}
async function ss({ apiURI: t, appId: e, refreshToken: n }) {
  return await B(`${t}/runtime/auth/verify_refresh_token`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      "app-id": e,
      "refresh-token": n
    })
  });
}
async function At({
  apiURI: t,
  appId: e,
  code: n,
  codeVerifier: r
}) {
  return await B(`${t}/runtime/oauth/token`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      app_id: e,
      code: n,
      code_verifier: r
    })
  });
}
async function is({
  apiURI: t,
  appId: e,
  nonce: n,
  idToken: r,
  clientName: s,
  refreshToken: i
}) {
  return await B(`${t}/runtime/oauth/id_token`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({
      app_id: e,
      nonce: n,
      id_token: r,
      client_name: s,
      refresh_token: i
    })
  });
}
async function os({ apiURI: t, appId: e, refreshToken: n }) {
  return await B(`${t}/runtime/signout`, {
    method: "POST",
    headers: {
      "content-type": "application/json"
    },
    body: JSON.stringify({
      app_id: e,
      refresh_token: n
    })
  });
}
async function as({
  apiURI: t,
  appId: e,
  fileName: n,
  refreshToken: r,
  metadata: s = {}
}) {
  const { data: i } = await B(`${t}/storage/signed-upload-url`, {
    method: "POST",
    headers: {
      "content-type": "application/json",
      authorization: `Bearer ${r}`
    },
    body: JSON.stringify({
      app_id: e,
      filename: n
    })
  });
  return i;
}
async function cs(t, e) {
  return (await fetch(t, {
    method: "PUT",
    body: e,
    headers: {
      "Content-Type": e.type
    }
  })).ok;
}
async function us({
  apiURI: t,
  appId: e,
  path: n,
  refreshToken: r
}) {
  const { data: s } = await B(
    `${t}/storage/signed-download-url?app_id=${e}&filename=${encodeURIComponent(n)}`,
    {
      method: "GET",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${r}`
      }
    }
  );
  return s;
}
async function fs({
  apiURI: t,
  appId: e,
  path: n,
  refreshToken: r
}) {
  const { data: s } = await B(
    `${t}/storage/files?app_id=${e}&filename=${encodeURIComponent(n)}`,
    {
      method: "DELETE",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${r}`
      }
    }
  );
  return s;
}
function Ct(t, e) {
  if (!e) return t;
  const n = {};
  return e.forEach((r) => {
    n[r] = t[r];
  }), n;
}
function ls(t, e, n) {
  const r = {
    peers: {}
  };
  if (e && "user" in e ? e.user : !0) {
    const i = Ct(t.user ?? {}, e == null ? void 0 : e.keys);
    r.user = { ...i, peerId: n };
  }
  for (const i of Object.keys(t.peers ?? {})) {
    const o = (e == null ? void 0 : e.peers) === void 0, a = Array.isArray(e == null ? void 0 : e.peers) && (e == null ? void 0 : e.peers.includes(i));
    if (o || a) {
      const c = Ct(t.peers[i], e == null ? void 0 : e.keys);
      r.peers[i] = { ...c, peerId: i };
    }
  }
  return r;
}
function ds(t, e) {
  if (t.isLoading !== e.isLoading || t.error !== e.error || (t.user || e.user) && (!t.user || !e.user || !yt(t.user, e.user)) || !Nt(t.peers, e.peers)) return !0;
  for (const r of Object.keys(t.peers))
    if (!yt(t.peers[r], e.peers[r])) return !0;
  return !1;
}
class Et {
  constructor() {
    p(this, "promise");
    p(this, "_resolve");
    p(this, "_reject");
    this.promise = new Promise((e, n) => {
      this._resolve = e, this._reject = n;
    });
  }
  resolve(e) {
    this._resolve(e);
  }
  reject(e) {
    this._reject(e);
  }
}
class Pt {
  constructor(e, n, r, s, i = (c) => JSON.stringify(c), o = (c) => JSON.parse(c), a = 100) {
    p(this, "_subs", []);
    this._persister = e, this._key = n, this._onMerge = s, this._loadedCbs = [], this._isLoading = !0, this.currentValue = r, this.toJSON = i, this.fromJSON = o, this._saveThrottleMs = a, this._pendingSaveCbs = [], this._version = 0, this._load();
  }
  async _load() {
    const e = this.fromJSON(await this._persister.getItem(this._key));
    this._isLoading = !1, this._onMerge(e, this.currentValue);
    for (const n of this._loadedCbs)
      n();
  }
  async waitForLoaded() {
    if (!this._isLoading)
      return;
    await new Promise((n) => {
      this._loadedCbs.push(n);
    });
  }
  isLoading() {
    return this._isLoading;
  }
  version() {
    return this._version;
  }
  async waitForSync() {
    if (!this._nextSave)
      return;
    await new Promise((n) => {
      this._pendingSaveCbs.push(n);
    });
  }
  _writeToStorage() {
    this._persister.setItem(this._key, this.toJSON(this.currentValue));
    for (const e of this._pendingSaveCbs)
      e();
    this._pendingSaveCbs.length = 0;
  }
  async flush() {
    this._nextSave && (clearTimeout(this._nextSave), this._writeToStorage());
  }
  _enqueuePersist(e) {
    if (this._nextSave) {
      e && this._pendingSaveCbs.push(e);
      return;
    }
    this._nextSave = setTimeout(() => {
      this._nextSave = null, this._writeToStorage();
    }, this._saveThrottleMs);
  }
  set(e, n) {
    this._version++, this.currentValue = e(this.currentValue), this._isLoading ? this._loadedCbs.push(() => this._enqueuePersist(n)) : this._enqueuePersist(n);
    for (const r of this._subs)
      r(this.currentValue);
  }
  subscribe(e) {
    return this._subs.push(e), e(this.currentValue), () => {
      this._subs = this._subs.filter((n) => n !== e);
    };
  }
}
function rn(t, e = []) {
  t.forEach((n) => {
    const { data: r } = n, { "datalog-result": s } = r, { "join-rows": i } = s;
    for (const o of i)
      for (const a of o)
        e.push(a);
    rn(n["child-nodes"], e);
  });
}
function Rt(t) {
  const e = [];
  return rn(t, e), e;
}
function hs(t) {
  return Object.values(t.links).reduce((e, n) => {
    var r, s;
    return e[r = n.forward.on] ?? (e[r] = {}), e[n.forward.on][n.forward.label] = {
      isForward: !0,
      isSingular: n.forward.has === "one",
      link: n
    }, e[s = n.reverse.on] ?? (e[s] = {}), e[n.reverse.on][n.reverse.label] = {
      isForward: !1,
      isSingular: n.reverse.has === "one",
      link: n
    }, e;
  }, {});
}
const sn = "v0.17.3", Y = {
  CONNECTING: "connecting",
  OPENED: "opened",
  AUTHENTICATED: "authenticated",
  CLOSED: "closed",
  ERRORED: "errored"
}, ps = 3e4, ys = 0, kt = 1, bs = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
}, ke = "_instant_oauth_redirect", je = "currentUser";
let _s = 0;
function ws(t) {
  const e = new WebSocket(t);
  return e._id = _s++, e;
}
function gs() {
  return typeof window < "u" || typeof chrome < "u";
}
const jt = {
  "set-presence": !0,
  "set-presence-ok": !0,
  "refresh-presence": !0
};
function ms(t) {
  var n;
  const e = JSON.parse(t);
  for (const r in e) {
    const s = e[r];
    (n = s == null ? void 0 : s.result) != null && n.store && (s.result.store = Rn(s.result.store));
  }
  return e;
}
function Ss(t) {
  var n;
  const e = {};
  for (const r in t) {
    const s = t[r], i = { ...s };
    (n = s.result) != null && n.store && (i.result = {
      ...s.result,
      store: Pn(s.result.store)
    }), e[r] = i;
  }
  return JSON.stringify(e);
}
class Os {
  constructor(e, n = tn, r = nn, s) {
    p(this, "attrs");
    p(this, "_isOnline", !0);
    p(this, "_isShutdown", !1);
    p(this, "status", Y.CONNECTING);
    /** @type {PersistedObject} */
    p(this, "querySubs");
    /** @type {PersistedObject} */
    p(this, "pendingMutations");
    /** @type {Record<string, Array<{ q: any, cb: (data: any) => any }>>} */
    p(this, "queryCbs", {});
    /** @type {Record<string, Array<{ q: any, eventId: string, dfd: Deferred }>>} */
    p(this, "queryOnceDfds", {});
    p(this, "authCbs", []);
    p(this, "attrsCbs", []);
    p(this, "mutationErrorCbs", []);
    p(this, "connectionStatusCbs", []);
    p(this, "config");
    p(this, "_persister");
    p(this, "mutationDeferredStore", /* @__PURE__ */ new Map());
    p(this, "_reconnectTimeoutId", null);
    p(this, "_reconnectTimeoutMs", 0);
    p(this, "_ws");
    p(this, "_localIdPromises", {});
    p(this, "_errorMessage", null);
    /** @type {Promise<null | {error: {message: string}}>}**/
    p(this, "_oauthCallbackResponse", null);
    /** @type {null | import('./utils/linkIndex').LinkIndex}} */
    p(this, "_linkIndex", null);
    /** @type BroadcastChannel | undefined */
    p(this, "_broadcastChannel");
    /** @type {Record<string, {isConnected: boolean; error: any}>} */
    p(this, "_rooms", {});
    /** @type {Record<string, boolean>} */
    p(this, "_roomsPendingLeave", {});
    p(this, "_presence", {});
    p(this, "_broadcastQueue", []);
    p(this, "_broadcastSubs", {});
    p(this, "_currentUserCached", { isLoading: !0, error: void 0, user: void 0 });
    p(this, "_beforeUnloadCbs", []);
    p(this, "_dataForQueryCache", {});
    /**
     *  merge querySubs from storage and in memory. Has the following side
     *  effects:
     *  - We notify all queryCbs because results may been added during merge
     */
    p(this, "_onMergeQuerySubs", (e, n) => {
      const r = e || {}, s = { ...n };
      Object.entries(n).forEach(([o, a]) => {
        var f;
        const c = (f = r == null ? void 0 : r[o]) == null ? void 0 : f.result, u = a.result;
        c && !u && (s[o].result = c);
      }), Object.keys(r).filter((o) => !n[o]).slice(0, 10).forEach((o) => {
        s[o] = r[o];
      }), this.querySubs.set((o) => s), this.loadedNotifyAll();
    });
    /**
     * merge pendingMutations from storage and in memory. Has a side effect of
     * sending mutations that were stored but not acked
     */
    p(this, "_onMergePendingMutations", (e, n) => {
      const r = new Map([...e.entries(), ...n.entries()]);
      this.pendingMutations.set((i) => r), this.loadedNotifyAll(), this._rewriteMutations(
        this.attrs,
        e
      ).forEach((i, o) => {
        !n.has(o) && !i["tx-id"] && this._sendMutation(o, i);
      });
    });
    // ---------------------------
    // Queries
    p(this, "getPreviousResult", (e) => {
      const n = x(e);
      return this.dataForQuery(n);
    });
    /** Re-run instaql and call all callbacks with new data */
    p(this, "notifyOne", (e) => {
      var i;
      const n = this.queryCbs[e] ?? [], r = (i = this._dataForQueryCache[e]) == null ? void 0 : i.data, s = this.dataForQuery(e);
      s && (_e(s, r) || n.forEach((o) => o.cb(s)));
    });
    p(this, "notifyOneQueryOnce", (e) => {
      const n = this.queryOnceDfds[e] ?? [], r = this.dataForQuery(e);
      n.forEach((s) => {
        this._completeQueryOnce(s.q, e, s.dfd), s.dfd.resolve(r);
      });
    });
    p(this, "notifyQueryError", (e, n) => {
      (this.queryCbs[e] || []).forEach((s) => s.cb({ error: n }));
    });
    /** Applies transactions locally and sends transact message to server */
    p(this, "pushTx", (e) => {
      try {
        const n = ts(
          { attrs: this.optimisticAttrs(), schema: this.config.schema },
          e
        );
        return this.pushOps(n);
      } catch (n) {
        return this.pushOps([], n);
      }
    });
    /**
     * @param {*} txSteps
     * @param {*} [error]
     * @returns
     */
    p(this, "pushOps", (e, n) => {
      const r = C(), s = {
        op: "transact",
        "tx-steps": e,
        error: n
      };
      this.pendingMutations.set((o) => (o.set(r, s), o));
      const i = new Et();
      return this.mutationDeferredStore.set(r, i), this._sendMutation(r, s), this.notifyAll(), i.promise;
    });
    p(this, "_wsOnOpen", (e) => {
      const n = e.target;
      if (this._ws !== n) {
        E.info(
          "[socket][open]",
          n._id,
          "skip; this is no longer the current ws"
        );
        return;
      }
      E.info("[socket][open]", this._ws._id), this._setStatus(Y.OPENED), this.getCurrentUser().then((r) => {
        var s;
        this._trySend(C(), {
          op: "init",
          "app-id": this.config.appId,
          "refresh-token": (s = r.user) == null ? void 0 : s.refresh_token,
          versions: this.versions,
          // If an admin token is provided for an app, we will
          // skip all permission checks. This is an advanced feature,
          // to let users write internal tools
          // This option is not exposed in `Config`, as it's
          // not ready for prme time
          "__admin-token": this.config.__adminToken
        });
      });
    });
    p(this, "_wsOnMessage", (e) => {
      const n = e.target, r = JSON.parse(e.data.toString());
      if (this._ws !== n) {
        E.info(
          "[socket][message]",
          n._id,
          r,
          "skip; this is no longer the current ws"
        );
        return;
      }
      this._handleReceive(n._id, JSON.parse(e.data.toString()));
    });
    p(this, "_wsOnError", (e) => {
      const n = e.target;
      if (this._ws !== n) {
        E.info(
          "[socket][error]",
          n._id,
          "skip; this is no longer the current ws"
        );
        return;
      }
      E.error("[socket][error]", n._id, e);
    });
    p(this, "_wsOnClose", (e) => {
      const n = e.target;
      if (this._ws !== n) {
        E.info(
          "[socket][close]",
          n._id,
          "skip; this is no longer the current ws"
        );
        return;
      }
      this._setStatus(Y.CLOSED);
      for (const r of Object.values(this._rooms))
        r.isConnected = !1;
      if (this._isShutdown) {
        E.info(
          "[socket][close]",
          n._id,
          "Reactor has been shut down and will not reconnect"
        );
        return;
      }
      E.info(
        "[socket][close]",
        n._id,
        "schedule reconnect, ms =",
        this._reconnectTimeoutMs
      ), setTimeout(() => {
        if (this._reconnectTimeoutMs = Math.min(
          this._reconnectTimeoutMs + 1e3,
          1e4
        ), !this._isOnline) {
          E.info(
            "[socket][close]",
            n._id,
            "we are offline, no need to start socket"
          );
          return;
        }
        this._startSocket();
      }, this._reconnectTimeoutMs);
    });
    this.config = { ...bs, ...e }, this.versions = { ...s || {}, "@instantdb/core": sn }, this.config.schema && (this._linkIndex = hs(this.config.schema)), gs() && (typeof BroadcastChannel == "function" && (this._broadcastChannel = new BroadcastChannel("@instantdb"), this._broadcastChannel.addEventListener("message", async (i) => {
      var o;
      if (((o = i.data) == null ? void 0 : o.type) === "auth") {
        const a = await this.getCurrentUser();
        this.updateUser(a.user);
      }
    })), this._oauthCallbackResponse = this._oauthLoginInit(), this._initStorage(n), this.getCurrentUser(), r.getIsOnline().then((i) => {
      this._isOnline = i, this._startSocket(), r.listen((o) => {
        o !== this._isOnline && (E.info("[network] online =", o), this._isOnline = o, this._isOnline && this._startSocket());
      });
    }), typeof addEventListener < "u" && (this._beforeUnload = this._beforeUnload.bind(this), addEventListener("beforeunload", this._beforeUnload)));
  }
  _initStorage(e) {
    this._persister = new e(`instant_${this.config.appId}_5`), this.querySubs = new Pt(
      this._persister,
      "querySubs",
      {},
      this._onMergeQuerySubs,
      Ss,
      ms
    ), this.pendingMutations = new Pt(
      this._persister,
      "pendingMutations",
      /* @__PURE__ */ new Map(),
      this._onMergePendingMutations,
      (n) => JSON.stringify([...n.entries()]),
      (n) => new Map(JSON.parse(n))
    ), this._beforeUnloadCbs.push(() => {
      this.pendingMutations.flush(), this.querySubs.flush();
    });
  }
  _beforeUnload() {
    for (const e of this._beforeUnloadCbs)
      e();
  }
  /**
   * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status
   * @param string clientId
   * @param {{message?: string, hint?: string, error?: Error}} [errDetails]
   */
  _finishTransaction(e, n, r) {
    const s = this.mutationDeferredStore.get(n);
    this.mutationDeferredStore.delete(n);
    const i = e !== "error" && e !== "timeout";
    !s && !i && console.error("Mutation failed", { status: e, clientId: n, ...r }), s && (i ? s.resolve({ status: e, clientId: n }) : s.reject({ status: e, clientId: n, ...r }));
  }
  _setStatus(e, n) {
    this.status = e, this._errorMessage = n, this.notifyConnectionStatusSubs(e);
  }
  _flushEnqueuedRoomData(e) {
    var s, i;
    const n = (i = (s = this._presence[e]) == null ? void 0 : s.result) == null ? void 0 : i.user, r = this._broadcastQueue[e];
    if (this._broadcastQueue[e] = [], n && this._trySetPresence(e, n), r)
      for (const o of r) {
        const { topic: a, roomType: c, data: u } = o;
        this._tryBroadcast(e, c, a, u);
      }
  }
  _handleReceive(e, n) {
    var s, i, o, a;
    const r = !!this.config.schema && ("cardinalityInference" in this.config ? !!this.config.cardinalityInference : !0);
    switch (jt[n.op] || E.info("[receive]", e, n.op, n), n.op) {
      case "init-ok":
        this._setStatus(Y.AUTHENTICATED), this._reconnectTimeoutMs = 0, this._setAttrs(n.attrs), this._flushPendingMessages(), this._sessionId = n["session-id"];
        for (const v of Object.keys(this._rooms))
          this._tryJoinRoom(v);
        break;
      case "add-query-exists":
        this.notifyOneQueryOnce(x(n.q));
        break;
      case "add-query-ok":
        const { q: c, result: u } = n, f = x(c), l = (i = (s = u == null ? void 0 : u[0]) == null ? void 0 : s.data) == null ? void 0 : i["page-info"], d = (a = (o = u == null ? void 0 : u[0]) == null ? void 0 : o.data) == null ? void 0 : a.aggregate, h = Rt(u), y = qe(
          this.attrs,
          h,
          r,
          this._linkIndex
        );
        this.querySubs.set((v) => (v[f].result = { store: y, pageInfo: l, aggregate: d }, v)), this.notifyOne(f), this.notifyOneQueryOnce(f);
        break;
      case "refresh-ok":
        const { computations: b, attrs: w } = n;
        this._setAttrs(w);
        const _ = b.map((v) => {
          var at, ct, ut, ft;
          const W = v["instaql-query"], D = v["instaql-result"], H = x(W), G = Rt(D), Ee = qe(
            this.attrs,
            G,
            r,
            this._linkIndex
          ), cn = (ct = (at = D == null ? void 0 : D[0]) == null ? void 0 : at.data) == null ? void 0 : ct["page-info"], un = (ft = (ut = D == null ? void 0 : D[0]) == null ? void 0 : ut.data) == null ? void 0 : ft.aggregate;
          return { hash: H, store: Ee, pageInfo: cn, aggregate: un };
        });
        _.forEach(({ hash: v, store: W, pageInfo: D, aggregate: H }) => {
          this.querySubs.set((G) => (G[v].result = { store: W, pageInfo: D, aggregate: H }, G));
        }), _.forEach(({ hash: v }) => {
          this.notifyOne(v);
        });
        break;
      case "transact-ok":
        const { "client-event-id": S, "tx-id": O } = n, g = this._rewriteMutations(
          this.attrs,
          this.pendingMutations.currentValue
        ).get(S);
        if (!g)
          break;
        this.pendingMutations.set((v) => (v.delete(S), v));
        const R = g["tx-steps"];
        this.querySubs.set((v) => {
          var W;
          for (const [D, H] of Object.entries(v)) {
            const G = (W = H == null ? void 0 : H.result) == null ? void 0 : W.store;
            if (!G)
              continue;
            const Ee = bt(G, R);
            v[D].result.store = Ee;
          }
          return v;
        });
        const L = g["tx-steps"].filter(([v, ...W]) => v === "add-attr").map(([v, W]) => W).concat(Object.values(this.attrs));
        this._setAttrs(L), this._finishTransaction("synced", S);
        break;
      case "refresh-presence":
        const K = n["room-id"];
        this._setPresencePeers(K, n.data), this._notifyPresenceSubs(K);
        break;
      case "server-broadcast":
        const Ce = n["room-id"], an = n.topic;
        this._notifyBroadcastSubs(Ce, an, n);
        break;
      case "join-room-ok":
        const ne = n["room-id"], st = this._rooms[ne];
        if (!st) {
          this._roomsPendingLeave[ne] && (this._tryLeaveRoom(ne), delete this._roomsPendingLeave[ne]);
          break;
        }
        st.isConnected = !0, this._notifyPresenceSubs(ne), this._flushEnqueuedRoomData(ne);
        break;
      case "join-room-error":
        const it = n["room-id"], ot = this._rooms[it];
        ot && (ot.error = n.error), this._notifyPresenceSubs(it);
        break;
      case "error":
        this._handleReceiveError(n);
        break;
    }
  }
  /**
   * @param {'timeout' | 'error'} status
   * @param {string} eventId
   * @param {{message?: string, hint?: string, error?: Error}} errDetails
   */
  _handleMutationError(e, n, r) {
    const s = this.pendingMutations.currentValue.get(n);
    s && (e !== "timeout" || !s["tx-id"]) && (this.pendingMutations.set((i) => (i.delete(n), i)), this.notifyAll(), this.notifyAttrsSubs(), this.notifyMutationErrorSubs(r), this._finishTransaction(e, n, r));
  }
  _handleReceiveError(e) {
    var c, u, f, l;
    const n = e["client-event-id"], r = this.pendingMutations.currentValue.get(n), s = {
      message: e.message || "Uh-oh, something went wrong. Ping Joe & Stopa."
    };
    if (e.hint && (s.hint = e.hint), r) {
      const d = {
        message: e.message,
        hint: e.hint
      };
      this._handleMutationError("error", n, d);
      return;
    }
    const i = (c = e["original-event"]) == null ? void 0 : c.q;
    if (i && ((u = e["original-event"]) == null ? void 0 : u.op) === "add-query") {
      const d = x(i);
      this.notifyQueryError(x(i), s), this.notifyQueryOnceError(i, d, n, s);
      return;
    }
    if (((f = e["original-event"]) == null ? void 0 : f.op) === "init") {
      if (e.type === "record-not-found" && ((l = e.hint) == null ? void 0 : l["record-type"]) === "app-user") {
        this.changeCurrentUser(null);
        return;
      }
      this._setStatus(Y.ERRORED, s), this.notifyAll();
      return;
    }
    const a = { ...e };
    delete a.message, delete a.hint, console.error(e.message, a), e.hint && console.error(
      `This error comes with some debugging information. Here it is: 
`,
      e.hint
    );
  }
  notifyQueryOnceError(e, n, r, s) {
    var o;
    const i = (o = this.queryOnceDfds[n]) == null ? void 0 : o.find((a) => a.eventId === r);
    i && (i.dfd.reject(s), this._completeQueryOnce(e, n, i.dfd));
  }
  _setAttrs(e) {
    this.attrs = e.reduce((n, r) => (n[r.id] = r, n), {}), this.notifyAttrsSubs();
  }
  _startQuerySub(e, n) {
    const r = C();
    return this.querySubs.set((s) => (s[n] = s[n] || { q: e, result: null, eventId: r }, s)), this._trySendAuthed(r, { op: "add-query", q: e }), r;
  }
  /**
   *  When a user subscribes to a query the following side effects occur:
   *
   *  - We update querySubs to include the new query
   *  - We update queryCbs to include the new cb
   *  - If we already have a result for the query we call cb immediately
   *  - We send the server an `add-query` message
   *
   *  Returns an unsubscribe function
   */
  subscribeQuery(e, n) {
    const r = x(e), s = this.getPreviousResult(e);
    return s && n(s), this.queryCbs[r] = this.queryCbs[r] ?? [], this.queryCbs[r].push({ q: e, cb: n }), this._startQuerySub(e, r), () => {
      this._unsubQuery(e, r, n);
    };
  }
  queryOnce(e) {
    const n = new Et();
    if (!this._isOnline)
      return n.reject(
        new Error("We can't run `queryOnce`, because the device is offline.")
      ), n.promise;
    if (!this.querySubs)
      return n.reject(
        new Error(
          "We can't run `queryOnce` on the backend. Use adminAPI.query instead: https://www.instantdb.com/docs/backend#query"
        )
      ), n.promise;
    const r = x(e), s = this._startQuerySub(e, r);
    return this.queryOnceDfds[r] = this.queryOnceDfds[r] ?? [], this.queryOnceDfds[r].push({ q: e, dfd: n, eventId: s }), setTimeout(
      () => n.reject(new Error("Query timed out")),
      ps
    ), n.promise;
  }
  _completeQueryOnce(e, n, r) {
    this.queryOnceDfds[n] && (this.queryOnceDfds[n] = this.queryOnceDfds[n].filter(
      (s) => s.dfd !== r
    ), this._cleanupQuery(e, n));
  }
  _unsubQuery(e, n, r) {
    this.queryCbs[n] && (this.queryCbs[n] = this.queryCbs[n].filter((s) => s.cb !== r), this._cleanupQuery(e, n));
  }
  _cleanupQuery(e, n) {
    var s, i;
    (s = this.queryCbs[n]) != null && s.length || (i = this.queryOnceDfds[n]) != null && i.length || (delete this.queryCbs[n], delete this.queryOnceDfds[n], this._trySendAuthed(C(), { op: "remove-query", q: e }));
  }
  // When we `pushTx`, it's possible that we don't yet have `this.attrs`
  // This means that `tx-steps` in `pendingMutations` will include `add-attr`
  // commands for attrs that already exist.
  //
  // This will also affect `add-triple` and `retract-triple` which
  // reference attr-ids that do not match the server.
  //
  // We fix this by rewriting `tx-steps` in each `pendingMutation`.
  // We remove `add-attr` commands for attrs that already exist.
  // We update `add-triple` and `retract-triple` commands to use the
  // server attr-ids.
  _rewriteMutations(e, n) {
    if (!e) return n;
    const r = (c) => {
      const [u, f, l] = c["forward-identity"];
      return j(e, f, l);
    }, s = (c) => {
      const [u, f, l] = c["forward-identity"];
      return Z(e, f, l);
    }, i = { attrIdMap: {}, refSwapAttrIds: /* @__PURE__ */ new Set() }, o = (c) => {
      const u = [];
      for (const f of c) {
        const [l] = f;
        if (l === "add-attr") {
          const [h, y] = f, b = r(y);
          if (b) {
            i.attrIdMap[y.id] = b.id;
            continue;
          }
          if (y["value-type"] === "ref") {
            const w = s(y);
            if (w) {
              i.attrIdMap[y.id] = w.id, i.refSwapAttrIds.add(y.id);
              continue;
            }
          }
        }
        const d = xr(i, f);
        u.push(d);
      }
      return u;
    }, a = /* @__PURE__ */ new Map();
    for (const [c, u] of n.entries())
      a.set(c, { ...u, "tx-steps": o(u["tx-steps"]) });
    return a;
  }
  // ---------------------------
  // Transact
  optimisticAttrs() {
    var o;
    const e = [
      ...this.pendingMutations.currentValue.values()
    ].flatMap((a) => a["tx-steps"]), n = new Set(
      e.filter(([a, c]) => a === "delete-attr").map(([a, c]) => c)
    ), r = [];
    for (const [a, c] of e)
      if (a === "add-attr")
        r.push(c);
      else if (a === "update-attr" && c.id && ((o = this.attrs) != null && o[c.id])) {
        const u = { ...this.attrs[c.id], ...c };
        r.push(u);
      }
    const s = [
      ...Object.values(this.attrs || {}),
      ...r
    ].filter((a) => !n.has(a.id));
    return Object.fromEntries(
      s.map((a) => [a.id, a])
    );
  }
  /** Runs instaql on a query and a store */
  dataForQuery(e) {
    const n = this._errorMessage;
    if (n)
      return { error: n };
    if (!this.querySubs || !this.pendingMutations) return;
    const r = this.querySubs.version(), s = this.querySubs.currentValue, i = this.pendingMutations.version(), o = this.pendingMutations.currentValue, { q: a, result: c } = s[e] || {};
    if (!c) return;
    const u = this._dataForQueryCache[e];
    if (u && r === u.querySubVersion && i === u.pendingMutationsVersion)
      return u.data;
    const { store: f, pageInfo: l, aggregate: d } = c, y = [...this._rewriteMutations(f.attrs, o).values()].flatMap((_) => _["tx-steps"]), b = bt(f, y), w = jr({ store: b, pageInfo: l, aggregate: d }, a);
    return this._dataForQueryCache[e] = {
      querySubVersion: r,
      pendingMutationsVersion: i,
      data: w
    }, w;
  }
  /** Re-compute all subscriptions */
  notifyAll() {
    Object.keys(this.queryCbs).forEach((e) => {
      this.notifyOne(e);
    });
  }
  loadedNotifyAll() {
    this.pendingMutations.isLoading() || this.querySubs.isLoading() || this.notifyAll();
  }
  shutdown() {
    this._isShutdown = !0, this._ws.close();
  }
  /**
   * Sends mutation to server and schedules a timeout to cancel it if
   * we don't hear back in time.
   * Note: If we're offline we don't schedule a timeout, we'll schedule it
   * later once we're back online and send the mutation again
   *
   */
  _sendMutation(e, n) {
    if (n.error) {
      this._handleMutationError("error", e, {
        error: n.error,
        message: n.error.message
      });
      return;
    }
    if (this.status !== Y.AUTHENTICATED) {
      this._finishTransaction("enqueued", e);
      return;
    }
    const r = Math.max(
      5e3,
      this.pendingMutations.currentValue.size * 5e3
    );
    this._isOnline ? (this._trySend(e, n), setTimeout(() => {
      this._finishTransaction("pending", e);
    }, 3e3), setTimeout(() => {
      this._isOnline && this._handleMutationError("timeout", e, {
        message: "transaction timed out"
      });
    }, r)) : this._finishTransaction("enqueued", e);
  }
  // ---------------------------
  // Websocket
  /** Send messages we accumulated while we were connecting */
  _flushPendingMessages() {
    Object.keys(this.queryCbs).map((s) => this.querySubs.currentValue[s]).filter((s) => s).forEach(({ eventId: s, q: i }) => {
      this._trySendAuthed(s, { op: "add-query", q: i });
    }), Object.values(this.queryOnceDfds).flat().forEach(({ eventId: s, q: i }) => {
      this._trySendAuthed(s, { op: "add-query", q: i });
    }), this._rewriteMutations(
      this.attrs,
      this.pendingMutations.currentValue
    ).forEach((s, i) => {
      s["tx-id"] || this._sendMutation(i, s);
    });
  }
  _trySendAuthed(...e) {
    this.status === Y.AUTHENTICATED && this._trySend(...e);
  }
  _trySend(e, n, r) {
    this._ws.readyState === kt && (jt[n.op] || E.info("[send]", this._ws._id, n.op, n), this._ws.send(JSON.stringify({ "client-event-id": e, ...n })));
  }
  _startSocket() {
    if (this._ws && this._ws.readyState == ys) {
      E.info(
        "[socket][start]",
        this._ws._id,
        "maintained as current ws, we were still in a connecting state"
      );
      return;
    }
    const e = this._ws;
    this._ws = ws(
      `${this.config.websocketURI}?app_id=${this.config.appId}`
    ), this._ws.onopen = this._wsOnOpen, this._ws.onmessage = this._wsOnMessage, this._ws.onclose = this._wsOnClose, this._ws.onerror = this._wsOnError, E.info("[socket][start]", this._ws._id), (e == null ? void 0 : e.readyState) === kt && (E.info(
      "[socket][start]",
      this._ws._id,
      "close previous ws id = ",
      e._id
    ), e.close());
  }
  /**
   * Given a key, returns a stable local id, unique to this device and app.
   *
   * This can be useful if you want to create guest ids for example.
   *
   * Note: If the user deletes their local storage, this id will change.
   *
   * We use this._localIdPromises to ensure that we only generate a local
   * id once, even if multiple callers call this function concurrently.
   */
  async getLocalId(e) {
    const n = `localToken_${e}`, r = await this._persister.getItem(n);
    if (r) return r;
    if (this._localIdPromises[n])
      return this._localIdPromises[n];
    const s = C();
    return this._localIdPromises[n] = this._persister.setItem(n, s).then(() => s), this._localIdPromises[n];
  }
  // ----
  // Auth
  _replaceUrlAfterOAuth() {
    if (typeof URL > "u")
      return;
    const e = new URL(window.location.href);
    if (e.searchParams.get(ke)) {
      const n = e.toString();
      e.searchParams.delete(ke), e.searchParams.delete("code"), e.searchParams.delete("error");
      const r = e.pathname + (e.searchParams.size ? "?" + e.searchParams : "") + e.hash;
      if (history.replaceState(history.state, "", r), // @ts-ignore (waiting for ts support)
      typeof navigation == "object" && // @ts-ignore (waiting for ts support)
      typeof navigation.addEventListener == "function" && // @ts-ignore (waiting for ts support)
      typeof navigation.removeEventListener == "function") {
        let s = !1;
        const i = (o) => {
          var a;
          s || (s = !0, navigation.removeEventListener("navigate", i), !o.userInitiated && o.navigationType === "replace" && ((a = o.destination) == null ? void 0 : a.url) === n && history.replaceState(history.state, "", r));
        };
        navigation.addEventListener("navigate", i);
      }
    }
  }
  /**
   *
   * @returns Promise<null | {error: {message: string}}>
   */
  async _oauthLoginInit() {
    var s, i, o, a;
    if (typeof window > "u" || typeof window.location > "u" || typeof URLSearchParams > "u")
      return null;
    const e = new URLSearchParams(window.location.search);
    if (!e.get(ke))
      return null;
    const n = e.get("error");
    if (n)
      return this._replaceUrlAfterOAuth(), { error: { message: n } };
    const r = e.get("code");
    if (!r)
      return null;
    this._replaceUrlAfterOAuth();
    try {
      const { user: c } = await At({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        code: r
      });
      return this.setCurrentUser(c), null;
    } catch (c) {
      return ((s = c == null ? void 0 : c.body) == null ? void 0 : s.type) === "record-not-found" && ((o = (i = c == null ? void 0 : c.body) == null ? void 0 : i.hint) == null ? void 0 : o["record-type"]) === "app-oauth-code" && await this._hasCurrentUser() ? null : { error: { message: ((a = c == null ? void 0 : c.body) == null ? void 0 : a.message) || "Error logging in." } };
    }
  }
  async _waitForOAuthCallbackResponse() {
    return await this._oauthCallbackResponse;
  }
  __subscribeMutationErrors(e) {
    return this.mutationErrorCbs.push(e), () => {
      this.mutationErrorCbs = this.mutationErrorCbs.filter((n) => n !== e);
    };
  }
  subscribeAuth(e) {
    this.authCbs.push(e);
    const n = this._currentUserCached;
    n.isLoading || e(this._currentUserCached);
    let r = !1;
    return this.getCurrentUser().then((s) => {
      r || _e(s, n) || e(s);
    }), () => {
      r = !0, this.authCbs = this.authCbs.filter((s) => s !== e);
    };
  }
  subscribeConnectionStatus(e) {
    return this.connectionStatusCbs.push(e), () => {
      this.connectionStatusCbs = this.connectionStatusCbs.filter(
        (n) => n !== e
      );
    };
  }
  subscribeAttrs(e) {
    return this.attrsCbs.push(e), this.attrs && e(this.attrs), () => {
      this.attrsCbs = this.attrsCbs.filter((n) => n !== e);
    };
  }
  notifyAuthSubs(e) {
    this.authCbs.forEach((n) => n(e));
  }
  notifyMutationErrorSubs(e) {
    this.mutationErrorCbs.forEach((n) => n(e));
  }
  notifyAttrsSubs() {
    if (!this.attrs) return;
    const e = this.optimisticAttrs();
    this.attrsCbs.forEach((n) => n(e));
  }
  notifyConnectionStatusSubs(e) {
    this.connectionStatusCbs.forEach((n) => n(e));
  }
  async setCurrentUser(e) {
    await this._persister.setItem(je, JSON.stringify(e));
  }
  getCurrentUserCached() {
    return this._currentUserCached;
  }
  async getCurrentUser() {
    const e = await this._waitForOAuthCallbackResponse();
    if (e != null && e.error) {
      const s = { error: e.error, user: void 0 };
      return this._currentUserCached = { isLoading: !1, ...s }, s;
    }
    const n = await this._persister.getItem(je), r = { user: JSON.parse(n), error: void 0 };
    return this._currentUserCached = {
      isLoading: !1,
      ...r
    }, r;
  }
  async _hasCurrentUser() {
    const e = await this._persister.getItem(je);
    return JSON.parse(e) != null;
  }
  async changeCurrentUser(e) {
    var r;
    const { user: n } = await this.getCurrentUser();
    if (!_e(n, e)) {
      await this.setCurrentUser(e), this.updateUser(e);
      try {
        (r = this._broadcastChannel) == null || r.postMessage({ type: "auth" });
      } catch (s) {
        console.error("Error posting message to broadcast channel", s);
      }
    }
  }
  updateUser(e) {
    const n = { error: void 0, user: e };
    this._currentUserCached = { isLoading: !1, ...n }, this._dataForQueryCache = {}, this.querySubs.set((r) => (Object.keys(r).forEach((s) => {
      delete r[s].result;
    }), r)), this._reconnectTimeoutMs = 0, this._ws.close(), this._oauthCallbackResponse = null, this.notifyAuthSubs(n);
  }
  sendMagicCode({ email: e }) {
    return ns({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email: e
    });
  }
  async signInWithMagicCode({ email: e, code: n }) {
    const r = await rs({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email: e,
      code: n
    });
    return await this.changeCurrentUser(r.user), r;
  }
  async signInWithCustomToken(e) {
    const n = await ss({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      refreshToken: e
    });
    return await this.changeCurrentUser(n.user), n;
  }
  async signOut() {
    var r;
    const e = await this.getCurrentUser(), n = (r = e == null ? void 0 : e.user) == null ? void 0 : r.refresh_token;
    if (n)
      try {
        await os({
          apiURI: this.config.apiURI,
          appId: this.config.appId,
          refreshToken: n
        });
      } catch {
      }
    await this.changeCurrentUser(null);
  }
  /**
   * Creates an OAuth authorization URL.
   * @param {Object} params - The parameters to create the authorization URL.
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.redirectURL - The URL to redirect users to after authorization.
   * @returns {string} The created authorization URL.
   */
  createAuthorizationURL({ clientName: e, redirectURL: n }) {
    const { apiURI: r, appId: s } = this.config;
    return `${r}/runtime/oauth/start?app_id=${s}&client_name=${e}&redirect_uri=${n}`;
  }
  async exchangeCodeForToken({ code: e, codeVerifier: n }) {
    const r = await At({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      code: e,
      codeVerifier: n
    });
    return await this.changeCurrentUser(r.user), r;
  }
  issuerURI() {
    const { apiURI: e, appId: n } = this.config;
    return `${e}/runtime/${n}`;
  }
  /**
   * @param {Object} params
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.idToken - The id_token from the external service
   * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service
   */
  async signInWithIdToken({ idToken: e, clientName: n, nonce: r }) {
    var a;
    const s = await this.getCurrentUser(), i = (a = s == null ? void 0 : s.user) == null ? void 0 : a.refresh_token, o = await is({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      idToken: e,
      clientName: n,
      nonce: r,
      refreshToken: i
    });
    return await this.changeCurrentUser(o.user), o;
  }
  // --------
  // Rooms
  joinRoom(e) {
    return this._rooms[e] || (this._rooms[e] = {
      isConnected: !1,
      error: void 0
    }), this._presence[e] = this._presence[e] || {}, this._tryJoinRoom(e), () => {
      this._cleanupRoom(e);
    };
  }
  _cleanupRoom(e) {
    var n, r, s;
    if (!((r = (n = this._presence[e]) == null ? void 0 : n.handlers) != null && r.length) && !Object.keys(this._broadcastSubs[e] ?? {}).length) {
      const i = (s = this._rooms[e]) == null ? void 0 : s.isConnected;
      delete this._rooms[e], delete this._presence[e], delete this._broadcastSubs[e], i ? this._tryLeaveRoom(e) : this._roomsPendingLeave[e] = !0;
    }
  }
  // --------
  // Presence
  // TODO: look into typing again
  getPresence(e, n, r = {}) {
    const s = this._rooms[n], i = this._presence[n];
    return !s || !i || !i.result ? null : {
      ...ls(i.result, r, this._sessionId),
      isLoading: !s.isConnected,
      error: s.error
    };
  }
  // TODO: look into typing again
  publishPresence(e, n, r) {
    const s = this._rooms[n], i = this._presence[n];
    if (!s || !i)
      return;
    i.result = i.result || {};
    const o = {
      ...i.result.user,
      ...r
    };
    i.result.user = o, s.isConnected && (this._trySetPresence(n, o), this._notifyPresenceSubs(n));
  }
  _trySetPresence(e, n) {
    this._trySendAuthed(C(), {
      op: "set-presence",
      "room-id": e,
      data: n
    });
  }
  _tryJoinRoom(e) {
    this._trySendAuthed(C(), { op: "join-room", "room-id": e }), delete this._roomsPendingLeave[e];
  }
  _tryLeaveRoom(e) {
    this._trySendAuthed(C(), { op: "leave-room", "room-id": e });
  }
  // TODO: look into typing again
  subscribePresence(e, n, r, s) {
    const i = this.joinRoom(n), o = { ...r, roomId: n, cb: s, prev: null };
    return this._presence[n] = this._presence[n] || {}, this._presence[n].handlers = this._presence[n].handlers || [], this._presence[n].handlers.push(o), this._notifyPresenceSub(n, o), () => {
      var a, c;
      this._presence[n].handlers = ((c = (a = this._presence[n]) == null ? void 0 : a.handlers) == null ? void 0 : c.filter((u) => u !== o)) ?? [], i();
    };
  }
  _notifyPresenceSubs(e) {
    var n, r;
    (r = (n = this._presence[e]) == null ? void 0 : n.handlers) == null || r.forEach((s) => {
      this._notifyPresenceSub(e, s);
    });
  }
  _notifyPresenceSub(e, n) {
    const r = this.getPresence("", e, n);
    r && (n.prev && !ds(r, n.prev) || (n.prev = r, n.cb(r)));
  }
  _setPresencePeers(e, n) {
    const r = { ...n };
    delete r[this._sessionId];
    const s = Object.fromEntries(
      Object.entries(r).map(([i, o]) => [i, o.data])
    );
    this._presence[e] = this._presence[e] || {}, this._presence[e].result = this._presence[e].result || {}, this._presence[e].result.peers = s;
  }
  // --------
  // Broadcast
  publishTopic({ roomType: e, roomId: n, topic: r, data: s }) {
    const i = this._rooms[n];
    if (i) {
      if (!i.isConnected) {
        this._broadcastQueue[n] = this._broadcastQueue[n] ?? [], this._broadcastQueue[n].push({ topic: r, roomType: e, data: s });
        return;
      }
      this._tryBroadcast(n, e, r, s);
    }
  }
  _tryBroadcast(e, n, r, s) {
    this._trySendAuthed(C(), {
      op: "client-broadcast",
      "room-id": e,
      roomType: n,
      topic: r,
      data: s
    });
  }
  subscribeTopic(e, n, r) {
    const s = this.joinRoom(e);
    return this._broadcastSubs[e] = this._broadcastSubs[e] || {}, this._broadcastSubs[e][n] = this._broadcastSubs[e][n] || [], this._broadcastSubs[e][n].push(r), this._presence[e] = this._presence[e] || {}, () => {
      this._broadcastSubs[e][n] = this._broadcastSubs[e][n].filter((i) => i !== r), this._broadcastSubs[e][n].length || delete this._broadcastSubs[e][n], s();
    };
  }
  _notifyBroadcastSubs(e, n, r) {
    var s, i, o;
    (o = (i = (s = this._broadcastSubs) == null ? void 0 : s[e]) == null ? void 0 : i[n]) == null || o.forEach((a) => {
      var f, l, d, h, y, b;
      const c = (f = r.data) == null ? void 0 : f.data, u = r.data["peer-id"] === this._sessionId ? (d = (l = this._presence[e]) == null ? void 0 : l.result) == null ? void 0 : d.user : (b = (y = (h = this._presence[e]) == null ? void 0 : h.result) == null ? void 0 : y.peers) == null ? void 0 : b[r.data["peer-id"]];
      return a(c, u);
    });
  }
  // --------
  // Storage
  async upload(e, n) {
    var c;
    const r = await this.getCurrentUser(), s = (c = r == null ? void 0 : r.user) == null ? void 0 : c.refresh_token, i = e || n.name, o = await as({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      fileName: i,
      refreshToken: s
    });
    return await cs(o, n);
  }
  async getDownloadUrl(e) {
    var i;
    const n = await this.getCurrentUser(), r = (i = n == null ? void 0 : n.user) == null ? void 0 : i.refresh_token;
    return await us({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path: e,
      refreshToken: r
    });
  }
  async deleteFile(e) {
    var i;
    const n = await this.getCurrentUser(), r = (i = n == null ? void 0 : n.user) == null ? void 0 : i.refresh_token;
    return await fs({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      path: e,
      refreshToken: r
    });
  }
}
class F {
  constructor(e, n, r = { indexed: !1, unique: !1 }) {
    this.valueType = e, this.required = n, this.config = r;
  }
  optional() {
    return new F(this.valueType, !1);
  }
  unique() {
    return new F(
      this.valueType,
      this.required,
      {
        ...this.config,
        unique: !0
      }
    );
  }
  indexed() {
    return new F(
      this.valueType,
      this.required,
      {
        ...this.config,
        indexed: !0
      }
    );
  }
  // clientValidate(clientValidator: (value: ValueType) => boolean) {
  //   return new DataAttrDef(this.valueType, this.required, {
  //     ...this.config,
  //     clientValidator,
  //   });
  // }
}
class Me {
  constructor(e, n) {
    this.attrs = e, this.links = n;
  }
  asType() {
    return new Me(this.attrs, this.links);
  }
}
class Ae {
  constructor(e, n, r) {
    this.entities = e, this.links = n, this.rooms = r;
  }
  /**
   * @deprecated
   * `withRoomSchema` is deprecated. Define your schema in `rooms` directly:
   *
   * @example
   * // Before:
   * const schema = i.schema({
   *   // ...
   * }).withRoomSchema<RoomSchema>()
   *
   * // After
   * const schema = i.schema({
   *  rooms: {
   *    // ...
   *  }
   * })
   *
   * @see https://instantdb.com/docs/presence-and-topics#typesafety
   */
  withRoomSchema() {
    return new Ae(
      this.entities,
      this.links,
      {}
    );
  }
}
function vs(t, e) {
  return new Ae(
    on(t, e),
    // (XXX): LinksDef<any> stems from TypeScripts inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    e,
    void 0
  );
}
function Ms(t) {
  return new Me(t, {});
}
function As() {
  return new F("string", !0);
}
function Cs() {
  return new F("number", !0);
}
function Es() {
  return new F("boolean", !0);
}
function Ps() {
  return new F("date", !0);
}
function Rs() {
  return new F("json", !0);
}
function ks() {
  return new F("json", !0);
}
function on(t, e) {
  var s, i, o, a;
  const n = { fwd: {}, rev: {} };
  for (const c of Object.values(e))
    (s = n.fwd)[i = c.forward.on] || (s[i] = {}), (o = n.rev)[a = c.reverse.on] || (o[a] = {}), n.fwd[c.forward.on][c.forward.label] = {
      entityName: c.reverse.on,
      cardinality: c.forward.has
    }, n.rev[c.reverse.on][c.reverse.label] = {
      entityName: c.forward.on,
      cardinality: c.reverse.has
    };
  return Object.fromEntries(
    Object.entries(t).map(([c, u]) => [
      c,
      new Me(u.attrs, {
        ...n.fwd[c],
        ...n.rev[c]
      })
    ])
  );
}
function js({
  entities: t,
  links: e,
  rooms: n
}) {
  const r = e ?? {}, s = n ?? {};
  return new Ae(
    on(t, r),
    // (XXX): LinksDef<any> stems from TypeScripts inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    r,
    s
  );
}
const Bs = {
  // constructs
  graph: vs,
  schema: js,
  entity: Ms,
  // value types
  string: As,
  number: Cs,
  boolean: Es,
  date: Ps,
  json: Rs,
  any: ks
};
let de;
function Ts(t) {
  de == null || de.dispose();
  const e = $s(), n = Us(o), r = xs(Is(t));
  function s(u) {
    var f;
    u.source === r.element.contentWindow && ((f = u.data) == null ? void 0 : f.type) === "close" && e.isVisible() && o();
  }
  function i(u) {
    const f = u.shiftKey && u.ctrlKey && u.key === "0", l = u.key === "Escape" || u.key === "Esc";
    (f || l && e.isVisible()) && o();
  }
  function o() {
    e.isVisible() ? e.element.style.display = "none" : (e.element.style.display = "block", e.element.contains(r.element) || e.element.appendChild(r.element));
  }
  function a() {
    e.element.remove(), n.element.remove(), removeEventListener("keydown", i), removeEventListener("message", s);
  }
  function c() {
    document.body.appendChild(e.element), document.body.appendChild(n.element), addEventListener("keydown", i), addEventListener("message", s), de = {
      dispose: a
    };
  }
  return c();
}
function Is(t) {
  return `${window.DEV_DEVTOOL ? "http://localhost:3000" : "https://instantdb.com"}/_devtool?appId=${t}`;
}
function xs(t) {
  const e = document.createElement("iframe");
  return e.src = t, e.className = "instant-devtool-iframe", Object.assign(e.style, {
    width: "100%",
    height: "100%",
    borderRadius: "4px",
    backgroundColor: "white",
    border: "none"
  }), { element: e };
}
function Us(t) {
  const e = `
    <svg width="32" height="32" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect width="512" height="512" fill="black"/>
      <rect x="97.0973" y="91.3297" width="140" height="330" fill="white"/>
    </svg>
  `, n = document.createElement("button");
  return n.innerHTML = e, n.className = "instant-devtool-toggler", Object.assign(n.style, {
    // pos
    position: "fixed",
    bottom: "24px",
    left: "24px",
    height: "32px",
    width: "32px",
    // layout
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    // look
    padding: "0",
    margin: "0",
    border: "none",
    cursor: "pointer"
  }), n.addEventListener("click", t), { element: n };
}
function $s() {
  const t = document.createElement("div");
  Object.assign(t.style, {
    position: "fixed",
    bottom: "24px",
    right: "24px",
    left: "60px",
    top: "72px",
    display: "block",
    borderRadius: "4px",
    border: "1px #ccc solid",
    boxShadow: "0px 0px 8px #00000044",
    backgroundColor: "#eee",
    zIndex: "999990"
  }), t.style.display = "none", t.className = "instant-devtool-container";
  function e() {
    return t.style.display !== "none";
  }
  return { element: t, isVisible: e };
}
const Ds = !0, qs = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
};
function Ns() {
  return globalThis.__instantDbStore = globalThis.__instantDbStore ?? {}, globalThis.__instantDbStore;
}
const Ke = Ns();
class Ls {
  constructor(e) {
    this.db = e, this.sendMagicCode = (n) => this.db.sendMagicCode(n), this.signInWithMagicCode = (n) => this.db.signInWithMagicCode(n), this.signInWithToken = (n) => this.db.signInWithCustomToken(n), this.createAuthorizationURL = (n) => this.db.createAuthorizationURL(n), this.signInWithIdToken = (n) => this.db.signInWithIdToken(n), this.exchangeOAuthCode = (n) => this.db.exchangeCodeForToken(n), this.issuerURI = () => this.db.issuerURI(), this.signOut = () => this.db.signOut();
  }
}
class zs {
  constructor(e) {
    this.db = e, this.upload = (n, r) => this.db.upload(n, r), this.put = this.upload, this.getDownloadUrl = (n) => this.db.getDownloadUrl(n), this.delete = (n) => this.db.deleteFile(n);
  }
}
function Ks(t) {
  return JSON.parse(JSON.stringify(t));
}
class Fs {
  constructor(e) {
    this.tx = en(), this._reactor = e, this.auth = new Ls(this._reactor), this.storage = new zs(this._reactor);
  }
  /**
   * Use this to write data! You can create, update, delete, and link objects
   *
   * @see https://instantdb.com/docs/instaml
   *
   * @example
   *   // Create a new object in the `goals` namespace
   *   const goalId = id();
   *   db.transact(tx.goals[goalId].update({title: "Get fit"}))
   *
   *   // Update the title
   *   db.transact(tx.goals[goalId].update({title: "Get super fit"}))
   *
   *   // Delete it
   *   db.transact(tx.goals[goalId].delete())
   *
   *   // Or create an association:
   *   todoId = id();
   *   db.transact([
   *    tx.todos[todoId].update({ title: 'Go on a run' }),
   *    tx.goals[goalId].link({todos: todoId}),
   *  ])
   */
  transact(e) {
    return this._reactor.pushTx(e);
  }
  getLocalId(e) {
    return this._reactor.getLocalId(e);
  }
  /**
   * Use this to query your data!
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  // listen to all goals
   *  db.subscribeQuery({ goals: {} }, (resp) => {
   *    console.log(resp.data.goals)
   *  })
   *
   *  // goals where the title is "Get Fit"
   *  db.subscribeQuery(
   *    { goals: { $: { where: { title: "Get Fit" } } } },
   *    (resp) => {
   *      console.log(resp.data.goals)
   *    }
   *  )
   *
   *  // all goals, _alongside_ their todos
   *  db.subscribeQuery({ goals: { todos: {} } }, (resp) => {
   *    console.log(resp.data.goals)
   *  });
   */
  subscribeQuery(e, n) {
    return this._reactor.subscribeQuery(e, n);
  }
  /**
   * Listen for the logged in state. This is useful
   * for deciding when to show a login screen.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const unsub = db.subscribeAuth((auth) => {
   *     if (auth.user) {
   *     console.log('logged in as', auth.user.email)
   *    } else {
   *      console.log('logged out')
   *    }
   *  })
   */
  subscribeAuth(e) {
    return this._reactor.subscribeAuth(e);
  }
  /**
   * Listen for connection status changes to Instant. This is useful
   * for building things like connectivity indicators
   *
   * @see https://www.instantdb.com/docs/patterns#connection-status
   * @example
   *   const unsub = db.subscribeConnectionStatus((status) => {
   *     const connectionState =
   *       status === 'connecting' || status === 'opened'
   *         ? 'authenticating'
   *       : status === 'authenticated'
   *         ? 'connected'
   *       : status === 'closed'
   *         ? 'closed'
   *       : status === 'errored'
   *         ? 'errored'
   *       : 'unexpected state';
   *
   *     console.log('Connection status:', connectionState);
   *   });
   */
  subscribeConnectionStatus(e) {
    return this._reactor.subscribeConnectionStatus(e);
  }
  /**
   * Join a room to publish and subscribe to topics and presence.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   * @example
   * // init
   * const db = init();
   * const room = db.joinRoom(roomType, roomId);
   * // usage
   * const unsubscribeTopic = room.subscribeTopic("foo", console.log);
   * const unsubscribePresence = room.subscribePresence({}, console.log);
   * room.publishTopic("hello", { message: "hello world!" });
   * room.publishPresence({ name: "joe" });
   * // later
   * unsubscribePresence();
   * unsubscribeTopic();
   * room.leaveRoom();
   */
  joinRoom(e = "_defaultRoomType", n = "_defaultRoomId") {
    return {
      leaveRoom: this._reactor.joinRoom(n),
      subscribeTopic: (s, i) => this._reactor.subscribeTopic(n, s, i),
      subscribePresence: (s, i) => this._reactor.subscribePresence(e, n, s, i),
      publishTopic: (s, i) => this._reactor.publishTopic({ roomType: e, roomId: n, topic: s, data: i }),
      publishPresence: (s) => this._reactor.publishPresence(e, n, s),
      getPresence: (s) => this._reactor.getPresence(e, n, s)
    };
  }
  shutdown() {
    delete Ke[this._reactor.config.appId], this._reactor.shutdown();
  }
  /**
   * Use this for one-off queries.
   * Returns local data if available, otherwise fetches from the server.
   * Because we want to avoid stale data, this method will throw an error
   * if the user is offline or there is no active connection to the server.
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *
   *  const resp = await db.queryOnce({ goals: {} });
   *  console.log(resp.data.goals)
   */
  queryOnce(e) {
    return this._reactor.queryOnce(e);
  }
}
function Vs(t, e, n, r) {
  const s = Ke[t.appId];
  if (s)
    return s;
  const i = new Os(
    {
      ...qs,
      ...t,
      cardinalityInference: !!t.schema
    },
    e || tn,
    n || nn,
    { ...r || {}, "@instantdb/core": sn }
  ), o = new Fs(i);
  return Ke[t.appId] = o, typeof window < "u" && typeof window.location < "u" && // show widget by default?
  ("devtool" in t ? t.devtool : Ds) && // only run on localhost (dev env)
  window.location.hostname === "localhost" && // used by dash and other internal consumers
  !globalThis._nodevtool && Ts(t.appId), o;
}
const Hs = Vs;
export {
  Ls as Auth,
  tn as IndexedDBStorage,
  Fs as InstantCoreDatabase,
  zs as Storage,
  nn as WindowNetworkListener,
  Ks as coerceQuery,
  Ir as getOps,
  Bs as i,
  C as id,
  Vs as init,
  Hs as init_experimental,
  Qs as lookup,
  Js as tx,
  en as txInit,
  sn as version,
  x as weakHash
};
