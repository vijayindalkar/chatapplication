import Wn, { useRef as nt, useCallback as rt, useSyncExternalStore as Pt, useEffect as Se, useState as zr, useMemo as Wr, createElement as Vr } from "react";
let Ge = !1;
typeof window < "u" && typeof window.localStorage < "u" && (Ge = !!window.localStorage.getItem("devBackend") || !!window.localStorage.getItem("__instantLogging"));
const F = {
  info: Ge ? console.info.bind(console) : () => {
  },
  debug: Ge ? console.debug.bind(console) : () => {
  },
  error: Ge ? console.error.bind(console) : () => {
  }
};
function Y(t) {
  if (typeof t == "number")
    return (Math.abs(t * 2654435761) >>> 0).toString(16);
  if (typeof t == "boolean")
    return t ? "1" : "0";
  if (t === null)
    return "null";
  if (t === void 0)
    return "undefined";
  if (typeof t == "string") {
    let e = 2166136261;
    for (let n = 0; n < t.length; n++)
      e ^= t.charCodeAt(n), e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24), e = e >>> 0;
    return e.toString(16);
  }
  if (Array.isArray(t)) {
    let e = 2166136261;
    for (let n = 0; n < t.length; n++) {
      e ^= (n + 1) * 2654435761;
      const r = Y(t[n]);
      for (let i = 0; i < r.length; i++)
        e ^= r.charCodeAt(i), e *= 16777619, e = e >>> 0;
    }
    return e.toString(16);
  }
  if (typeof t == "object") {
    let e = 2166136261;
    const n = Object.keys(t).sort();
    for (let r = 0; r < n.length; r++) {
      const i = n[r], s = Y(i);
      e ^= parseInt(s, 16), e *= 16777619, e = e >>> 0;
      const o = Y(t[i]);
      e ^= parseInt(o, 16), e *= 16777619, e = e >>> 0;
    }
    return e.toString(16);
  }
  return Y(String(t));
}
const k = {
  Remove: "remove",
  Replace: "replace",
  Add: "add"
}, Vn = Symbol.for("__MUTATIVE_PROXY_DRAFT__"), Br = Symbol("__MUTATIVE_RAW_RETURN_SYMBOL__"), Xe = Symbol.iterator, G = {
  mutable: "mutable",
  immutable: "immutable"
}, Qt = {};
function H(t) {
  var e;
  return (e = t.copy) !== null && e !== void 0 ? e : t.original;
}
function be(t) {
  return !!j(t);
}
function j(t) {
  return typeof t != "object" ? null : t == null ? void 0 : t[Vn];
}
function Kt(t) {
  var e;
  const n = j(t);
  return n ? (e = n.copy) !== null && e !== void 0 ? e : n.original : t;
}
function ie(t, e) {
  if (!t || typeof t != "object")
    return !1;
  let n;
  return Object.getPrototypeOf(t) === Object.prototype || Array.isArray(t) || t instanceof Map || t instanceof Set || !!(e != null && e.mark) && ((n = e.mark(t, G)) === G.immutable || typeof n == "function");
}
function Bn(t, e = []) {
  if (Object.hasOwnProperty.call(t, "key")) {
    const n = j(de(t.parent.copy, t.key));
    if (n !== null && (n == null ? void 0 : n.original) !== t.original)
      return null;
    e.push(t.parent.type === 3 ? Array.from(t.parent.setMap.keys()).indexOf(t.key) : t.key);
  }
  if (t.parent)
    return Bn(t.parent, e);
  e.reverse();
  try {
    Jr(t.copy, e);
  } catch {
    return null;
  }
  return e;
}
function ge(t) {
  return Array.isArray(t) ? 1 : t instanceof Map ? 2 : t instanceof Set ? 3 : 0;
}
function de(t, e) {
  return ge(t) === 2 ? t.get(e) : t[e];
}
function De(t, e, n) {
  ge(t) === 2 ? t.set(e, n) : t[e] = n;
}
function Et(t, e) {
  const n = j(t);
  return (n ? H(n) : t)[e];
}
function le(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function Tt(t) {
  if (t)
    for (; t.finalities.revoke.length > 0; )
      t.finalities.revoke.pop()();
}
function _e(t, e) {
  return e ? t : [""].concat(t).map((n) => {
    const r = `${n}`;
    return r.indexOf("/") === -1 && r.indexOf("~") === -1 ? r : r.replace(/~/g, "~0").replace(/\//g, "~1");
  }).join("/");
}
function Jr(t, e) {
  for (let n = 0; n < e.length - 1; n += 1) {
    const r = e[n];
    if (t = de(ge(t) === 3 ? Array.from(t) : t, r), typeof t != "object")
      throw new Error(`Cannot resolve patch at '${e.join("/")}'.`);
  }
  return t;
}
function Qr(t) {
  const e = Object.create(Object.getPrototypeOf(t));
  return Reflect.ownKeys(t).forEach((n) => {
    let r = Reflect.getOwnPropertyDescriptor(t, n);
    if (r.enumerable && r.configurable && r.writable) {
      e[n] = t[n];
      return;
    }
    r.writable || (r.writable = !0, r.configurable = !0), (r.get || r.set) && (r = {
      configurable: !0,
      writable: !0,
      enumerable: r.enumerable,
      value: t[n]
    }), Reflect.defineProperty(e, n, r);
  }), e;
}
const Kr = Object.prototype.propertyIsEnumerable;
function Jn(t, e) {
  let n;
  if (Array.isArray(t))
    return Array.prototype.concat.call(t);
  if (t instanceof Set)
    return new Set(t.values());
  if (t instanceof Map)
    return new Map(t);
  if (e != null && e.mark && (n = e.mark(t, G), n !== void 0) && n !== G.mutable) {
    if (n === G.immutable)
      return Qr(t);
    if (typeof n == "function") {
      if (e.enablePatches || e.enableAutoFreeze)
        throw new Error("You can't use mark and patches or auto freeze together.");
      return n();
    }
    throw new Error(`Unsupported mark result: ${n}`);
  } else if (typeof t == "object" && Object.getPrototypeOf(t) === Object.prototype) {
    const r = {};
    return Object.keys(t).forEach((i) => {
      r[i] = t[i];
    }), Object.getOwnPropertySymbols(t).forEach((i) => {
      Kr.call(t, i) && (r[i] = t[i]);
    }), r;
  } else
    throw new Error("Please check mark() to ensure that it is a stable marker draftable function.");
}
function z(t) {
  t.copy || (t.copy = Jn(t.original, t.options));
}
function ke(t) {
  if (!ie(t))
    return Kt(t);
  if (Array.isArray(t))
    return t.map(ke);
  if (t instanceof Map)
    return new Map(Array.from(t.entries()).map(([n, r]) => [n, ke(r)]));
  if (t instanceof Set)
    return new Set(Array.from(t).map(ke));
  const e = Object.create(Object.getPrototypeOf(t));
  for (const n in t)
    e[n] = ke(t[n]);
  return e;
}
function Ze(t) {
  return be(t) ? ke(t) : t;
}
function ue(t) {
  var e;
  t.assignedMap = (e = t.assignedMap) !== null && e !== void 0 ? e : /* @__PURE__ */ new Map(), t.operated || (t.operated = !0, t.parent && ue(t.parent));
}
function bn() {
  throw new Error("Cannot modify frozen object");
}
function Ee(t, e, n, r, i) {
  {
    n = n ?? /* @__PURE__ */ new WeakMap(), r = r ?? [], i = i ?? [];
    const o = n.has(t) ? n.get(t) : t;
    if (r.length > 0) {
      const a = r.indexOf(o);
      if (o && typeof o == "object" && a !== -1)
        throw r[0] === o ? new Error("Forbids circular reference") : new Error(`Forbids circular reference: ~/${i.slice(0, a).map((u, c) => {
          if (typeof u == "symbol")
            return `[${u.toString()}]`;
          const l = r[c];
          return typeof u == "object" && (l instanceof Map || l instanceof Set) ? Array.from(l.keys()).indexOf(u) : u;
        }).join("/")}`);
      r.push(o), i.push(e);
    } else
      r.push(o);
  }
  if (Object.isFrozen(t) || be(t)) {
    r.pop(), i.pop();
    return;
  }
  switch (ge(t)) {
    case 2:
      for (const [a, u] of t)
        Ee(a, a, n, r, i), Ee(u, a, n, r, i);
      t.set = t.clear = t.delete = bn;
      break;
    case 3:
      for (const a of t)
        Ee(a, a, n, r, i);
      t.add = t.clear = t.delete = bn;
      break;
    case 1:
      Object.freeze(t);
      let o = 0;
      for (const a of t)
        Ee(a, o, n, r, i), o += 1;
      break;
    default:
      Object.freeze(t), Object.keys(t).forEach((a) => {
        const u = t[a];
        Ee(u, a, n, r, i);
      });
  }
  r.pop(), i.pop();
}
function et(t, e) {
  return t instanceof Map ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function gn(t, e) {
  if (e in t) {
    let n = Reflect.getPrototypeOf(t);
    for (; n; ) {
      const r = Reflect.getOwnPropertyDescriptor(n, e);
      if (r)
        return r;
      n = Reflect.getPrototypeOf(n);
    }
  }
}
function Yt(t, e) {
  const n = ge(t);
  if (n === 0)
    Reflect.ownKeys(t).forEach((r) => {
      e(r, t[r], t);
    });
  else if (n === 1) {
    let r = 0;
    for (const i of t)
      e(r, i, t), r += 1;
  } else
    t.forEach((r, i) => e(i, r, t));
}
function Qn(t, e, n) {
  if (be(t) || !ie(t, n) || e.has(t) || Object.isFrozen(t))
    return;
  const r = t instanceof Set, i = r ? /* @__PURE__ */ new Map() : void 0;
  if (e.add(t), Yt(t, (s, o) => {
    var a;
    if (be(o)) {
      const u = j(o);
      z(u);
      const c = !((a = u.assignedMap) === null || a === void 0) && a.size || u.operated ? u.copy : u.original;
      De(r ? i : t, s, c);
    } else
      Qn(o, e, n);
  }), i) {
    const s = t, o = Array.from(s);
    s.clear(), o.forEach((a) => {
      s.add(i.has(a) ? i.get(a) : a);
    });
  }
}
function Yr(t, e) {
  const n = t.type === 3 ? t.setMap : t.copy;
  t.finalities.revoke.length > 1 && t.assignedMap.get(e) && n && Qn(de(n, e), t.finalities.handledSet, t.options);
}
function xt(t) {
  t.type === 3 && t.copy && (t.copy.clear(), t.setMap.forEach((e) => {
    t.copy.add(Kt(e));
  }));
}
function At(t, e, n, r) {
  if (t.operated && t.assignedMap && t.assignedMap.size > 0 && !t.finalized) {
    if (n && r) {
      const s = Bn(t);
      s && e(t, s, n, r);
    }
    t.finalized = !0;
  }
}
function Ht(t, e, n, r) {
  const i = j(n);
  i && (i.callbacks || (i.callbacks = []), i.callbacks.push((s, o) => {
    var a;
    const u = t.type === 3 ? t.setMap : t.copy;
    if (le(de(u, e), n)) {
      let c = i.original;
      i.copy && (c = i.copy), xt(t), At(t, r, s, o), t.options.enableAutoFreeze && (t.options.updatedValues = (a = t.options.updatedValues) !== null && a !== void 0 ? a : /* @__PURE__ */ new WeakMap(), t.options.updatedValues.set(c, i.original)), De(u, e, c);
    }
  }), t.options.enableAutoFreeze && i.finalities !== t.finalities && (t.options.enableAutoFreeze = !1)), ie(n, t.options) && t.finalities.draft.push(() => {
    const s = t.type === 3 ? t.setMap : t.copy;
    le(de(s, e), n) && Yr(t, e);
  });
}
function Hr(t, e, n, r, i) {
  let { original: s, assignedMap: o, options: a } = t, u = t.copy;
  u.length < s.length && ([s, u] = [u, s], [n, r] = [r, n]);
  for (let c = 0; c < s.length; c += 1)
    if (o.get(c.toString()) && u[c] !== s[c]) {
      const l = e.concat([c]), f = _e(l, i);
      n.push({
        op: k.Replace,
        path: f,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: Ze(u[c])
      }), r.push({
        op: k.Replace,
        path: f,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: Ze(s[c])
      });
    }
  for (let c = s.length; c < u.length; c += 1) {
    const l = e.concat([c]), f = _e(l, i);
    n.push({
      op: k.Add,
      path: f,
      // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
      value: Ze(u[c])
    });
  }
  if (s.length < u.length) {
    const { arrayLengthAssignment: c = !0 } = a.enablePatches;
    if (c) {
      const l = e.concat(["length"]), f = _e(l, i);
      r.push({
        op: k.Replace,
        path: f,
        value: s.length
      });
    } else
      for (let l = u.length; s.length < l; l -= 1) {
        const f = e.concat([l - 1]), h = _e(f, i);
        r.push({
          op: k.Remove,
          path: h
        });
      }
  }
}
function Gr({ original: t, copy: e, assignedMap: n }, r, i, s, o) {
  n.forEach((a, u) => {
    const c = de(t, u), l = Ze(de(e, u)), f = a ? et(t, u) ? k.Replace : k.Add : k.Remove;
    if (le(c, l) && f === k.Replace)
      return;
    const h = r.concat(u), v = _e(h, o);
    i.push(f === k.Remove ? { op: f, path: v } : { op: f, path: v, value: l }), s.push(f === k.Add ? { op: k.Remove, path: v } : f === k.Remove ? { op: k.Add, path: v, value: c } : { op: k.Replace, path: v, value: c });
  });
}
function Xr({ original: t, copy: e }, n, r, i, s) {
  let o = 0;
  t.forEach((a) => {
    if (!e.has(a)) {
      const u = n.concat([o]), c = _e(u, s);
      r.push({
        op: k.Remove,
        path: c,
        value: a
      }), i.unshift({
        op: k.Add,
        path: c,
        value: a
      });
    }
    o += 1;
  }), o = 0, e.forEach((a) => {
    if (!t.has(a)) {
      const u = n.concat([o]), c = _e(u, s);
      r.push({
        op: k.Add,
        path: c,
        value: a
      }), i.unshift({
        op: k.Remove,
        path: c,
        value: a
      });
    }
    o += 1;
  });
}
function $e(t, e, n, r) {
  const { pathAsArray: i = !0 } = t.options.enablePatches;
  switch (t.type) {
    case 0:
    case 2:
      return Gr(t, e, n, r, i);
    case 1:
      return Hr(t, e, n, r, i);
    case 3:
      return Xr(t, e, n, r, i);
  }
}
let Zr = !1;
const it = (t, e, n = !1) => {
  if (typeof t == "object" && t !== null && (!ie(t, e) || n) && !Zr)
    throw new Error("Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.");
}, Mt = {
  get size() {
    return H(j(this)).size;
  },
  has(t) {
    return H(j(this)).has(t);
  },
  set(t, e) {
    const n = j(this), r = H(n);
    return (!r.has(t) || !le(r.get(t), e)) && (z(n), ue(n), n.assignedMap.set(t, !0), n.copy.set(t, e), Ht(n, t, e, $e)), this;
  },
  delete(t) {
    if (!this.has(t))
      return !1;
    const e = j(this);
    return z(e), ue(e), e.original.has(t) ? e.assignedMap.set(t, !1) : e.assignedMap.delete(t), e.copy.delete(t), !0;
  },
  clear() {
    const t = j(this);
    if (this.size) {
      z(t), ue(t), t.assignedMap = /* @__PURE__ */ new Map();
      for (const [e] of t.original)
        t.assignedMap.set(e, !1);
      t.copy.clear();
    }
  },
  forEach(t, e) {
    const n = j(this);
    H(n).forEach((r, i) => {
      t.call(e, this.get(i), i, this);
    });
  },
  get(t) {
    var e, n;
    const r = j(this), i = H(r).get(t), s = ((n = (e = r.options).mark) === null || n === void 0 ? void 0 : n.call(e, i, G)) === G.mutable;
    if (r.options.strict && it(i, r.options, s), s || r.finalized || !ie(i, r.options) || i !== r.original.get(t))
      return i;
    const o = Qt.createDraft({
      original: i,
      parentDraft: r,
      key: t,
      finalities: r.finalities,
      options: r.options
    });
    return z(r), r.copy.set(t, o), o;
  },
  keys() {
    return H(j(this)).keys();
  },
  values() {
    const t = this.keys();
    return {
      [Xe]: () => this.values(),
      next: () => {
        const e = t.next();
        return e.done ? e : {
          done: !1,
          value: this.get(e.value)
        };
      }
    };
  },
  entries() {
    const t = this.keys();
    return {
      [Xe]: () => this.entries(),
      next: () => {
        const e = t.next();
        if (e.done)
          return e;
        const n = this.get(e.value);
        return {
          done: !1,
          value: [e.value, n]
        };
      }
    };
  },
  [Xe]() {
    return this.entries();
  }
}, ei = Reflect.ownKeys(Mt), wn = (t, e, { isValuesIterator: n }) => () => {
  var r, i;
  const s = e.next();
  if (s.done)
    return s;
  const o = s.value;
  let a = t.setMap.get(o);
  const u = j(a), c = ((i = (r = t.options).mark) === null || i === void 0 ? void 0 : i.call(r, a, G)) === G.mutable;
  if (t.options.strict && it(o, t.options, c), !c && !u && ie(o, t.options) && !t.finalized && t.original.has(o)) {
    const l = Qt.createDraft({
      original: o,
      parentDraft: t,
      key: o,
      finalities: t.finalities,
      options: t.options
    });
    t.setMap.set(o, l), a = l;
  } else u && (a = u.proxy);
  return {
    done: !1,
    value: n ? a : [a, a]
  };
}, kt = {
  get size() {
    return j(this).setMap.size;
  },
  has(t) {
    const e = j(this);
    if (e.setMap.has(t))
      return !0;
    z(e);
    const n = j(t);
    return !!(n && e.setMap.has(n.original));
  },
  add(t) {
    const e = j(this);
    return this.has(t) || (z(e), ue(e), e.assignedMap.set(t, !0), e.setMap.set(t, t), Ht(e, t, t, $e)), this;
  },
  delete(t) {
    if (!this.has(t))
      return !1;
    const e = j(this);
    z(e), ue(e);
    const n = j(t);
    return n && e.setMap.has(n.original) ? (e.assignedMap.set(n.original, !1), e.setMap.delete(n.original)) : (!n && e.setMap.has(t) ? e.assignedMap.set(t, !1) : e.assignedMap.delete(t), e.setMap.delete(t));
  },
  clear() {
    if (!this.size)
      return;
    const t = j(this);
    z(t), ue(t);
    for (const e of t.original)
      t.assignedMap.set(e, !1);
    t.setMap.clear();
  },
  values() {
    const t = j(this);
    z(t);
    const e = t.setMap.keys();
    return {
      [Symbol.iterator]: () => this.values(),
      next: wn(t, e, { isValuesIterator: !0 })
    };
  },
  entries() {
    const t = j(this);
    z(t);
    const e = t.setMap.keys();
    return {
      [Symbol.iterator]: () => this.entries(),
      next: wn(t, e, {
        isValuesIterator: !1
      })
    };
  },
  keys() {
    return this.values();
  },
  [Xe]() {
    return this.values();
  },
  forEach(t, e) {
    const n = this.values();
    let r = n.next();
    for (; !r.done; )
      t.call(e, r.value, r.value, this), r = n.next();
  }
}, ti = Reflect.ownKeys(kt), Kn = /* @__PURE__ */ new WeakSet(), Yn = {
  get(t, e, n) {
    var r, i;
    const s = (r = t.copy) === null || r === void 0 ? void 0 : r[e];
    if (s && Kn.has(s))
      return s;
    if (e === Vn)
      return t;
    let o;
    if (t.options.mark) {
      const c = e === "size" && (t.original instanceof Map || t.original instanceof Set) ? Reflect.get(t.original, e) : Reflect.get(t.original, e, n);
      if (o = t.options.mark(c, G), o === G.mutable)
        return t.options.strict && it(c, t.options, !0), c;
    }
    const a = H(t);
    if (a instanceof Map && ei.includes(e)) {
      if (e === "size")
        return Object.getOwnPropertyDescriptor(Mt, "size").get.call(t.proxy);
      const c = Mt[e];
      if (c)
        return c.bind(t.proxy);
    }
    if (a instanceof Set && ti.includes(e)) {
      if (e === "size")
        return Object.getOwnPropertyDescriptor(kt, "size").get.call(t.proxy);
      const c = kt[e];
      if (c)
        return c.bind(t.proxy);
    }
    if (!et(a, e)) {
      const c = gn(a, e);
      return c ? "value" in c ? c.value : (
        // !case: support for getter
        (i = c.get) === null || i === void 0 ? void 0 : i.call(t.proxy)
      ) : void 0;
    }
    const u = a[e];
    if (t.options.strict && it(u, t.options), t.finalized || !ie(u, t.options))
      return u;
    if (u === Et(t.original, e)) {
      if (z(t), t.copy[e] = Gt({
        original: t.original[e],
        parentDraft: t,
        key: t.type === 1 ? Number(e) : e,
        finalities: t.finalities,
        options: t.options
      }), typeof o == "function") {
        const c = j(t.copy[e]);
        return z(c), ue(c), c.copy;
      }
      return t.copy[e];
    }
    return u;
  },
  set(t, e, n) {
    var r;
    if (t.type === 3 || t.type === 2)
      throw new Error("Map/Set draft does not support any property assignment.");
    let i;
    if (t.type === 1 && e !== "length" && !(Number.isInteger(i = Number(e)) && i >= 0 && (e === 0 || i === 0 || String(i) === String(e))))
      throw new Error("Only supports setting array indices and the 'length' property.");
    const s = gn(H(t), e);
    if (s != null && s.set)
      return s.set.call(t.proxy, n), !0;
    const o = Et(H(t), e), a = j(o);
    return a && le(a.original, n) ? (t.copy[e] = n, t.assignedMap = (r = t.assignedMap) !== null && r !== void 0 ? r : /* @__PURE__ */ new Map(), t.assignedMap.set(e, !1), !0) : (le(n, o) && (n !== void 0 || et(t.original, e)) || (z(t), ue(t), et(t.original, e) && le(n, t.original[e]) ? t.assignedMap.delete(e) : t.assignedMap.set(e, !0), t.copy[e] = n, Ht(t, e, n, $e)), !0);
  },
  has(t, e) {
    return e in H(t);
  },
  ownKeys(t) {
    return Reflect.ownKeys(H(t));
  },
  getOwnPropertyDescriptor(t, e) {
    const n = H(t), r = Reflect.getOwnPropertyDescriptor(n, e);
    return r && {
      writable: !0,
      configurable: t.type !== 1 || e !== "length",
      enumerable: r.enumerable,
      value: n[e]
    };
  },
  getPrototypeOf(t) {
    return Reflect.getPrototypeOf(t.original);
  },
  setPrototypeOf() {
    throw new Error("Cannot call 'setPrototypeOf()' on drafts");
  },
  defineProperty() {
    throw new Error("Cannot call 'defineProperty()' on drafts");
  },
  deleteProperty(t, e) {
    var n;
    return t.type === 1 ? Yn.set.call(this, t, e, void 0, t.proxy) : (Et(t.original, e) !== void 0 || e in t.original ? (z(t), ue(t), t.assignedMap.set(e, !1)) : (t.assignedMap = (n = t.assignedMap) !== null && n !== void 0 ? n : /* @__PURE__ */ new Map(), t.assignedMap.delete(e)), t.copy && delete t.copy[e], !0);
  }
};
function Gt(t) {
  const { original: e, parentDraft: n, key: r, finalities: i, options: s } = t, o = ge(e), a = {
    type: o,
    finalized: !1,
    parent: n,
    original: e,
    copy: null,
    proxy: null,
    finalities: i,
    options: s,
    // Mapping of draft Set items to their corresponding draft values.
    setMap: o === 3 ? new Map(e.entries()) : void 0
  };
  (r || "key" in t) && (a.key = r);
  const { proxy: u, revoke: c } = Proxy.revocable(o === 1 ? Object.assign([], a) : a, Yn);
  if (i.revoke.push(c), Kn.add(u), a.proxy = u, n) {
    const l = n;
    l.finalities.draft.push((f, h) => {
      var v, b;
      const m = j(u);
      let E = l.type === 3 ? l.setMap : l.copy;
      const S = de(E, r), y = j(S);
      if (y) {
        let g = y.original;
        y.operated && (g = Kt(S)), xt(y), At(y, $e, f, h), l.options.enableAutoFreeze && (l.options.updatedValues = (v = l.options.updatedValues) !== null && v !== void 0 ? v : /* @__PURE__ */ new WeakMap(), l.options.updatedValues.set(g, y.original)), De(E, r, g);
      }
      (b = m.callbacks) === null || b === void 0 || b.forEach((g) => {
        g(f, h);
      });
    });
  } else {
    const l = j(u);
    l.finalities.draft.push((f, h) => {
      xt(l), At(l, $e, f, h);
    });
  }
  return u;
}
Qt.createDraft = Gt;
function ni(t, e, n, r, i) {
  var s;
  const o = j(t), a = (s = o == null ? void 0 : o.original) !== null && s !== void 0 ? s : t, u = !!e.length;
  if (o != null && o.operated)
    for (; o.finalities.draft.length > 0; )
      o.finalities.draft.pop()(n, r);
  const c = u ? e[0] : o ? o.operated ? o.copy : o.original : t;
  return o && Tt(o), i && Ee(c, c, o == null ? void 0 : o.options.updatedValues), [
    c,
    n && u ? [{ op: k.Replace, path: [], value: e[0] }] : n,
    r && u ? [{ op: k.Replace, path: [], value: a }] : r
  ];
}
function ri(t, e) {
  var n;
  const r = {
    draft: [],
    revoke: [],
    handledSet: /* @__PURE__ */ new WeakSet()
  };
  let i, s;
  e.enablePatches && (i = [], s = []);
  const a = ((n = e.mark) === null || n === void 0 ? void 0 : n.call(e, t, G)) === G.mutable || !ie(t, e) ? t : Gt({
    original: t,
    parentDraft: null,
    finalities: r,
    options: e
  });
  return [
    a,
    (u = []) => {
      const [c, l, f] = ni(a, u, i, s, e.enableAutoFreeze);
      return e.enablePatches ? [c, l, f] : c;
    }
  ];
}
function It(t) {
  const { rootDraft: e, value: n, useRawReturn: r = !1, isRoot: i = !0 } = t;
  Yt(n, (s, o, a) => {
    const u = j(o);
    if (u && e && u.finalities === e.finalities) {
      t.isContainDraft = !0;
      const c = u.original;
      if (a instanceof Set) {
        const l = Array.from(a);
        a.clear(), l.forEach((f) => a.add(s === f ? c : f));
      } else
        De(a, s, c);
    } else typeof o == "object" && o !== null && (t.value = o, t.isRoot = !1, It(t));
  }), i && (t.isContainDraft || console.warn("The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance."), r && console.warn("The return value contains drafts, please don't use 'rawReturn()' to wrap the return value."));
}
function Hn(t) {
  const e = j(t);
  if (!ie(t, e == null ? void 0 : e.options))
    return t;
  const n = ge(t);
  if (e && !e.operated)
    return e.original;
  let r;
  function i() {
    r = n === 2 ? new Map(t) : n === 3 ? Array.from(e.setMap.values()) : Jn(t, e == null ? void 0 : e.options);
  }
  if (e) {
    e.finalized = !0;
    try {
      i();
    } finally {
      e.finalized = !1;
    }
  } else
    r = t;
  return Yt(r, (s, o) => {
    if (e && le(de(e.original, s), o))
      return;
    const a = Hn(o);
    a !== o && (r === t && i(), De(r, s, a));
  }), n === 3 ? new Set(r) : r;
}
function mn(t) {
  if (!be(t))
    throw new Error(`current() is only used for Draft, parameter: ${t}`);
  return Hn(t);
}
const ii = (t) => function e(n, r, i) {
  var s, o, a;
  if (typeof n == "function" && typeof r != "function")
    return function(O, ...$) {
      return e(O, (W) => n.call(this, W, ...$), r);
    };
  const u = n, c = r;
  let l = i;
  if (typeof r != "function" && (l = r), l !== void 0 && Object.prototype.toString.call(l) !== "[object Object]")
    throw new Error(`Invalid options: ${l}, 'options' should be an object.`);
  l = Object.assign(Object.assign({}, t), l);
  const f = be(u) ? mn(u) : u, h = Array.isArray(l.mark) ? (O, $) => {
    for (const W of l.mark) {
      if (typeof W != "function")
        throw new Error(`Invalid mark: ${W}, 'mark' should be a function.`);
      const se = W(O, $);
      if (se)
        return se;
    }
  } : l.mark, v = (s = l.enablePatches) !== null && s !== void 0 ? s : !1, b = (o = l.strict) !== null && o !== void 0 ? o : !1, E = {
    enableAutoFreeze: (a = l.enableAutoFreeze) !== null && a !== void 0 ? a : !1,
    mark: h,
    strict: b,
    enablePatches: v
  };
  if (!ie(f, E) && typeof f == "object" && f !== null)
    throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");
  const [S, y] = ri(f, E);
  if (typeof r != "function") {
    if (!ie(f, E))
      throw new Error("Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.");
    return [S, y];
  }
  let g;
  try {
    g = c(S);
  } catch (O) {
    throw Tt(j(S)), O;
  }
  const A = (O) => {
    const $ = j(S);
    if (!be(O)) {
      if (O !== void 0 && !le(O, S) && ($ != null && $.operated))
        throw new Error("Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.");
      const se = O == null ? void 0 : O[Br];
      if (se) {
        const Ce = se[0];
        return E.strict && typeof O == "object" && O !== null && It({
          rootDraft: $,
          value: O,
          useRawReturn: !0
        }), y([Ce]);
      }
      if (O !== void 0)
        return typeof O == "object" && O !== null && It({ rootDraft: $, value: O }), y([O]);
    }
    if (O === S || O === void 0)
      return y([]);
    const W = j(O);
    if (E === W.options) {
      if (W.operated)
        throw new Error("Cannot return a modified child draft.");
      return y([mn(O)]);
    }
    return y([O]);
  };
  return g instanceof Promise ? g.then(A, (O) => {
    throw Tt(j(S)), O;
  }) : A(g);
}, si = ii();
Object.prototype.constructor.toString();
function Gn(t, e) {
  const n = Object.keys(t), r = Object.keys(e);
  return n.length === r.length && Object.keys(t).every((i) => e.hasOwnProperty(i));
}
function On(t, e) {
  return Object.keys(t).length === Object.keys(e).length && Object.keys(t).every((n) => e.hasOwnProperty(n) && t[n] === e[n]);
}
function tt(t, e) {
  return typeof t != "object" || typeof e != "object" || t === null || e === null ? t === e : Gn(t, e) ? Object.keys(t).every((n) => tt(t[n], e[n])) : !1;
}
function Xn(t, e) {
  if (!Re(t) || !Re(e))
    return e;
  const n = {};
  for (const r of Object.keys(t))
    e[r] !== null && (n[r] = t[r]);
  for (const r of Object.keys(e)) {
    if (e[r] === null)
      continue;
    const i = Re(t[r]) && Re(e[r]);
    n[r] = i ? Xn(t[r], e[r]) : e[r];
  }
  return n;
}
function Zn(t, e, n) {
  if (!Re(t))
    return t;
  const r = {};
  for (const [i, s] of Object.entries(t))
    r[i] = Re(s) ? Zn(s, e, n) : s === e ? n : s;
  return r;
}
function Re(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
function oi(t) {
  return t.cardinality === "one";
}
function Xt(t) {
  return t["value-type"] === "ref";
}
function er(t) {
  return t["value-type"] === "blob";
}
function at(t, e) {
  return t[e];
}
function Zt(t, e) {
  return e.reduce((n, r) => n && n.get(r), t);
}
function re(t, e) {
  if (e.length === 0)
    throw new Error("path must have at least one element");
  if (e.length === 1) {
    t.delete(e[0]);
    return;
  }
  const [n, ...r] = e;
  t.has(n) && re(t.get(n), r);
}
function B(t, e, n) {
  if (e.length === 0)
    throw new Error("path must have at least one element");
  if (e.length === 1) {
    t.set(e[0], n);
    return;
  }
  const [r, ...i] = e;
  let s = t.get(r);
  s || (s = /* @__PURE__ */ new Map(), t.set(r, s)), B(s, i, n);
}
function tr(t, e) {
  const n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  for (const s of e) {
    const [o, a, u, c] = s, l = at(t, a);
    if (!l) {
      console.warn("no such attr", o, t);
      continue;
    }
    Xt(l) && B(i, [u, a, o], s), B(n, [o, a, u], s), B(r, [a, o, u], s);
  }
  return { eav: n, aev: r, vae: i };
}
function nr(t) {
  const e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  for (const s of Object.values(t)) {
    const o = s["forward-identity"], [a, u, c] = o, l = s["reverse-identity"];
    if (B(r, [u, c], s), er(s) && B(e, [u, c], s), s["primary?"] && B(n, [u], s), l) {
      const [f, h, v] = l;
      B(i, [h, v], s);
    }
  }
  return { blobAttrs: e, primaryKeys: n, forwardIdents: r, revIdents: i };
}
function ai(t) {
  return {
    __type: t.__type,
    attrs: t.attrs,
    triples: te(t.eav, 3),
    cardinalityInference: t.cardinalityInference,
    linkIndex: t.linkIndex
  };
}
function ui(t) {
  return $t(t.attrs, t.triples, t.cardinalityInference, t.linkIndex);
}
function en(t) {
  t.attrIndexes = nr(t.attrs);
}
function $t(t, e, n, r) {
  const i = tr(t, e);
  return i.attrs = t, i.attrIndexes = nr(t), i.cardinalityInference = n, i.linkIndex = r, i.__type = "store", i;
}
function ut(t, e) {
  var n, r;
  let i;
  if (Array.isArray(e[0])) {
    const [o, a] = e[0], u = t.aev.get(o);
    if (!u)
      return null;
    i = (n = te(u, 2).find((l) => l[2] === a)) === null || n === void 0 ? void 0 : n[0];
  } else
    i = e[0];
  if (!i)
    return null;
  const s = e[2];
  if (Array.isArray(s) && s.length === 2 && t.aev.get(s[0])) {
    const [o, a] = s, u = t.aev.get(o);
    if (!u)
      return null;
    const l = (r = te(u, 2).find((m) => m[2] === a)) === null || r === void 0 ? void 0 : r[0];
    if (!l)
      return null;
    const [f, h, v, ...b] = e;
    return [i, h, l, ...b];
  } else {
    const [o, ...a] = e;
    return [i, ...a];
  }
}
function ci(t, e) {
  const n = ut(t, e);
  if (!n)
    return;
  const [r, i, s] = n, o = at(t.attrs, i);
  o && (re(t.eav, [r, i, s]), re(t.aev, [i, r, s]), Xt(o) && re(t.vae, [s, i, r]));
}
let li = 0;
function rr(t, e, n) {
  const [r, i, s] = n;
  let o;
  const a = Zt(t.ea, [r, i, s]);
  return a && (o = a[3]), o || Date.now() * 10 + li++;
}
function di(t, e) {
  var n;
  const r = ut(t, e);
  if (!r)
    return;
  const [i, s, o] = r, a = at(t.attrs, s);
  if (!a)
    return;
  const u = Zt(t.eav, [i, s, o]), c = (n = u == null ? void 0 : u[3]) !== null && n !== void 0 ? n : rr(t, a, r), l = [i, s, o, c];
  oi(a) ? (B(t.eav, [i, s], /* @__PURE__ */ new Map([[o, l]])), B(t.aev, [s, i], /* @__PURE__ */ new Map([[o, l]]))) : (B(t.eav, [i, s, o], l), B(t.aev, [s, i, o], l)), Xt(a) && B(t.vae, [o, s, i], l);
}
function fi(t, e) {
  var n;
  const r = ut(t, e);
  if (!r)
    return;
  const [i, s, o] = r, a = at(t.attrs, s);
  if (!a)
    return;
  if (!er(a))
    throw new Error("merge operation is not supported for links");
  const u = Zt(t.eav, [i, s]);
  if (!u)
    return;
  const c = (n = u.values().next()) === null || n === void 0 ? void 0 : n.value;
  if (!c)
    return;
  const l = c[2], f = Xn(l, o), h = [
    i,
    s,
    f,
    rr(t, a, c)
  ];
  B(t.eav, [i, s], /* @__PURE__ */ new Map([[f, h]]));
}
function hi(t, e) {
  var n, r;
  const [i, s] = e, o = ut(t, [i]);
  if (!o)
    return;
  const [a] = o, u = t.eav.get(a);
  if (u) {
    for (const l of u.keys()) {
      const f = t.attrs[l];
      // Fall back to deleting everything if we've rehydrated tx-steps from
      // the store that didn't set `etype` in deleteEntity
      (!s || // If we don't know about the attr, let's just get rid of it
      !f || // Make sure it matches the etype
      ((n = f["forward-identity"]) === null || n === void 0 ? void 0 : n[1]) === s) && (re(t.aev, [l, a]), re(t.eav, [a, l]));
    }
    u.size === 0 && re(t.eav, [a]);
  }
  const c = t.vae.get(a) && te(t.vae.get(a), 2);
  c && c.forEach((l) => {
    var f;
    const [h, v, b] = l, m = t.attrs[v];
    (!s || !m || ((f = m["reverse-identity"]) === null || f === void 0 ? void 0 : f[1]) === s) && (re(t.eav, [h, v, b]), re(t.aev, [v, h, b]), re(t.vae, [b, v, h]));
  }), ((r = t.vae.get(a)) === null || r === void 0 ? void 0 : r.size) === 0 && re(t.vae, [a]);
}
function ir(t, e) {
  const n = tr(t.attrs, e);
  Object.keys(n).forEach((r) => {
    t[r] = n[r];
  });
}
function pi(t, [e]) {
  t.attrs[e.id] = e, en(t);
}
function sr(t) {
  return te(t.eav, 3);
}
function vi(t, [e]) {
  if (!t.attrs[e])
    return;
  const n = sr(t).filter(([r, i]) => i !== e);
  delete t.attrs[e], en(t), ir(t, n);
}
function _i(t, [e]) {
  const n = t.attrs[e.id];
  n && (t.attrs[e.id] = Object.assign(Object.assign({}, n), e), en(t), ir(t, sr(t)));
}
function yi(t, e) {
  const [n, ...r] = e;
  switch (n) {
    case "add-triple":
      di(t, r);
      break;
    case "deep-merge-triple":
      fi(t, r);
      break;
    case "retract-triple":
      ci(t, r);
      break;
    case "delete-entity":
      hi(t, r);
      break;
    case "add-attr":
      pi(t, r);
      break;
    case "delete-attr":
      vi(t, r);
      break;
    case "update-attr":
      _i(t, r);
      break;
    default:
      throw new Error(`unhandled transaction action: ${n}`);
  }
}
function te(t, e, n = []) {
  if (!t || e === 0)
    return n;
  if (e === 1) {
    for (const r of t.values())
      n.push(r);
    return n;
  }
  for (const r of t.values())
    te(r, e - 1, n);
  return n;
}
function Qe(t, e, n) {
  var r, i;
  const s = [];
  if (n != null && n.hasOwnProperty("$not")) {
    for (const a of e.keys())
      n.$not !== a && s.push(e.get(a));
    return s;
  }
  if (n != null && n.hasOwnProperty("$isNull")) {
    const { attrId: a, isNull: u, reverse: c } = n.$isNull;
    if (c)
      for (const l of e.keys()) {
        const f = t.vae.get(l), h = !f || ((r = f.get(a)) === null || r === void 0 ? void 0 : r.get(null)) || !f.get(a);
        (u ? h : !h) && s.push(e.get(l));
      }
    else {
      const l = t.aev.get(a);
      for (const f of e.keys()) {
        const h = !l || ((i = l.get(f)) === null || i === void 0 ? void 0 : i.get(null)) || !l.get(f);
        (u ? h : !h) && s.push(e.get(f));
      }
    }
    return s;
  }
  if (n != null && n.$comparator)
    return te(e, 1).filter(n.$op);
  const o = n.in || n.$in || [n];
  for (const a of o) {
    const u = e.get(a);
    u && s.push(u);
  }
  return s;
}
function bi(t, e, n) {
  let r = "";
  return t !== void 0 && (r += "e"), e !== void 0 && (r += "a"), n !== void 0 && (r += "v"), r;
}
function gi(t, [e, n, r]) {
  var i, s;
  switch (bi(e, n, r)) {
    case "e": {
      const a = t.eav.get(e);
      return te(a, 2);
    }
    case "ea": {
      const a = (i = t.eav.get(e)) === null || i === void 0 ? void 0 : i.get(n);
      return te(a, 1);
    }
    case "eav": {
      const a = (s = t.eav.get(e)) === null || s === void 0 ? void 0 : s.get(n);
      return a ? Qe(t, a, r) : [];
    }
    case "ev": {
      const a = t.eav.get(e);
      if (!a)
        return [];
      const u = [];
      for (const c of a.values())
        u.push(...Qe(t, c, r));
      return u;
    }
    case "a": {
      const a = t.aev.get(n);
      return te(a, 2);
    }
    case "av": {
      const a = t.aev.get(n);
      if (!a)
        return [];
      const u = [];
      for (const c of a.values())
        u.push(...Qe(t, c, r));
      return u;
    }
    case "v": {
      const a = [];
      for (const u of t.eav.values())
        for (const c of u.values())
          a.push(...Qe(t, c, r));
    }
    default:
      return te(t.eav, 3);
  }
}
function wi(t, e, n) {
  var r;
  const i = t.attrIndexes.blobAttrs.get(e), s = {};
  for (const [o, a] of i.entries()) {
    const u = (r = t.eav.get(n)) === null || r === void 0 ? void 0 : r.get(a.id), c = te(u, 1);
    for (const l of c)
      s[o] = l[2];
  }
  return s;
}
function st(t, e, n) {
  var r;
  return (r = t.attrIndexes.forwardIdents.get(e)) === null || r === void 0 ? void 0 : r.get(n);
}
function or(t, e, n) {
  var r;
  return (r = t.attrIndexes.revIdents.get(e)) === null || r === void 0 ? void 0 : r.get(n);
}
function mi(t, e) {
  var n;
  const r = t.attrIndexes.primaryKeys.get(e);
  return r || ((n = t.attrIndexes.forwardIdents.get(e)) === null || n === void 0 ? void 0 : n.get("id"));
}
function Sn(t, e) {
  return si(t, (n) => {
    e.forEach((r) => {
      yi(n, r);
    });
  });
}
function Oi(t) {
  return typeof t == "string" && t.startsWith("?");
}
function Si(t, e, n) {
  if (n.hasOwnProperty(t)) {
    const r = n[t];
    return ar(r, e, n);
  }
  return Object.assign(Object.assign({}, n), { [t]: e });
}
function En(t, e, n) {
  return t === e ? n : null;
}
function Ei(t) {
  switch (typeof t) {
    case "string":
      return t.startsWith("?") ? Si : En;
    default:
      return En;
  }
}
const Ri = [
  "in",
  "$in",
  "$not",
  "$isNull",
  "$comparator"
  // covers all of $gt, $lt, etc.
];
function ji(t) {
  for (const e of Ri)
    if (t.hasOwnProperty(e))
      return !0;
  return !1;
}
function ar(t, e, n) {
  return n ? typeof t == "object" ? ji(t) ? n : null : Ei(t)(t, e, n) : null;
}
function Ci(t, e, n) {
  return t.reduce((r, i, s) => {
    const o = e[s];
    return ar(i, o, r);
  }, n);
}
function Pi(t, e, n) {
  return Ai(t, e, n).map((r) => Ci(e, r, n)).filter((r) => r);
}
function Ti(t, e, n) {
  return e.or ? e.or.patterns.flatMap((r) => Dt(t, r, n)) : e.and ? e.and.patterns.reduce((r, i) => Dt(t, i, r), n) : n.flatMap((r) => Pi(t, e, r));
}
function Dt(t, e, n = [{}]) {
  return e.reduce((r, i) => Ti(t, i, r), n);
}
function tn(t, e) {
  return Array.isArray(e) ? e.map((n) => tn(t, n)) : Oi(e) ? t[e] : e;
}
function xi(t, { find: e, where: n }) {
  return Dt(t, n).map((i) => tn(i, e));
}
function Ai(t, e, n) {
  return gi(t, tn(n, e));
}
let Ke;
const Mi = new Uint8Array(16);
function ki() {
  if (!Ke && (Ke = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Ke))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Ke(Mi);
}
const U = [];
for (let t = 0; t < 256; ++t)
  U.push((t + 256).toString(16).slice(1));
function Ii(t, e = 0) {
  return U[t[e + 0]] + U[t[e + 1]] + U[t[e + 2]] + U[t[e + 3]] + "-" + U[t[e + 4]] + U[t[e + 5]] + "-" + U[t[e + 6]] + U[t[e + 7]] + "-" + U[t[e + 8]] + U[t[e + 9]] + "-" + U[t[e + 10]] + U[t[e + 11]] + U[t[e + 12]] + U[t[e + 13]] + U[t[e + 14]] + U[t[e + 15]];
}
const $i = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Rn = {
  randomUUID: $i
};
function Di(t, e, n) {
  if (Rn.randomUUID && !e && !t)
    return Rn.randomUUID();
  t = t || {};
  const r = t.random || (t.rng || ki)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Ii(r);
}
function jn(t) {
  const e = t.replace(/-/g, ""), n = [];
  for (let r = 0; r < e.length; r += 2)
    n.push(parseInt(e.substring(r, r + 2), 16));
  return n;
}
function Ui(t, e) {
  for (let n = 0; n < t.length; n++) {
    if (t[n] < e[n])
      return -1;
    if (t[n] > e[n])
      return 1;
  }
  return 0;
}
function Li(t, e) {
  return Ui(jn(t), jn(e));
}
function N() {
  return Di();
}
let Ni = 0;
function Ie(t) {
  return ct(`_${t}`, Ni++);
}
function ct(t, e) {
  return `?${t}-${e}`;
}
class je extends Error {
  constructor(e) {
    super(e), this.name = "AttrNotFoundError";
  }
}
function qi(t, e) {
  const n = mi(t, e);
  if (!n)
    throw new je(`Could not find id attr for ${e}`);
  return n;
}
function Cn(t, e, n, r) {
  return [Fi(t, e, n, r)];
}
function Fi(t, e, n, r) {
  return [
    t(n, r),
    qi(e, n).id,
    t(n, r),
    t("time", r)
  ];
}
function zi(t, e, n) {
  return t.map((r) => r === e ? n : r);
}
function ur(t, e, n, r, i) {
  const s = st(e, n, i), o = or(e, n, i), a = s || o;
  if (!a)
    throw new je(`Could not find attr for ${[n, i]}`);
  if (a["value-type"] !== "ref")
    throw new Error(`Attr ${a.id} is not a ref`);
  const [u, c] = a["forward-identity"], [l, f] = a["reverse-identity"], h = r + 1, v = s ? [
    t(c, r),
    a.id,
    t(f, h),
    Ie("time")
  ] : [
    t(c, h),
    a.id,
    t(f, r),
    Ie("time")
  ];
  return [s ? f : c, h, v, a, !!s];
}
function Pn(t, e) {
  if (typeof e != "string")
    return function(s) {
      return !1;
    };
  const n = e.replace(/%/g, ".*").replace(/_/g, "."), r = new RegExp(`^${n}$`, t ? void 0 : "i");
  return function(s) {
    return typeof s != "string" ? !1 : r.test(s);
  };
}
function Wi(t, e) {
  if (typeof e != "object" || e.hasOwnProperty("$in") || e.hasOwnProperty("in"))
    return e;
  const n = t["checked-data-type"] === "date";
  if (e.hasOwnProperty("$gt"))
    return {
      $comparator: !0,
      $op: n ? function(i) {
        return new Date(i[2]) > new Date(e.$gt);
      } : function(i) {
        return i[2] > e.$gt;
      }
    };
  if (e.hasOwnProperty("$gte"))
    return {
      $comparator: !0,
      $op: n ? function(i) {
        return new Date(i[2]) >= new Date(e.$gte);
      } : function(i) {
        return i[2] >= e.$gte;
      }
    };
  if (e.hasOwnProperty("$lt"))
    return {
      $comparator: !0,
      $op: n ? function(i) {
        return new Date(i[2]) < new Date(e.$lt);
      } : function(i) {
        return i[2] < e.$lt;
      }
    };
  if (e.hasOwnProperty("$lte"))
    return {
      $comparator: !0,
      $op: n ? function(i) {
        return new Date(i[2]) <= new Date(e.$lte);
      } : function(i) {
        return i[2] <= e.$lte;
      }
    };
  if (e.hasOwnProperty("$like")) {
    const r = Pn(!0, e.$like);
    return {
      $comparator: !0,
      $op: function(s) {
        return r(s[2]);
      }
    };
  }
  if (e.hasOwnProperty("$ilike")) {
    const r = Pn(!1, e.$ilike);
    return {
      $comparator: !0,
      $op: function(s) {
        return r(s[2]);
      }
    };
  }
  return e;
}
function Vi(t, e, n, r, i, s) {
  const o = st(e, n, i), a = or(e, n, i), u = o || a;
  if (!u)
    throw new je(`No attr for etype = ${n} label = ${i}`);
  if (s != null && s.hasOwnProperty("$isNull")) {
    const c = st(e, n, "id");
    if (!c)
      throw new je(`No attr for etype = ${n} label = id`);
    return [
      t(n, r),
      c.id,
      { $isNull: { attrId: u.id, isNull: s.$isNull, reverse: !o } },
      Ie("time")
    ];
  }
  return o ? [
    t(n, r),
    u.id,
    Wi(u, s),
    Ie("time")
  ] : [s, u.id, t(n, r), Ie("time")];
}
function Bi(t, e, n, r, i) {
  const [s, o, a] = i.reduce((u, c) => {
    const [l, f, h] = u, [v, b, m] = ur(t, e, l, f, c);
    return [v, b, [...h, m]];
  }, [n, r, []]);
  return [s, o, a];
}
function Ut(t, e, n, r, i, s) {
  const o = i.slice(0, i.length - 1), a = i[i.length - 1], [u, c, l] = Bi(t, e, n, r, o), f = Vi(t, e, u, c, a, s);
  return l.concat([f]);
}
function Ji(t, e) {
  return e ? [e].concat(t) : t;
}
function Qi([t, e]) {
  return t === "or" && Array.isArray(e);
}
function Ki([t, e]) {
  return t === "and" && Array.isArray(e);
}
function Yi(t, e, n) {
  return (r, i) => r == e ? t(r, i) : `${t(r, i)}-${n}`;
}
function Tn(t, e, n, r, i, s) {
  const o = s.map((u, c) => {
    const l = Yi(t, r, c);
    return cr(l, n, r, i, u);
  }), a = t(r, i);
  return { [e]: { patterns: o, joinSym: a } };
}
function Hi(t) {
  const e = [];
  for (let n = 1; n <= t.length; n++)
    e.push(t.slice(0, n));
  return e;
}
function xn(t, e, n, r, i) {
  return Hi(i).map((s) => Ut(t, e, n, r, s, { $isNull: !0 }));
}
function cr(t, e, n, r, i) {
  return Object.entries(i).flatMap(([s, o]) => {
    if (Qi([s, o]))
      return Tn(t, "or", e, n, r, o);
    if (Ki([s, o]))
      return Tn(t, "and", e, n, r, o);
    const a = s.split(".");
    if (o != null && o.hasOwnProperty("$not")) {
      const u = Ut(t, e, n, r, a, o), c = xn(t, e, n, r, a);
      return [
        {
          or: {
            patterns: [u, ...c],
            joinSym: t(n, r)
          }
        }
      ];
    }
    return o != null && o.hasOwnProperty("$isNull") && o.$isNull === !0 && a.length > 1 ? [
      {
        or: {
          patterns: xn(t, e, n, r, a),
          joinSym: t(n, r)
        }
      }
    ] : Ut(t, e, n, r, a, o);
  });
}
function Gi(t, e, n, r) {
  const i = ct;
  return r ? cr(i, t, e, n, r).concat(Cn(i, t, e, n)) : Cn(i, t, e, n);
}
function Xi(t, e, n) {
  return [t(e, n), t("time", n)];
}
function Zi(t, e, n, r, i, s) {
  const [o, a, u, c, l] = ur(t, e, n, r, i), f = zi(u, t(n, r), s);
  return [o, a, f, c, l];
}
function es(t, e, { etype: n, level: r, form: i }, s) {
  const o = Object.keys(i).filter((a) => a !== "$");
  return o.length ? Object.entries(s).map(function([u, c]) {
    return o.map(function(h) {
      var v, b, m;
      const E = !!(e.cardinalityInference && (!((m = (b = (v = e.linkIndex) === null || v === void 0 ? void 0 : v[n]) === null || b === void 0 ? void 0 : b[h]) === null || m === void 0) && m.isSingular));
      try {
        const [S, y, g] = Zi(t, e, n, r, h, u), A = lr(e, {
          etype: S,
          level: y,
          form: i[h],
          join: g
        }), O = E ? A[0] : A;
        return { [h]: O };
      } catch (S) {
        if (S instanceof je)
          return { [h]: E ? void 0 : [] };
        throw S;
      }
    }).reduce(function(h, v) {
      return Object.assign(Object.assign({}, h), v);
    }, c);
  }) : Object.values(s);
}
function ot([t, e], [n, r]) {
  return e === r || e == null && r == null ? Li(t, n) : r == null ? 1 : e == null ? -1 : e > r ? 1 : -1;
}
function Lt(t) {
  return t == null ? t : new Date(t).getTime();
}
function ts(t, e, n, r) {
  var i;
  const [s, o, a, u] = t, c = n === "desc" ? 1 : -1;
  if (((i = e["forward-identity"]) === null || i === void 0 ? void 0 : i[2]) === "id")
    return ot(r, [s, u]) === c;
  const [l, f] = r, h = e["checked-data-type"] === "date" ? Lt(f) : f, v = e["checked-data-type"] === "date" ? Lt(a) : a;
  return ot([l, h], [s, v]) === c;
}
function ns(t, e) {
  const n = e[1];
  return t.attrs[n];
}
function rs(t, e, n) {
  const r = Object.keys(n)[0];
  return st(t, e, r);
}
function is(t, e, n, r) {
  if (n)
    return ns(t, n);
  if (r)
    return rs(t, e, r);
}
function ss(t, e, n, r, i, s) {
  var o;
  let a = xi(t, s);
  const u = r == null ? void 0 : r["start-cursor"], c = is(t, e, u, i);
  if (c && ((o = c == null ? void 0 : c["forward-identity"]) === null || o === void 0 ? void 0 : o[2]) !== "id") {
    const f = c["checked-data-type"] === "date", h = c.id;
    a = a.map(([v]) => {
      var b, m, E, S, y;
      let g = (y = (S = (E = (m = (b = t.eav.get(v)) === null || b === void 0 ? void 0 : b.get(h)) === null || m === void 0 ? void 0 : m.values()) === null || E === void 0 ? void 0 : E.next()) === null || S === void 0 ? void 0 : S.value) === null || y === void 0 ? void 0 : y[2];
      return f && (g = Lt(g)), [v, g];
    });
  }
  a.sort(n === "asc" ? function(h, v) {
    return ot(h, v);
  } : function(h, v) {
    return ot(v, h);
  });
  let l = {};
  for (const f of a) {
    const [h] = f;
    if (l[h] || u && c && ts(u, c, n, f))
      continue;
    const v = wi(t, e, h);
    v && (l[h] = v);
  }
  return l;
}
function os(t) {
  var e;
  const n = (e = t.$) === null || e === void 0 ? void 0 : e.order;
  return n && n[Object.keys(n)[0]] || "asc";
}
function as(t, { etype: e, level: n, form: r, join: i, pageInfo: s }) {
  var o, a, u, c, l, f, h, v;
  const b = ((o = r.$) === null || o === void 0 ? void 0 : o.limit) || ((a = r.$) === null || a === void 0 ? void 0 : a.first) || ((u = r.$) === null || u === void 0 ? void 0 : u.last), m = (c = r.$) === null || c === void 0 ? void 0 : c.offset, E = (l = r.$) === null || l === void 0 ? void 0 : l.before, S = (f = r.$) === null || f === void 0 ? void 0 : f.after, y = (h = r.$) === null || h === void 0 ? void 0 : h.order;
  if ((m || E || S) && (!s || !s["start-cursor"]))
    return [];
  const g = Ji(Gi(t, e, n, (v = r.$) === null || v === void 0 ? void 0 : v.where), i), A = Xi(ct, e, n), O = ss(t, e, os(r), s, y, { where: g, find: A });
  if (b != null) {
    const $ = Object.entries(O);
    return $.length <= b ? O : Object.fromEntries($.slice(0, b));
  }
  return O;
}
function us(t, e) {
  try {
    return as(t, e);
  } catch (n) {
    if (n instanceof je)
      return {};
    throw n;
  }
}
function lr(t, e) {
  const n = us(t, e);
  return es(ct, t, e, n);
}
function cs(t) {
  const e = {};
  for (const [n, r] of Object.entries(t))
    e[n] = {
      startCursor: r["start-cursor"],
      endCursor: r["end-cursor"],
      hasNextPage: r["has-next-page?"],
      hasPreviousPage: r["has-previous-page?"]
    };
  return e;
}
function ls({ store: t, pageInfo: e, aggregate: n }, r) {
  const s = { data: Object.keys(r).reduce(function(a, u) {
    return n != null && n[u] || (a[u] = lr(t, {
      etype: u,
      form: r[u],
      level: 0,
      pageInfo: e == null ? void 0 : e[u]
    })), a;
  }, {}) };
  return e && (s.pageInfo = cs(e)), n && (s.aggregate = n), s;
}
function Nt(t, e, n) {
  return new Proxy({}, {
    get: (r, i) => i === "__ops" ? n : (s) => Nt(t, e, [
      ...n,
      [i, t, e, s]
    ])
  });
}
function Bo(t, e) {
  return `lookup__${t}__${JSON.stringify(e)}`;
}
function qt(t) {
  return t.startsWith("lookup__");
}
function dr(t) {
  const [e, n, ...r] = t.split("__");
  return [n, JSON.parse(r.join("__"))];
}
function ds(t) {
  return new Proxy({}, {
    get(e, n) {
      return qt(n) ? Nt(t, dr(n), []) : Nt(t, n, []);
    }
  });
}
function nn() {
  return new Proxy({}, {
    get(t, e) {
      return ds(e);
    }
  });
}
const Jo = nn();
function fs(t) {
  return t.__ops;
}
function hs(t, e) {
  const { attrIdMap: n, refSwapAttrIds: r } = t, i = [];
  for (const o of e) {
    const a = n[o];
    if (a)
      i.push(a);
    else if (Array.isArray(o) && o.length == 2 && n[o[0]]) {
      const [u, c] = o;
      i.push([n[u], c]);
    } else
      i.push(o);
  }
  const [s] = e;
  if ((s === "add-triple" || s === "retract-triple") && r.has(e[2])) {
    const o = i[1];
    i[1] = i[3], i[3] = o;
  }
  return i;
}
function J(t, e, n) {
  return Object.values(t).find((r) => {
    const [i, s, o] = r["forward-identity"];
    return s === e && o === n;
  });
}
function ye(t, e, n) {
  return Object.values(t).find((r) => {
    const i = r["reverse-identity"];
    if (!i)
      return !1;
    const [s, o, a] = i;
    return o === e && a === n;
  });
}
function ps(t) {
  if (Array.isArray(t))
    return t;
  const e = Object.entries(t);
  if (e.length !== 1)
    throw new Error("lookup must be an object with a single unique attr and value.");
  return e[0];
}
function Ft(t, e, n) {
  return n.indexOf(".") !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
  // before assuming it's a ref lookup.
  !J(t, e, n);
}
function zt(t) {
  const [e, n, ...r] = t.split(".");
  if (r.length > 0 || n !== "id")
    throw new Error(`${t} is not a valid lookup attribute.`);
  return e;
}
function vs(t, e, n) {
  if (!Ft(t, e, n))
    return J(t, e, n);
  const r = zt(n), i = J(t, e, r) || ye(t, e, r);
  if (i && i["value-type"] !== "ref")
    throw new Error(`${n} does not reference a valid link attribute.`);
  return i;
}
function Wt(t) {
  return typeof t == "string" && !qt(t) ? null : typeof t == "string" && qt(t) ? dr(t) : ps(t);
}
function ne(t, e, n) {
  const r = Wt(n);
  if (r === null)
    return n;
  const [i, s] = r, o = vs(t, e, i);
  if (!o || !o["unique?"])
    throw new Error(`${i} is not a unique attribute.`);
  return [o.id, s];
}
function _s(t, [e, n, r]) {
  return Object.entries(r).flatMap(([s, o]) => {
    const a = Array.isArray(o) ? o : [o], u = J(t, e, s), c = ye(t, e, s);
    return a.map((l) => u ? [
      "add-triple",
      ne(t, e, n),
      u.id,
      ne(t, u["reverse-identity"][1], l)
    ] : [
      "add-triple",
      ne(t, c["forward-identity"][1], l),
      c.id,
      ne(t, e, n)
    ]);
  });
}
function ys(t, [e, n, r]) {
  return Object.entries(r).flatMap(([s, o]) => {
    const a = Array.isArray(o) ? o : [o], u = J(t, e, s), c = ye(t, e, s);
    return a.map((l) => u ? [
      "retract-triple",
      ne(t, e, n),
      u.id,
      ne(t, u["reverse-identity"][1], l)
    ] : [
      "retract-triple",
      ne(t, c["forward-identity"][1], l),
      c.id,
      ne(t, e, n)
    ]);
  });
}
function bs(t, [e, n, r]) {
  const i = ne(t, e, n);
  return [["id", ne(t, e, n)]].concat(Object.entries(r)).map(([o, a]) => {
    const u = J(t, e, o);
    return ["add-triple", i, u.id, a];
  });
}
function gs(t, [e, n]) {
  return [["delete-entity", ne(t, e, n), e]];
}
function ws(t, [e, n, r]) {
  const i = ne(t, e, n), s = Object.entries(r).map(([a, u]) => {
    const c = J(t, e, a), l = Zn(u, void 0, null);
    return ["deep-merge-triple", i, c.id, l];
  });
  return [[
    "add-triple",
    i,
    J(t, e, "id").id,
    i
  ]].concat(s);
}
function ms(t) {
  const [e, n, r, i] = t;
  if (!i)
    return t;
  const s = Object.assign({}, i);
  return delete s.id, [e, n, r, s];
}
function Os(t, e) {
  const [n, ...r] = ms(e);
  switch (n) {
    case "merge":
      return ws(t, r);
    case "update":
      return bs(t, r);
    case "link":
      return _s(t, r);
    case "unlink":
      return ys(t, r);
    case "delete":
      return gs(t, r);
    default:
      throw new Error(`unsupported action ${n}`);
  }
}
function Ss(t) {
  switch (t) {
    case "string":
    case "date":
    case "boolean":
    case "number":
      return t;
    default:
      return;
  }
}
function Es(t, e, n) {
  var r, i;
  const s = (i = (r = t.entities[e]) === null || r === void 0 ? void 0 : r.attrs) === null || i === void 0 ? void 0 : i[n];
  if (n === "id")
    return null;
  if (!s)
    throw new Error(`${e}.${n} does not exist in your schema`);
  const { unique: o, indexed: a } = s == null ? void 0 : s.config, u = Ss(s == null ? void 0 : s.valueType);
  return {
    "index?": a,
    "unique?": o,
    "checked-data-type": u
  };
}
function Rt(t, e, n, r) {
  const i = t ? Es(t, e, n) : null, s = N(), a = [N(), e, n];
  return Object.assign(Object.assign({ id: s, "forward-identity": a, "value-type": "blob", cardinality: "one", "unique?": !1, "index?": !1, isUnsynced: !0 }, i || {}), r || {});
}
function Rs(t, e, n) {
  return Object.values(t.links).find((i) => i.forward.on === e && i.forward.label === n || i.reverse.on === e && i.reverse.label === n);
}
function js(t, e, n) {
  const r = Rs(t, e, n);
  if (!r)
    throw new Error(`Couldn't find the link ${e}.${n} in your schema`);
  const { forward: i, reverse: s } = r;
  return {
    "forward-identity": [N(), i.on, i.label],
    "reverse-identity": [N(), s.on, s.label],
    cardinality: i.has === "one" ? "one" : "many",
    "unique?": s.has === "one"
  };
}
function An(t, e, n, r) {
  const i = t ? js(t, e, n) : null, s = N(), o = [N(), e, n], a = [N(), n, e];
  return Object.assign(Object.assign({ id: s, "forward-identity": o, "reverse-identity": a, "value-type": "ref", cardinality: "many", "unique?": !1, "index?": !1, isUnsynced: !0 }, i || {}), r || {});
}
const Cs = /* @__PURE__ */ new Set(["update", "merge", "link", "unlink"]), Ps = /* @__PURE__ */ new Set(["link", "unlink"]), Ts = /* @__PURE__ */ new Set(["update", "merge"]), xs = /* @__PURE__ */ new Set([
  "link",
  "unlink",
  "update",
  "merge",
  "delete"
]), Vt = { "unique?": !0, "index?": !0 }, As = Object.assign(Object.assign({}, Vt), { cardinality: "one" });
function Ms(t) {
  const e = [], [n, r, i, s] = t;
  if (!xs.has(n))
    return e;
  const o = Wt(i);
  if (o && e.push({ etype: r, lookupPair: o }), n === "link")
    for (const [a, u] of Object.entries(s)) {
      const c = Array.isArray(u) ? u : [u];
      for (const l of c) {
        const f = Wt(l);
        f && e.push({
          etype: r,
          lookupPair: f,
          linkLabel: a
        });
      }
    }
  return e;
}
function ks({ attrs: t, schema: e }, n) {
  var r, i;
  const [s, o, a] = [/* @__PURE__ */ new Set(), Object.assign({}, t), []];
  function u(f) {
    o[f.id] = f, a.push(["add-attr", f]), s.add(f.id);
  }
  function c(f) {
    f != null && f.isUnsynced && !s.has(f.id) && (a.push(["add-attr", f]), s.add(f.id));
  }
  function l(f, h) {
    const v = J(o, f, h), b = ye(o, f, h);
    c(v), c(b), !v && !b && u(An(e, f, h, As));
  }
  for (const f of n)
    for (const { etype: h, lookupPair: v, linkLabel: b } of Ms(f)) {
      const m = v[0];
      if (b) {
        l(h, b);
        const E = J(o, h, b), S = ye(o, h, b);
        c(E), c(S);
        const y = ((r = E == null ? void 0 : E["reverse-identity"]) === null || r === void 0 ? void 0 : r[1]) || ((i = S == null ? void 0 : S["forward-identity"]) === null || i === void 0 ? void 0 : i[1]) || b;
        if (Ft(o, y, m))
          l(y, zt(m));
        else {
          const g = J(o, y, m);
          g || u(Rt(e, y, m, Vt)), c(g);
        }
      } else if (Ft(o, h, m))
        l(h, zt(m));
      else {
        const E = J(o, h, m);
        E || u(Rt(e, h, m, Vt)), c(E);
      }
    }
  for (const f of n) {
    const [h, v, b, m] = f;
    if (Cs.has(h)) {
      const E = Object.keys(m);
      E.push("id");
      for (const S of E) {
        const y = J(o, v, S);
        if (c(y), Ts.has(h) && (y || u(Rt(e, v, S, S === "id" ? { "unique?": !0 } : null))), Ps.has(h)) {
          const g = ye(o, v, S);
          !y && !g && u(An(e, v, S)), c(g);
        }
      }
    }
  }
  return [o, a];
}
function Is(t, e) {
  const r = (Array.isArray(e) ? e : [e]).flatMap((a) => fs(a)), [i, s] = ks(t, r), o = r.flatMap((a) => Os(i, a));
  return [...s, ...o];
}
var Mn = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function a(l) {
      try {
        c(r.next(l));
      } catch (f) {
        o(f);
      }
    }
    function u(l) {
      try {
        c(r.throw(l));
      } catch (f) {
        o(f);
      }
    }
    function c(l) {
      l.done ? s(l.value) : i(l.value).then(a, u);
    }
    c((r = r.apply(t, e || [])).next());
  });
};
class fr {
  constructor(e) {
    this.dbName = e, this._storeName = "kv", this._dbPromise = this._init();
  }
  _init() {
    return new Promise((e, n) => {
      const r = indexedDB.open(this.dbName, 1);
      r.onerror = (i) => {
        n(i);
      }, r.onsuccess = (i) => {
        e(i.target.result);
      }, r.onupgradeneeded = (i) => {
        i.target.result.createObjectStore(this._storeName);
      };
    });
  }
  getItem(e) {
    return Mn(this, void 0, void 0, function* () {
      const n = yield this._dbPromise;
      return new Promise((r, i) => {
        const a = n.transaction([this._storeName], "readonly").objectStore(this._storeName).get(e);
        a.onerror = (u) => {
          i(u);
        }, a.onsuccess = (u) => {
          a.result ? r(a.result) : r(null);
        };
      });
    });
  }
  setItem(e, n) {
    return Mn(this, void 0, void 0, function* () {
      const r = yield this._dbPromise;
      return new Promise((i, s) => {
        const u = r.transaction([this._storeName], "readwrite").objectStore(this._storeName).put(n, e);
        u.onerror = (c) => {
          s(c);
        }, u.onsuccess = (c) => {
          i();
        };
      });
    });
  }
}
var $s = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function a(l) {
      try {
        c(r.next(l));
      } catch (f) {
        o(f);
      }
    }
    function u(l) {
      try {
        c(r.throw(l));
      } catch (f) {
        o(f);
      }
    }
    function c(l) {
      l.done ? s(l.value) : i(l.value).then(a, u);
    }
    c((r = r.apply(t, e || [])).next());
  });
};
class hr {
  static getIsOnline() {
    return $s(this, void 0, void 0, function* () {
      return navigator.onLine;
    });
  }
  static listen(e) {
    const n = () => {
      e(!0);
    }, r = () => {
      e(!1);
    };
    return addEventListener("online", n), addEventListener("offline", r), () => {
      removeEventListener("online", n), removeEventListener("offline", r);
    };
  }
}
var Ds = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function a(l) {
      try {
        c(r.next(l));
      } catch (f) {
        o(f);
      }
    }
    function u(l) {
      try {
        c(r.throw(l));
      } catch (f) {
        o(f);
      }
    }
    function c(l) {
      l.done ? s(l.value) : i(l.value).then(a, u);
    }
    c((r = r.apply(t, e || [])).next());
  });
};
function fe(t, e) {
  return Ds(this, void 0, void 0, function* () {
    const n = yield fetch(t, e), r = yield n.json();
    return n.status === 200 ? Promise.resolve(r) : Promise.reject({ status: n.status, body: r });
  });
}
var Ue = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function a(l) {
      try {
        c(r.next(l));
      } catch (f) {
        o(f);
      }
    }
    function u(l) {
      try {
        c(r.throw(l));
      } catch (f) {
        o(f);
      }
    }
    function c(l) {
      l.done ? s(l.value) : i(l.value).then(a, u);
    }
    c((r = r.apply(t, e || [])).next());
  });
};
function Us({ apiURI: t, appId: e, email: n }) {
  return fe(`${t}/runtime/auth/send_magic_code`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ "app-id": e, email: n })
  });
}
function Ls(t) {
  return Ue(this, arguments, void 0, function* ({ apiURI: e, appId: n, email: r, code: i }) {
    return yield fe(`${e}/runtime/auth/verify_magic_code`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ "app-id": n, email: r, code: i })
    });
  });
}
function Ns(t) {
  return Ue(this, arguments, void 0, function* ({ apiURI: e, appId: n, refreshToken: r }) {
    return yield fe(`${e}/runtime/auth/verify_refresh_token`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        "app-id": n,
        "refresh-token": r
      })
    });
  });
}
function kn(t) {
  return Ue(this, arguments, void 0, function* ({ apiURI: e, appId: n, code: r, codeVerifier: i }) {
    return yield fe(`${e}/runtime/oauth/token`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        app_id: n,
        code: r,
        code_verifier: i
      })
    });
  });
}
function qs(t) {
  return Ue(this, arguments, void 0, function* ({ apiURI: e, appId: n, nonce: r, idToken: i, clientName: s, refreshToken: o }) {
    return yield fe(`${e}/runtime/oauth/id_token`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        app_id: n,
        nonce: r,
        id_token: i,
        client_name: s,
        refresh_token: o
      })
    });
  });
}
function Fs(t) {
  return Ue(this, arguments, void 0, function* ({ apiURI: e, appId: n, refreshToken: r }) {
    return yield fe(`${e}/runtime/signout`, {
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify({
        app_id: n,
        refresh_token: r
      })
    });
  });
}
var lt = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function a(l) {
      try {
        c(r.next(l));
      } catch (f) {
        o(f);
      }
    }
    function u(l) {
      try {
        c(r.throw(l));
      } catch (f) {
        o(f);
      }
    }
    function c(l) {
      l.done ? s(l.value) : i(l.value).then(a, u);
    }
    c((r = r.apply(t, e || [])).next());
  });
};
function zs(t) {
  return lt(this, arguments, void 0, function* ({ apiURI: e, appId: n, fileName: r, refreshToken: i, metadata: s = {} }) {
    const { data: o } = yield fe(`${e}/storage/signed-upload-url`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${i}`
      },
      body: JSON.stringify({
        app_id: n,
        filename: r
      })
    });
    return o;
  });
}
function Ws(t, e) {
  return lt(this, void 0, void 0, function* () {
    return (yield fetch(t, {
      method: "PUT",
      body: e,
      headers: {
        "Content-Type": e.type
      }
    })).ok;
  });
}
function Vs(t) {
  return lt(this, arguments, void 0, function* ({ apiURI: e, appId: n, path: r, refreshToken: i }) {
    const { data: s } = yield fe(`${e}/storage/signed-download-url?app_id=${n}&filename=${encodeURIComponent(r)}`, {
      method: "GET",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${i}`
      }
    });
    return s;
  });
}
function Bs(t) {
  return lt(this, arguments, void 0, function* ({ apiURI: e, appId: n, path: r, refreshToken: i }) {
    const { data: s } = yield fe(`${e}/storage/files?app_id=${n}&filename=${encodeURIComponent(r)}`, {
      method: "DELETE",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${i}`
      }
    });
    return s;
  });
}
function In(t, e) {
  if (!e)
    return t;
  const n = {};
  return e.forEach((r) => {
    n[r] = t[r];
  }), n;
}
function Js(t, e, n) {
  var r, i;
  const s = {
    peers: {}
  };
  if (e && "user" in e ? e.user : !0) {
    const a = In((r = t.user) !== null && r !== void 0 ? r : {}, e == null ? void 0 : e.keys);
    s.user = Object.assign(Object.assign({}, a), { peerId: n });
  }
  for (const a of Object.keys((i = t.peers) !== null && i !== void 0 ? i : {})) {
    const u = (e == null ? void 0 : e.peers) === void 0, c = Array.isArray(e == null ? void 0 : e.peers) && (e == null ? void 0 : e.peers.includes(a));
    if (u || c) {
      const l = In(t.peers[a], e == null ? void 0 : e.keys);
      s.peers[a] = Object.assign(Object.assign({}, l), { peerId: a });
    }
  }
  return s;
}
function Qs(t, e) {
  if (t.isLoading !== e.isLoading || t.error !== e.error || (t.user || e.user) && (!t.user || !e.user || !On(t.user, e.user)) || !Gn(t.peers, e.peers))
    return !0;
  for (const r of Object.keys(t.peers))
    if (!On(t.peers[r], e.peers[r]))
      return !0;
  return !1;
}
class $n {
  constructor() {
    this.promise = new Promise((e, n) => {
      this._resolve = e, this._reject = n;
    });
  }
  resolve(e) {
    this._resolve(e);
  }
  reject(e) {
    this._reject(e);
  }
}
var Ye = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function a(l) {
      try {
        c(r.next(l));
      } catch (f) {
        o(f);
      }
    }
    function u(l) {
      try {
        c(r.throw(l));
      } catch (f) {
        o(f);
      }
    }
    function c(l) {
      l.done ? s(l.value) : i(l.value).then(a, u);
    }
    c((r = r.apply(t, e || [])).next());
  });
};
class Dn {
  constructor(e, n, r, i, s = (u) => JSON.stringify(u), o = (u) => JSON.parse(u), a = 100) {
    this._subs = [], this._persister = e, this._key = n, this._onMerge = i, this._loadedCbs = [], this._isLoading = !0, this.currentValue = r, this.toJSON = s, this.fromJSON = o, this._saveThrottleMs = a, this._pendingSaveCbs = [], this._version = 0, this._load();
  }
  _load() {
    return Ye(this, void 0, void 0, function* () {
      const e = this.fromJSON(yield this._persister.getItem(this._key));
      this._isLoading = !1, this._onMerge(e, this.currentValue);
      for (const n of this._loadedCbs)
        n();
    });
  }
  waitForLoaded() {
    return Ye(this, void 0, void 0, function* () {
      if (!this._isLoading)
        return;
      yield new Promise((n) => {
        this._loadedCbs.push(n);
      });
    });
  }
  isLoading() {
    return this._isLoading;
  }
  version() {
    return this._version;
  }
  waitForSync() {
    return Ye(this, void 0, void 0, function* () {
      if (!this._nextSave)
        return;
      yield new Promise((n) => {
        this._pendingSaveCbs.push(n);
      });
    });
  }
  _writeToStorage() {
    this._persister.setItem(this._key, this.toJSON(this.currentValue));
    for (const e of this._pendingSaveCbs)
      e();
    this._pendingSaveCbs.length = 0;
  }
  flush() {
    return Ye(this, void 0, void 0, function* () {
      this._nextSave && (clearTimeout(this._nextSave), this._writeToStorage());
    });
  }
  _enqueuePersist(e) {
    if (this._nextSave) {
      e && this._pendingSaveCbs.push(e);
      return;
    }
    this._nextSave = setTimeout(() => {
      this._nextSave = null, this._writeToStorage();
    }, this._saveThrottleMs);
  }
  set(e, n) {
    this._version++, this.currentValue = e(this.currentValue), this._isLoading ? this._loadedCbs.push(() => this._enqueuePersist(n)) : this._enqueuePersist(n);
    for (const r of this._subs)
      r(this.currentValue);
  }
  subscribe(e) {
    return this._subs.push(e), e(this.currentValue), () => {
      this._subs = this._subs.filter((n) => n !== e);
    };
  }
}
function pr(t, e = []) {
  t.forEach((n) => {
    const { data: r } = n, { "datalog-result": i } = r, { "join-rows": s } = i;
    for (const o of s)
      for (const a of o)
        e.push(a);
    pr(n["child-nodes"], e);
  });
}
function Un(t) {
  const e = [];
  return pr(t, e), e;
}
function Ks(t) {
  return Object.values(t.links).reduce((e, n) => {
    var r, i, s, o;
    return (r = e[s = n.forward.on]) !== null && r !== void 0 || (e[s] = {}), e[n.forward.on][n.forward.label] = {
      isForward: !0,
      isSingular: n.forward.has === "one",
      link: n
    }, (i = e[o = n.reverse.on]) !== null && i !== void 0 || (e[o] = {}), e[n.reverse.on][n.reverse.label] = {
      isForward: !1,
      isSingular: n.reverse.has === "one",
      link: n
    }, e;
  }, {});
}
const vr = "v0.17.3";
var L = function(t, e, n, r) {
  function i(s) {
    return s instanceof n ? s : new n(function(o) {
      o(s);
    });
  }
  return new (n || (n = Promise))(function(s, o) {
    function a(l) {
      try {
        c(r.next(l));
      } catch (f) {
        o(f);
      }
    }
    function u(l) {
      try {
        c(r.throw(l));
      } catch (f) {
        o(f);
      }
    }
    function c(l) {
      l.done ? s(l.value) : i(l.value).then(a, u);
    }
    c((r = r.apply(t, e || [])).next());
  });
};
const ve = {
  CONNECTING: "connecting",
  OPENED: "opened",
  AUTHENTICATED: "authenticated",
  CLOSED: "closed",
  ERRORED: "errored"
}, Ys = 3e4, Hs = 0, Ln = 1, Gs = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
}, jt = "_instant_oauth_redirect", Ct = "currentUser";
let Xs = 0;
function Zs(t) {
  const e = new WebSocket(t);
  return e._id = Xs++, e;
}
function eo() {
  return typeof window < "u" || typeof chrome < "u";
}
const Nn = {
  "set-presence": !0,
  "set-presence-ok": !0,
  "refresh-presence": !0
};
function to(t) {
  var e;
  const n = JSON.parse(t);
  for (const r in n) {
    const i = n[r];
    !((e = i == null ? void 0 : i.result) === null || e === void 0) && e.store && (i.result.store = ui(i.result.store));
  }
  return n;
}
function no(t) {
  var e;
  const n = {};
  for (const r in t) {
    const i = t[r], s = Object.assign({}, i);
    !((e = i.result) === null || e === void 0) && e.store && (s.result = Object.assign(Object.assign({}, i.result), { store: ai(i.result.store) })), n[r] = s;
  }
  return JSON.stringify(n);
}
class ro {
  constructor(e, n = fr, r = hr, i) {
    this._isOnline = !0, this._isShutdown = !1, this.status = ve.CONNECTING, this.queryCbs = {}, this.queryOnceDfds = {}, this.authCbs = [], this.attrsCbs = [], this.mutationErrorCbs = [], this.connectionStatusCbs = [], this.mutationDeferredStore = /* @__PURE__ */ new Map(), this._reconnectTimeoutId = null, this._reconnectTimeoutMs = 0, this._localIdPromises = {}, this._errorMessage = null, this._oauthCallbackResponse = null, this._linkIndex = null, this._rooms = {}, this._roomsPendingLeave = {}, this._presence = {}, this._broadcastQueue = [], this._broadcastSubs = {}, this._currentUserCached = { isLoading: !0, error: void 0, user: void 0 }, this._beforeUnloadCbs = [], this._dataForQueryCache = {}, this._onMergeQuerySubs = (s, o) => {
      const a = s || {}, u = Object.assign({}, o);
      Object.entries(o).forEach(([l, f]) => {
        var h;
        const v = (h = a == null ? void 0 : a[l]) === null || h === void 0 ? void 0 : h.result, b = f.result;
        v && !b && (u[l].result = v);
      }), Object.keys(a).filter((l) => !o[l]).slice(0, 10).forEach((l) => {
        u[l] = a[l];
      }), this.querySubs.set((l) => u), this.loadedNotifyAll();
    }, this._onMergePendingMutations = (s, o) => {
      const a = new Map([...s.entries(), ...o.entries()]);
      this.pendingMutations.set((c) => a), this.loadedNotifyAll(), this._rewriteMutations(this.attrs, s).forEach((c, l) => {
        !o.has(l) && !c["tx-id"] && this._sendMutation(l, c);
      });
    }, this.getPreviousResult = (s) => {
      const o = Y(s);
      return this.dataForQuery(o);
    }, this.notifyOne = (s) => {
      var o, a;
      const u = (o = this.queryCbs[s]) !== null && o !== void 0 ? o : [], c = (a = this._dataForQueryCache[s]) === null || a === void 0 ? void 0 : a.data, l = this.dataForQuery(s);
      l && (tt(l, c) || u.forEach((f) => f.cb(l)));
    }, this.notifyOneQueryOnce = (s) => {
      var o;
      const a = (o = this.queryOnceDfds[s]) !== null && o !== void 0 ? o : [], u = this.dataForQuery(s);
      a.forEach((c) => {
        this._completeQueryOnce(c.q, s, c.dfd), c.dfd.resolve(u);
      });
    }, this.notifyQueryError = (s, o) => {
      (this.queryCbs[s] || []).forEach((u) => u.cb({ error: o }));
    }, this.pushTx = (s) => {
      try {
        const o = Is({ attrs: this.optimisticAttrs(), schema: this.config.schema }, s);
        return this.pushOps(o);
      } catch (o) {
        return this.pushOps([], o);
      }
    }, this.pushOps = (s, o) => {
      const a = N(), u = {
        op: "transact",
        "tx-steps": s,
        error: o
      };
      this.pendingMutations.set((l) => (l.set(a, u), l));
      const c = new $n();
      return this.mutationDeferredStore.set(a, c), this._sendMutation(a, u), this.notifyAll(), c.promise;
    }, this._wsOnOpen = (s) => {
      const o = s.target;
      if (this._ws !== o) {
        F.info("[socket][open]", o._id, "skip; this is no longer the current ws");
        return;
      }
      F.info("[socket][open]", this._ws._id), this._setStatus(ve.OPENED), this.getCurrentUser().then((a) => {
        var u;
        this._trySend(N(), {
          op: "init",
          "app-id": this.config.appId,
          "refresh-token": (u = a.user) === null || u === void 0 ? void 0 : u.refresh_token,
          versions: this.versions,
          // If an admin token is provided for an app, we will
          // skip all permission checks. This is an advanced feature,
          // to let users write internal tools
          // This option is not exposed in `Config`, as it's
          // not ready for prme time
          "__admin-token": this.config.__adminToken
        });
      });
    }, this._wsOnMessage = (s) => {
      const o = s.target, a = JSON.parse(s.data.toString());
      if (this._ws !== o) {
        F.info("[socket][message]", o._id, a, "skip; this is no longer the current ws");
        return;
      }
      this._handleReceive(o._id, JSON.parse(s.data.toString()));
    }, this._wsOnError = (s) => {
      const o = s.target;
      if (this._ws !== o) {
        F.info("[socket][error]", o._id, "skip; this is no longer the current ws");
        return;
      }
      F.error("[socket][error]", o._id, s);
    }, this._wsOnClose = (s) => {
      const o = s.target;
      if (this._ws !== o) {
        F.info("[socket][close]", o._id, "skip; this is no longer the current ws");
        return;
      }
      this._setStatus(ve.CLOSED);
      for (const a of Object.values(this._rooms))
        a.isConnected = !1;
      if (this._isShutdown) {
        F.info("[socket][close]", o._id, "Reactor has been shut down and will not reconnect");
        return;
      }
      F.info("[socket][close]", o._id, "schedule reconnect, ms =", this._reconnectTimeoutMs), setTimeout(() => {
        if (this._reconnectTimeoutMs = Math.min(this._reconnectTimeoutMs + 1e3, 1e4), !this._isOnline) {
          F.info("[socket][close]", o._id, "we are offline, no need to start socket");
          return;
        }
        this._startSocket();
      }, this._reconnectTimeoutMs);
    }, this.config = Object.assign(Object.assign({}, Gs), e), this.versions = Object.assign(Object.assign({}, i || {}), { "@instantdb/core": vr }), this.config.schema && (this._linkIndex = Ks(this.config.schema)), eo() && (typeof BroadcastChannel == "function" && (this._broadcastChannel = new BroadcastChannel("@instantdb"), this._broadcastChannel.addEventListener("message", (s) => L(this, void 0, void 0, function* () {
      var o;
      if (((o = s.data) === null || o === void 0 ? void 0 : o.type) === "auth") {
        const a = yield this.getCurrentUser();
        this.updateUser(a.user);
      }
    }))), this._oauthCallbackResponse = this._oauthLoginInit(), this._initStorage(n), this.getCurrentUser(), r.getIsOnline().then((s) => {
      this._isOnline = s, this._startSocket(), r.listen((o) => {
        o !== this._isOnline && (F.info("[network] online =", o), this._isOnline = o, this._isOnline && this._startSocket());
      });
    }), typeof addEventListener < "u" && (this._beforeUnload = this._beforeUnload.bind(this), addEventListener("beforeunload", this._beforeUnload)));
  }
  _initStorage(e) {
    this._persister = new e(`instant_${this.config.appId}_5`), this.querySubs = new Dn(this._persister, "querySubs", {}, this._onMergeQuerySubs, no, to), this.pendingMutations = new Dn(this._persister, "pendingMutations", /* @__PURE__ */ new Map(), this._onMergePendingMutations, (n) => JSON.stringify([...n.entries()]), (n) => new Map(JSON.parse(n))), this._beforeUnloadCbs.push(() => {
      this.pendingMutations.flush(), this.querySubs.flush();
    });
  }
  _beforeUnload() {
    for (const e of this._beforeUnloadCbs)
      e();
  }
  /**
   * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status
   * @param string clientId
   * @param {{message?: string, hint?: string, error?: Error}} [errDetails]
   */
  _finishTransaction(e, n, r) {
    const i = this.mutationDeferredStore.get(n);
    this.mutationDeferredStore.delete(n);
    const s = e !== "error" && e !== "timeout";
    !i && !s && console.error("Mutation failed", Object.assign({ status: e, clientId: n }, r)), i && (s ? i.resolve({ status: e, clientId: n }) : i.reject(Object.assign({ status: e, clientId: n }, r)));
  }
  _setStatus(e, n) {
    this.status = e, this._errorMessage = n, this.notifyConnectionStatusSubs(e);
  }
  _flushEnqueuedRoomData(e) {
    var n, r;
    const i = (r = (n = this._presence[e]) === null || n === void 0 ? void 0 : n.result) === null || r === void 0 ? void 0 : r.user, s = this._broadcastQueue[e];
    if (this._broadcastQueue[e] = [], i && this._trySetPresence(e, i), s)
      for (const o of s) {
        const { topic: a, roomType: u, data: c } = o;
        this._tryBroadcast(e, u, a, c);
      }
  }
  _handleReceive(e, n) {
    var r, i, s, o;
    const a = !!this.config.schema && ("cardinalityInference" in this.config ? !!this.config.cardinalityInference : !0);
    switch (Nn[n.op] || F.info("[receive]", e, n.op, n), n.op) {
      case "init-ok":
        this._setStatus(ve.AUTHENTICATED), this._reconnectTimeoutMs = 0, this._setAttrs(n.attrs), this._flushPendingMessages(), this._sessionId = n["session-id"];
        for (const T of Object.keys(this._rooms))
          this._tryJoinRoom(T);
        break;
      case "add-query-exists":
        this.notifyOneQueryOnce(Y(n.q));
        break;
      case "add-query-ok":
        const { q: u, result: c } = n, l = Y(u), f = (i = (r = c == null ? void 0 : c[0]) === null || r === void 0 ? void 0 : r.data) === null || i === void 0 ? void 0 : i["page-info"], h = (o = (s = c == null ? void 0 : c[0]) === null || s === void 0 ? void 0 : s.data) === null || o === void 0 ? void 0 : o.aggregate, v = Un(c), b = $t(this.attrs, v, a, this._linkIndex);
        this.querySubs.set((T) => (T[l].result = { store: b, pageInfo: f, aggregate: h }, T)), this.notifyOne(l), this.notifyOneQueryOnce(l);
        break;
      case "refresh-ok":
        const { computations: m, attrs: E } = n;
        this._setAttrs(E);
        const S = m.map((T) => {
          var D, oe, X, Z;
          const we = T["instaql-query"], ae = T["instaql-result"], qe = Y(we), Fe = Un(ae), ze = $t(this.attrs, Fe, a, this._linkIndex), ht = (oe = (D = ae == null ? void 0 : ae[0]) === null || D === void 0 ? void 0 : D.data) === null || oe === void 0 ? void 0 : oe["page-info"], pt = (Z = (X = ae == null ? void 0 : ae[0]) === null || X === void 0 ? void 0 : X.data) === null || Z === void 0 ? void 0 : Z.aggregate;
          return { hash: qe, store: ze, pageInfo: ht, aggregate: pt };
        });
        S.forEach(({ hash: T, store: D, pageInfo: oe, aggregate: X }) => {
          this.querySubs.set((Z) => (Z[T].result = { store: D, pageInfo: oe, aggregate: X }, Z));
        }), S.forEach(({ hash: T }) => {
          this.notifyOne(T);
        });
        break;
      case "transact-ok":
        const { "client-event-id": y, "tx-id": g } = n, O = this._rewriteMutations(this.attrs, this.pendingMutations.currentValue).get(y);
        if (!O)
          break;
        this.pendingMutations.set((T) => (T.delete(y), T));
        const $ = O["tx-steps"];
        this.querySubs.set((T) => {
          var D;
          for (const [oe, X] of Object.entries(T)) {
            const Z = (D = X == null ? void 0 : X.result) === null || D === void 0 ? void 0 : D.store;
            if (!Z)
              continue;
            const we = Sn(Z, $);
            T[oe].result.store = we;
          }
          return T;
        });
        const W = O["tx-steps"].filter(([T, ...D]) => T === "add-attr").map(([T, D]) => D).concat(Object.values(this.attrs));
        this._setAttrs(W), this._finishTransaction("synced", y);
        break;
      case "refresh-presence":
        const se = n["room-id"];
        this._setPresencePeers(se, n.data), this._notifyPresenceSubs(se);
        break;
      case "server-broadcast":
        const Ce = n["room-id"], Le = n.topic;
        this._notifyBroadcastSubs(Ce, Le, n);
        break;
      case "join-room-ok":
        const he = n["room-id"], Ne = this._rooms[he];
        if (!Ne) {
          this._roomsPendingLeave[he] && (this._tryLeaveRoom(he), delete this._roomsPendingLeave[he]);
          break;
        }
        Ne.isConnected = !0, this._notifyPresenceSubs(he), this._flushEnqueuedRoomData(he);
        break;
      case "join-room-error":
        const Pe = n["room-id"], Q = this._rooms[Pe];
        Q && (Q.error = n.error), this._notifyPresenceSubs(Pe);
        break;
      case "error":
        this._handleReceiveError(n);
        break;
    }
  }
  /**
   * @param {'timeout' | 'error'} status
   * @param {string} eventId
   * @param {{message?: string, hint?: string, error?: Error}} errDetails
   */
  _handleMutationError(e, n, r) {
    const i = this.pendingMutations.currentValue.get(n);
    i && (e !== "timeout" || !i["tx-id"]) && (this.pendingMutations.set((s) => (s.delete(n), s)), this.notifyAll(), this.notifyAttrsSubs(), this.notifyMutationErrorSubs(r), this._finishTransaction(e, n, r));
  }
  _handleReceiveError(e) {
    var n, r, i, s;
    const o = e["client-event-id"], a = this.pendingMutations.currentValue.get(o), u = {
      message: e.message || "Uh-oh, something went wrong. Ping Joe & Stopa."
    };
    if (e.hint && (u.hint = e.hint), a) {
      const h = {
        message: e.message,
        hint: e.hint
      };
      this._handleMutationError("error", o, h);
      return;
    }
    const c = (n = e["original-event"]) === null || n === void 0 ? void 0 : n.q;
    if (c && ((r = e["original-event"]) === null || r === void 0 ? void 0 : r.op) === "add-query") {
      const h = Y(c);
      this.notifyQueryError(Y(c), u), this.notifyQueryOnceError(c, h, o, u);
      return;
    }
    if (((i = e["original-event"]) === null || i === void 0 ? void 0 : i.op) === "init") {
      if (e.type === "record-not-found" && ((s = e.hint) === null || s === void 0 ? void 0 : s["record-type"]) === "app-user") {
        this.changeCurrentUser(null);
        return;
      }
      this._setStatus(ve.ERRORED, u), this.notifyAll();
      return;
    }
    const f = Object.assign({}, e);
    delete f.message, delete f.hint, console.error(e.message, f), e.hint && console.error(`This error comes with some debugging information. Here it is: 
`, e.hint);
  }
  notifyQueryOnceError(e, n, r, i) {
    var s;
    const o = (s = this.queryOnceDfds[n]) === null || s === void 0 ? void 0 : s.find((a) => a.eventId === r);
    o && (o.dfd.reject(i), this._completeQueryOnce(e, n, o.dfd));
  }
  _setAttrs(e) {
    this.attrs = e.reduce((n, r) => (n[r.id] = r, n), {}), this.notifyAttrsSubs();
  }
  _startQuerySub(e, n) {
    const r = N();
    return this.querySubs.set((i) => (i[n] = i[n] || { q: e, result: null, eventId: r }, i)), this._trySendAuthed(r, { op: "add-query", q: e }), r;
  }
  /**
   *  When a user subscribes to a query the following side effects occur:
   *
   *  - We update querySubs to include the new query
   *  - We update queryCbs to include the new cb
   *  - If we already have a result for the query we call cb immediately
   *  - We send the server an `add-query` message
   *
   *  Returns an unsubscribe function
   */
  subscribeQuery(e, n) {
    var r;
    const i = Y(e), s = this.getPreviousResult(e);
    return s && n(s), this.queryCbs[i] = (r = this.queryCbs[i]) !== null && r !== void 0 ? r : [], this.queryCbs[i].push({ q: e, cb: n }), this._startQuerySub(e, i), () => {
      this._unsubQuery(e, i, n);
    };
  }
  queryOnce(e) {
    var n;
    const r = new $n();
    if (!this._isOnline)
      return r.reject(new Error("We can't run `queryOnce`, because the device is offline.")), r.promise;
    if (!this.querySubs)
      return r.reject(new Error("We can't run `queryOnce` on the backend. Use adminAPI.query instead: https://www.instantdb.com/docs/backend#query")), r.promise;
    const i = Y(e), s = this._startQuerySub(e, i);
    return this.queryOnceDfds[i] = (n = this.queryOnceDfds[i]) !== null && n !== void 0 ? n : [], this.queryOnceDfds[i].push({ q: e, dfd: r, eventId: s }), setTimeout(() => r.reject(new Error("Query timed out")), Ys), r.promise;
  }
  _completeQueryOnce(e, n, r) {
    this.queryOnceDfds[n] && (this.queryOnceDfds[n] = this.queryOnceDfds[n].filter((i) => i.dfd !== r), this._cleanupQuery(e, n));
  }
  _unsubQuery(e, n, r) {
    this.queryCbs[n] && (this.queryCbs[n] = this.queryCbs[n].filter((i) => i.cb !== r), this._cleanupQuery(e, n));
  }
  _cleanupQuery(e, n) {
    var r, i;
    !((r = this.queryCbs[n]) === null || r === void 0) && r.length || !((i = this.queryOnceDfds[n]) === null || i === void 0) && i.length || (delete this.queryCbs[n], delete this.queryOnceDfds[n], this._trySendAuthed(N(), { op: "remove-query", q: e }));
  }
  // When we `pushTx`, it's possible that we don't yet have `this.attrs`
  // This means that `tx-steps` in `pendingMutations` will include `add-attr`
  // commands for attrs that already exist.
  //
  // This will also affect `add-triple` and `retract-triple` which
  // reference attr-ids that do not match the server.
  //
  // We fix this by rewriting `tx-steps` in each `pendingMutation`.
  // We remove `add-attr` commands for attrs that already exist.
  // We update `add-triple` and `retract-triple` commands to use the
  // server attr-ids.
  _rewriteMutations(e, n) {
    if (!e)
      return n;
    const r = (u) => {
      const [c, l, f] = u["forward-identity"];
      return J(e, l, f);
    }, i = (u) => {
      const [c, l, f] = u["forward-identity"];
      return ye(e, l, f);
    }, s = { attrIdMap: {}, refSwapAttrIds: /* @__PURE__ */ new Set() }, o = (u) => {
      const c = [];
      for (const l of u) {
        const [f] = l;
        if (f === "add-attr") {
          const [v, b] = l, m = r(b);
          if (m) {
            s.attrIdMap[b.id] = m.id;
            continue;
          }
          if (b["value-type"] === "ref") {
            const E = i(b);
            if (E) {
              s.attrIdMap[b.id] = E.id, s.refSwapAttrIds.add(b.id);
              continue;
            }
          }
        }
        const h = hs(s, l);
        c.push(h);
      }
      return c;
    }, a = /* @__PURE__ */ new Map();
    for (const [u, c] of n.entries())
      a.set(u, Object.assign(Object.assign({}, c), { "tx-steps": o(c["tx-steps"]) }));
    return a;
  }
  // ---------------------------
  // Transact
  optimisticAttrs() {
    var e;
    const n = [
      ...this.pendingMutations.currentValue.values()
    ].flatMap((a) => a["tx-steps"]), r = new Set(n.filter(([a, u]) => a === "delete-attr").map(([a, u]) => u)), i = [];
    for (const [a, u] of n)
      if (a === "add-attr")
        i.push(u);
      else if (a === "update-attr" && u.id && (!((e = this.attrs) === null || e === void 0) && e[u.id])) {
        const c = Object.assign(Object.assign({}, this.attrs[u.id]), u);
        i.push(c);
      }
    const s = [
      ...Object.values(this.attrs || {}),
      ...i
    ].filter((a) => !r.has(a.id));
    return Object.fromEntries(s.map((a) => [a.id, a]));
  }
  /** Runs instaql on a query and a store */
  dataForQuery(e) {
    const n = this._errorMessage;
    if (n)
      return { error: n };
    if (!this.querySubs || !this.pendingMutations)
      return;
    const r = this.querySubs.version(), i = this.querySubs.currentValue, s = this.pendingMutations.version(), o = this.pendingMutations.currentValue, { q: a, result: u } = i[e] || {};
    if (!u)
      return;
    const c = this._dataForQueryCache[e];
    if (c && r === c.querySubVersion && s === c.pendingMutationsVersion)
      return c.data;
    const { store: l, pageInfo: f, aggregate: h } = u, b = [...this._rewriteMutations(l.attrs, o).values()].flatMap((S) => S["tx-steps"]), m = Sn(l, b), E = ls({ store: m, pageInfo: f, aggregate: h }, a);
    return this._dataForQueryCache[e] = {
      querySubVersion: r,
      pendingMutationsVersion: s,
      data: E
    }, E;
  }
  /** Re-compute all subscriptions */
  notifyAll() {
    Object.keys(this.queryCbs).forEach((e) => {
      this.notifyOne(e);
    });
  }
  loadedNotifyAll() {
    this.pendingMutations.isLoading() || this.querySubs.isLoading() || this.notifyAll();
  }
  shutdown() {
    this._isShutdown = !0, this._ws.close();
  }
  /**
   * Sends mutation to server and schedules a timeout to cancel it if
   * we don't hear back in time.
   * Note: If we're offline we don't schedule a timeout, we'll schedule it
   * later once we're back online and send the mutation again
   *
   */
  _sendMutation(e, n) {
    if (n.error) {
      this._handleMutationError("error", e, {
        error: n.error,
        message: n.error.message
      });
      return;
    }
    if (this.status !== ve.AUTHENTICATED) {
      this._finishTransaction("enqueued", e);
      return;
    }
    const r = Math.max(5e3, this.pendingMutations.currentValue.size * 5e3);
    this._isOnline ? (this._trySend(e, n), setTimeout(() => {
      this._finishTransaction("pending", e);
    }, 3e3), setTimeout(() => {
      this._isOnline && this._handleMutationError("timeout", e, {
        message: "transaction timed out"
      });
    }, r)) : this._finishTransaction("enqueued", e);
  }
  // ---------------------------
  // Websocket
  /** Send messages we accumulated while we were connecting */
  _flushPendingMessages() {
    Object.keys(this.queryCbs).map((i) => this.querySubs.currentValue[i]).filter((i) => i).forEach(({ eventId: i, q: s }) => {
      this._trySendAuthed(i, { op: "add-query", q: s });
    }), Object.values(this.queryOnceDfds).flat().forEach(({ eventId: i, q: s }) => {
      this._trySendAuthed(i, { op: "add-query", q: s });
    }), this._rewriteMutations(this.attrs, this.pendingMutations.currentValue).forEach((i, s) => {
      i["tx-id"] || this._sendMutation(s, i);
    });
  }
  _trySendAuthed(...e) {
    this.status === ve.AUTHENTICATED && this._trySend(...e);
  }
  _trySend(e, n, r) {
    this._ws.readyState === Ln && (Nn[n.op] || F.info("[send]", this._ws._id, n.op, n), this._ws.send(JSON.stringify(Object.assign({ "client-event-id": e }, n))));
  }
  _startSocket() {
    if (this._ws && this._ws.readyState == Hs) {
      F.info("[socket][start]", this._ws._id, "maintained as current ws, we were still in a connecting state");
      return;
    }
    const e = this._ws;
    this._ws = Zs(`${this.config.websocketURI}?app_id=${this.config.appId}`), this._ws.onopen = this._wsOnOpen, this._ws.onmessage = this._wsOnMessage, this._ws.onclose = this._wsOnClose, this._ws.onerror = this._wsOnError, F.info("[socket][start]", this._ws._id), (e == null ? void 0 : e.readyState) === Ln && (F.info("[socket][start]", this._ws._id, "close previous ws id = ", e._id), e.close());
  }
  /**
   * Given a key, returns a stable local id, unique to this device and app.
   *
   * This can be useful if you want to create guest ids for example.
   *
   * Note: If the user deletes their local storage, this id will change.
   *
   * We use this._localIdPromises to ensure that we only generate a local
   * id once, even if multiple callers call this function concurrently.
   */
  getLocalId(e) {
    return L(this, void 0, void 0, function* () {
      const n = `localToken_${e}`, r = yield this._persister.getItem(n);
      if (r)
        return r;
      if (this._localIdPromises[n])
        return this._localIdPromises[n];
      const i = N();
      return this._localIdPromises[n] = this._persister.setItem(n, i).then(() => i), this._localIdPromises[n];
    });
  }
  // ----
  // Auth
  _replaceUrlAfterOAuth() {
    if (typeof URL > "u")
      return;
    const e = new URL(window.location.href);
    if (e.searchParams.get(jt)) {
      const n = e.toString();
      e.searchParams.delete(jt), e.searchParams.delete("code"), e.searchParams.delete("error");
      const r = e.pathname + (e.searchParams.size ? "?" + e.searchParams : "") + e.hash;
      if (history.replaceState(history.state, "", r), // @ts-ignore (waiting for ts support)
      typeof navigation == "object" && // @ts-ignore (waiting for ts support)
      typeof navigation.addEventListener == "function" && // @ts-ignore (waiting for ts support)
      typeof navigation.removeEventListener == "function") {
        let i = !1;
        const s = (o) => {
          var a;
          i || (i = !0, navigation.removeEventListener("navigate", s), !o.userInitiated && o.navigationType === "replace" && ((a = o.destination) === null || a === void 0 ? void 0 : a.url) === n && history.replaceState(history.state, "", r));
        };
        navigation.addEventListener("navigate", s);
      }
    }
  }
  /**
   *
   * @returns Promise<null | {error: {message: string}}>
   */
  _oauthLoginInit() {
    return L(this, void 0, void 0, function* () {
      var e, n, r, i;
      if (typeof window > "u" || typeof window.location > "u" || typeof URLSearchParams > "u")
        return null;
      const s = new URLSearchParams(window.location.search);
      if (!s.get(jt))
        return null;
      const o = s.get("error");
      if (o)
        return this._replaceUrlAfterOAuth(), { error: { message: o } };
      const a = s.get("code");
      if (!a)
        return null;
      this._replaceUrlAfterOAuth();
      try {
        const { user: u } = yield kn({
          apiURI: this.config.apiURI,
          appId: this.config.appId,
          code: a
        });
        return this.setCurrentUser(u), null;
      } catch (u) {
        return ((e = u == null ? void 0 : u.body) === null || e === void 0 ? void 0 : e.type) === "record-not-found" && ((r = (n = u == null ? void 0 : u.body) === null || n === void 0 ? void 0 : n.hint) === null || r === void 0 ? void 0 : r["record-type"]) === "app-oauth-code" && (yield this._hasCurrentUser()) ? null : { error: { message: ((i = u == null ? void 0 : u.body) === null || i === void 0 ? void 0 : i.message) || "Error logging in." } };
      }
    });
  }
  _waitForOAuthCallbackResponse() {
    return L(this, void 0, void 0, function* () {
      return yield this._oauthCallbackResponse;
    });
  }
  __subscribeMutationErrors(e) {
    return this.mutationErrorCbs.push(e), () => {
      this.mutationErrorCbs = this.mutationErrorCbs.filter((n) => n !== e);
    };
  }
  subscribeAuth(e) {
    this.authCbs.push(e);
    const n = this._currentUserCached;
    n.isLoading || e(this._currentUserCached);
    let r = !1;
    return this.getCurrentUser().then((i) => {
      r || tt(i, n) || e(i);
    }), () => {
      r = !0, this.authCbs = this.authCbs.filter((i) => i !== e);
    };
  }
  subscribeConnectionStatus(e) {
    return this.connectionStatusCbs.push(e), () => {
      this.connectionStatusCbs = this.connectionStatusCbs.filter((n) => n !== e);
    };
  }
  subscribeAttrs(e) {
    return this.attrsCbs.push(e), this.attrs && e(this.attrs), () => {
      this.attrsCbs = this.attrsCbs.filter((n) => n !== e);
    };
  }
  notifyAuthSubs(e) {
    this.authCbs.forEach((n) => n(e));
  }
  notifyMutationErrorSubs(e) {
    this.mutationErrorCbs.forEach((n) => n(e));
  }
  notifyAttrsSubs() {
    if (!this.attrs)
      return;
    const e = this.optimisticAttrs();
    this.attrsCbs.forEach((n) => n(e));
  }
  notifyConnectionStatusSubs(e) {
    this.connectionStatusCbs.forEach((n) => n(e));
  }
  setCurrentUser(e) {
    return L(this, void 0, void 0, function* () {
      yield this._persister.setItem(Ct, JSON.stringify(e));
    });
  }
  getCurrentUserCached() {
    return this._currentUserCached;
  }
  getCurrentUser() {
    return L(this, void 0, void 0, function* () {
      const e = yield this._waitForOAuthCallbackResponse();
      if (e != null && e.error) {
        const i = { error: e.error, user: void 0 };
        return this._currentUserCached = Object.assign({ isLoading: !1 }, i), i;
      }
      const n = yield this._persister.getItem(Ct), r = { user: JSON.parse(n), error: void 0 };
      return this._currentUserCached = Object.assign({ isLoading: !1 }, r), r;
    });
  }
  _hasCurrentUser() {
    return L(this, void 0, void 0, function* () {
      const e = yield this._persister.getItem(Ct);
      return JSON.parse(e) != null;
    });
  }
  changeCurrentUser(e) {
    return L(this, void 0, void 0, function* () {
      var n;
      const { user: r } = yield this.getCurrentUser();
      if (!tt(r, e)) {
        yield this.setCurrentUser(e), this.updateUser(e);
        try {
          (n = this._broadcastChannel) === null || n === void 0 || n.postMessage({ type: "auth" });
        } catch (i) {
          console.error("Error posting message to broadcast channel", i);
        }
      }
    });
  }
  updateUser(e) {
    const n = { error: void 0, user: e };
    this._currentUserCached = Object.assign({ isLoading: !1 }, n), this._dataForQueryCache = {}, this.querySubs.set((r) => (Object.keys(r).forEach((i) => {
      delete r[i].result;
    }), r)), this._reconnectTimeoutMs = 0, this._ws.close(), this._oauthCallbackResponse = null, this.notifyAuthSubs(n);
  }
  sendMagicCode({ email: e }) {
    return Us({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email: e
    });
  }
  signInWithMagicCode(e) {
    return L(this, arguments, void 0, function* ({ email: n, code: r }) {
      const i = yield Ls({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        email: n,
        code: r
      });
      return yield this.changeCurrentUser(i.user), i;
    });
  }
  signInWithCustomToken(e) {
    return L(this, void 0, void 0, function* () {
      const n = yield Ns({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        refreshToken: e
      });
      return yield this.changeCurrentUser(n.user), n;
    });
  }
  signOut() {
    return L(this, void 0, void 0, function* () {
      var e;
      const n = yield this.getCurrentUser(), r = (e = n == null ? void 0 : n.user) === null || e === void 0 ? void 0 : e.refresh_token;
      if (r)
        try {
          yield Fs({
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            refreshToken: r
          });
        } catch {
        }
      yield this.changeCurrentUser(null);
    });
  }
  /**
   * Creates an OAuth authorization URL.
   * @param {Object} params - The parameters to create the authorization URL.
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.redirectURL - The URL to redirect users to after authorization.
   * @returns {string} The created authorization URL.
   */
  createAuthorizationURL({ clientName: e, redirectURL: n }) {
    const { apiURI: r, appId: i } = this.config;
    return `${r}/runtime/oauth/start?app_id=${i}&client_name=${e}&redirect_uri=${n}`;
  }
  exchangeCodeForToken(e) {
    return L(this, arguments, void 0, function* ({ code: n, codeVerifier: r }) {
      const i = yield kn({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        code: n,
        codeVerifier: r
      });
      return yield this.changeCurrentUser(i.user), i;
    });
  }
  issuerURI() {
    const { apiURI: e, appId: n } = this.config;
    return `${e}/runtime/${n}`;
  }
  /**
   * @param {Object} params
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.idToken - The id_token from the external service
   * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service
   */
  signInWithIdToken(e) {
    return L(this, arguments, void 0, function* ({ idToken: n, clientName: r, nonce: i }) {
      var s;
      const o = yield this.getCurrentUser(), a = (s = o == null ? void 0 : o.user) === null || s === void 0 ? void 0 : s.refresh_token, u = yield qs({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        idToken: n,
        clientName: r,
        nonce: i,
        refreshToken: a
      });
      return yield this.changeCurrentUser(u.user), u;
    });
  }
  // --------
  // Rooms
  joinRoom(e) {
    return this._rooms[e] || (this._rooms[e] = {
      isConnected: !1,
      error: void 0
    }), this._presence[e] = this._presence[e] || {}, this._tryJoinRoom(e), () => {
      this._cleanupRoom(e);
    };
  }
  _cleanupRoom(e) {
    var n, r, i, s;
    if (!(!((r = (n = this._presence[e]) === null || n === void 0 ? void 0 : n.handlers) === null || r === void 0) && r.length) && !Object.keys((i = this._broadcastSubs[e]) !== null && i !== void 0 ? i : {}).length) {
      const o = (s = this._rooms[e]) === null || s === void 0 ? void 0 : s.isConnected;
      delete this._rooms[e], delete this._presence[e], delete this._broadcastSubs[e], o ? this._tryLeaveRoom(e) : this._roomsPendingLeave[e] = !0;
    }
  }
  // --------
  // Presence
  // TODO: look into typing again
  getPresence(e, n, r = {}) {
    const i = this._rooms[n], s = this._presence[n];
    return !i || !s || !s.result ? null : Object.assign(Object.assign({}, Js(s.result, r, this._sessionId)), { isLoading: !i.isConnected, error: i.error });
  }
  // TODO: look into typing again
  publishPresence(e, n, r) {
    const i = this._rooms[n], s = this._presence[n];
    if (!i || !s)
      return;
    s.result = s.result || {};
    const o = Object.assign(Object.assign({}, s.result.user), r);
    s.result.user = o, i.isConnected && (this._trySetPresence(n, o), this._notifyPresenceSubs(n));
  }
  _trySetPresence(e, n) {
    this._trySendAuthed(N(), {
      op: "set-presence",
      "room-id": e,
      data: n
    });
  }
  _tryJoinRoom(e) {
    this._trySendAuthed(N(), { op: "join-room", "room-id": e }), delete this._roomsPendingLeave[e];
  }
  _tryLeaveRoom(e) {
    this._trySendAuthed(N(), { op: "leave-room", "room-id": e });
  }
  // TODO: look into typing again
  subscribePresence(e, n, r, i) {
    const s = this.joinRoom(n), o = Object.assign(Object.assign({}, r), { roomId: n, cb: i, prev: null });
    return this._presence[n] = this._presence[n] || {}, this._presence[n].handlers = this._presence[n].handlers || [], this._presence[n].handlers.push(o), this._notifyPresenceSub(n, o), () => {
      var a, u, c;
      this._presence[n].handlers = (c = (u = (a = this._presence[n]) === null || a === void 0 ? void 0 : a.handlers) === null || u === void 0 ? void 0 : u.filter((l) => l !== o)) !== null && c !== void 0 ? c : [], s();
    };
  }
  _notifyPresenceSubs(e) {
    var n, r;
    (r = (n = this._presence[e]) === null || n === void 0 ? void 0 : n.handlers) === null || r === void 0 || r.forEach((i) => {
      this._notifyPresenceSub(e, i);
    });
  }
  _notifyPresenceSub(e, n) {
    const r = this.getPresence("", e, n);
    r && (n.prev && !Qs(r, n.prev) || (n.prev = r, n.cb(r)));
  }
  _setPresencePeers(e, n) {
    const r = Object.assign({}, n);
    delete r[this._sessionId];
    const i = Object.fromEntries(Object.entries(r).map(([s, o]) => [s, o.data]));
    this._presence[e] = this._presence[e] || {}, this._presence[e].result = this._presence[e].result || {}, this._presence[e].result.peers = i;
  }
  // --------
  // Broadcast
  publishTopic({ roomType: e, roomId: n, topic: r, data: i }) {
    var s;
    const o = this._rooms[n];
    if (o) {
      if (!o.isConnected) {
        this._broadcastQueue[n] = (s = this._broadcastQueue[n]) !== null && s !== void 0 ? s : [], this._broadcastQueue[n].push({ topic: r, roomType: e, data: i });
        return;
      }
      this._tryBroadcast(n, e, r, i);
    }
  }
  _tryBroadcast(e, n, r, i) {
    this._trySendAuthed(N(), {
      op: "client-broadcast",
      "room-id": e,
      roomType: n,
      topic: r,
      data: i
    });
  }
  subscribeTopic(e, n, r) {
    const i = this.joinRoom(e);
    return this._broadcastSubs[e] = this._broadcastSubs[e] || {}, this._broadcastSubs[e][n] = this._broadcastSubs[e][n] || [], this._broadcastSubs[e][n].push(r), this._presence[e] = this._presence[e] || {}, () => {
      this._broadcastSubs[e][n] = this._broadcastSubs[e][n].filter((s) => s !== r), this._broadcastSubs[e][n].length || delete this._broadcastSubs[e][n], i();
    };
  }
  _notifyBroadcastSubs(e, n, r) {
    var i, s, o;
    (o = (s = (i = this._broadcastSubs) === null || i === void 0 ? void 0 : i[e]) === null || s === void 0 ? void 0 : s[n]) === null || o === void 0 || o.forEach((a) => {
      var u, c, l, f, h, v;
      const b = (u = r.data) === null || u === void 0 ? void 0 : u.data, m = r.data["peer-id"] === this._sessionId ? (l = (c = this._presence[e]) === null || c === void 0 ? void 0 : c.result) === null || l === void 0 ? void 0 : l.user : (v = (h = (f = this._presence[e]) === null || f === void 0 ? void 0 : f.result) === null || h === void 0 ? void 0 : h.peers) === null || v === void 0 ? void 0 : v[r.data["peer-id"]];
      return a(b, m);
    });
  }
  // --------
  // Storage
  upload(e, n) {
    return L(this, void 0, void 0, function* () {
      var r;
      const i = yield this.getCurrentUser(), s = (r = i == null ? void 0 : i.user) === null || r === void 0 ? void 0 : r.refresh_token, o = e || n.name, a = yield zs({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        fileName: o,
        refreshToken: s
      });
      return yield Ws(a, n);
    });
  }
  getDownloadUrl(e) {
    return L(this, void 0, void 0, function* () {
      var n;
      const r = yield this.getCurrentUser(), i = (n = r == null ? void 0 : r.user) === null || n === void 0 ? void 0 : n.refresh_token;
      return yield Vs({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        path: e,
        refreshToken: i
      });
    });
  }
  deleteFile(e) {
    return L(this, void 0, void 0, function* () {
      var n;
      const r = yield this.getCurrentUser(), i = (n = r == null ? void 0 : r.user) === null || n === void 0 ? void 0 : n.refresh_token;
      return yield Bs({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        path: e,
        refreshToken: i
      });
    });
  }
}
class ce {
  constructor(e, n, r = { indexed: !1, unique: !1 }) {
    this.valueType = e, this.required = n, this.config = r;
  }
  optional() {
    return new ce(this.valueType, !1);
  }
  unique() {
    return new ce(this.valueType, this.required, Object.assign(Object.assign({}, this.config), { unique: !0 }));
  }
  indexed() {
    return new ce(this.valueType, this.required, Object.assign(Object.assign({}, this.config), { indexed: !0 }));
  }
}
class dt {
  constructor(e, n) {
    this.attrs = e, this.links = n;
  }
  asType() {
    return new dt(this.attrs, this.links);
  }
}
class ft {
  constructor(e, n, r) {
    this.entities = e, this.links = n, this.rooms = r;
  }
  /**
   * @deprecated
   * `withRoomSchema` is deprecated. Define your schema in `rooms` directly:
   *
   * @example
   * // Before:
   * const schema = i.schema({
   *   // ...
   * }).withRoomSchema<RoomSchema>()
   *
   * // After
   * const schema = i.schema({
   *  rooms: {
   *    // ...
   *  }
   * })
   *
   * @see https://instantdb.com/docs/presence-and-topics#typesafety
   */
  withRoomSchema() {
    return new ft(this.entities, this.links, {});
  }
}
function io(t, e) {
  return new ft(
    _r(t, e),
    // (XXX): LinksDef<any> stems from TypeScript’s inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    e,
    void 0
  );
}
function so(t) {
  return new dt(t, {});
}
function oo() {
  return new ce("string", !0);
}
function ao() {
  return new ce("number", !0);
}
function uo() {
  return new ce("boolean", !0);
}
function co() {
  return new ce("date", !0);
}
function lo() {
  return new ce("json", !0);
}
function fo() {
  return new ce("json", !0);
}
function _r(t, e) {
  var n, r, i, s;
  const o = { fwd: {}, rev: {} };
  for (const u of Object.values(e))
    (n = o.fwd)[r = u.forward.on] || (n[r] = {}), (i = o.rev)[s = u.reverse.on] || (i[s] = {}), o.fwd[u.forward.on][u.forward.label] = {
      entityName: u.reverse.on,
      cardinality: u.forward.has
    }, o.rev[u.reverse.on][u.reverse.label] = {
      entityName: u.forward.on,
      cardinality: u.reverse.has
    };
  return Object.fromEntries(Object.entries(t).map(([u, c]) => [
    u,
    new dt(c.attrs, Object.assign(Object.assign({}, o.fwd[u]), o.rev[u]))
  ]));
}
function ho({ entities: t, links: e, rooms: n }) {
  const r = e ?? {}, i = n ?? {};
  return new ft(
    _r(t, r),
    // (XXX): LinksDef<any> stems from TypeScript’s inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    r,
    i
  );
}
const Qo = {
  // constructs
  graph: io,
  schema: ho,
  entity: so,
  // value types
  string: oo,
  number: ao,
  boolean: uo,
  date: co,
  json: lo,
  any: fo
};
let He;
function po(t) {
  He == null || He.dispose();
  const e = bo(), n = yo(o), r = _o(vo(t));
  function i(c) {
    var l;
    c.source === r.element.contentWindow && ((l = c.data) === null || l === void 0 ? void 0 : l.type) === "close" && e.isVisible() && o();
  }
  function s(c) {
    const l = c.shiftKey && c.ctrlKey && c.key === "0", f = c.key === "Escape" || c.key === "Esc";
    (l || f && e.isVisible()) && o();
  }
  function o() {
    e.isVisible() ? e.element.style.display = "none" : (e.element.style.display = "block", e.element.contains(r.element) || e.element.appendChild(r.element));
  }
  function a() {
    e.element.remove(), n.element.remove(), removeEventListener("keydown", s), removeEventListener("message", i);
  }
  function u() {
    document.body.appendChild(e.element), document.body.appendChild(n.element), addEventListener("keydown", s), addEventListener("message", i), He = {
      dispose: a
    };
  }
  return u();
}
function vo(t) {
  return `${window.DEV_DEVTOOL ? "http://localhost:3000" : "https://instantdb.com"}/_devtool?appId=${t}`;
}
function _o(t) {
  const e = document.createElement("iframe");
  return e.src = t, e.className = "instant-devtool-iframe", Object.assign(e.style, {
    width: "100%",
    height: "100%",
    borderRadius: "4px",
    backgroundColor: "white",
    border: "none"
  }), { element: e };
}
function yo(t) {
  const e = `
    <svg width="32" height="32" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect width="512" height="512" fill="black"/>
      <rect x="97.0973" y="91.3297" width="140" height="330" fill="white"/>
    </svg>
  `, n = document.createElement("button");
  return n.innerHTML = e, n.className = "instant-devtool-toggler", Object.assign(n.style, {
    // pos
    position: "fixed",
    bottom: "24px",
    left: "24px",
    height: "32px",
    width: "32px",
    // layout
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    // look
    padding: "0",
    margin: "0",
    border: "none",
    cursor: "pointer"
  }), n.addEventListener("click", t), { element: n };
}
function bo() {
  const t = document.createElement("div");
  Object.assign(t.style, {
    position: "fixed",
    bottom: "24px",
    right: "24px",
    left: "60px",
    top: "72px",
    display: "block",
    borderRadius: "4px",
    border: "1px #ccc solid",
    boxShadow: "0px 0px 8px #00000044",
    backgroundColor: "#eee",
    zIndex: "999990"
  }), t.style.display = "none", t.className = "instant-devtool-container";
  function e() {
    return t.style.display !== "none";
  }
  return { element: t, isVisible: e };
}
const go = !0, wo = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
};
function mo() {
  var t;
  return globalThis.__instantDbStore = (t = globalThis.__instantDbStore) !== null && t !== void 0 ? t : {}, globalThis.__instantDbStore;
}
const Bt = mo();
class Oo {
  constructor(e) {
    this.db = e, this.sendMagicCode = (n) => this.db.sendMagicCode(n), this.signInWithMagicCode = (n) => this.db.signInWithMagicCode(n), this.signInWithToken = (n) => this.db.signInWithCustomToken(n), this.createAuthorizationURL = (n) => this.db.createAuthorizationURL(n), this.signInWithIdToken = (n) => this.db.signInWithIdToken(n), this.exchangeOAuthCode = (n) => this.db.exchangeCodeForToken(n), this.issuerURI = () => this.db.issuerURI(), this.signOut = () => this.db.signOut();
  }
}
class So {
  constructor(e) {
    this.db = e, this.upload = (n, r) => this.db.upload(n, r), this.put = this.upload, this.getDownloadUrl = (n) => this.db.getDownloadUrl(n), this.delete = (n) => this.db.deleteFile(n);
  }
}
function Eo(t) {
  return JSON.parse(JSON.stringify(t));
}
class Ro {
  constructor(e) {
    this.tx = nn(), this._reactor = e, this.auth = new Oo(this._reactor), this.storage = new So(this._reactor);
  }
  /**
   * Use this to write data! You can create, update, delete, and link objects
   *
   * @see https://instantdb.com/docs/instaml
   *
   * @example
   *   // Create a new object in the `goals` namespace
   *   const goalId = id();
   *   db.transact(tx.goals[goalId].update({title: "Get fit"}))
   *
   *   // Update the title
   *   db.transact(tx.goals[goalId].update({title: "Get super fit"}))
   *
   *   // Delete it
   *   db.transact(tx.goals[goalId].delete())
   *
   *   // Or create an association:
   *   todoId = id();
   *   db.transact([
   *    tx.todos[todoId].update({ title: 'Go on a run' }),
   *    tx.goals[goalId].link({todos: todoId}),
   *  ])
   */
  transact(e) {
    return this._reactor.pushTx(e);
  }
  getLocalId(e) {
    return this._reactor.getLocalId(e);
  }
  /**
   * Use this to query your data!
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  // listen to all goals
   *  db.subscribeQuery({ goals: {} }, (resp) => {
   *    console.log(resp.data.goals)
   *  })
   *
   *  // goals where the title is "Get Fit"
   *  db.subscribeQuery(
   *    { goals: { $: { where: { title: "Get Fit" } } } },
   *    (resp) => {
   *      console.log(resp.data.goals)
   *    }
   *  )
   *
   *  // all goals, _alongside_ their todos
   *  db.subscribeQuery({ goals: { todos: {} } }, (resp) => {
   *    console.log(resp.data.goals)
   *  });
   */
  subscribeQuery(e, n) {
    return this._reactor.subscribeQuery(e, n);
  }
  /**
   * Listen for the logged in state. This is useful
   * for deciding when to show a login screen.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const unsub = db.subscribeAuth((auth) => {
   *     if (auth.user) {
   *     console.log('logged in as', auth.user.email)
   *    } else {
   *      console.log('logged out')
   *    }
   *  })
   */
  subscribeAuth(e) {
    return this._reactor.subscribeAuth(e);
  }
  /**
   * Listen for connection status changes to Instant. This is useful
   * for building things like connectivity indicators
   *
   * @see https://www.instantdb.com/docs/patterns#connection-status
   * @example
   *   const unsub = db.subscribeConnectionStatus((status) => {
   *     const connectionState =
   *       status === 'connecting' || status === 'opened'
   *         ? 'authenticating'
   *       : status === 'authenticated'
   *         ? 'connected'
   *       : status === 'closed'
   *         ? 'closed'
   *       : status === 'errored'
   *         ? 'errored'
   *       : 'unexpected state';
   *
   *     console.log('Connection status:', connectionState);
   *   });
   */
  subscribeConnectionStatus(e) {
    return this._reactor.subscribeConnectionStatus(e);
  }
  /**
   * Join a room to publish and subscribe to topics and presence.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   * @example
   * // init
   * const db = init();
   * const room = db.joinRoom(roomType, roomId);
   * // usage
   * const unsubscribeTopic = room.subscribeTopic("foo", console.log);
   * const unsubscribePresence = room.subscribePresence({}, console.log);
   * room.publishTopic("hello", { message: "hello world!" });
   * room.publishPresence({ name: "joe" });
   * // later
   * unsubscribePresence();
   * unsubscribeTopic();
   * room.leaveRoom();
   */
  joinRoom(e = "_defaultRoomType", n = "_defaultRoomId") {
    return {
      leaveRoom: this._reactor.joinRoom(n),
      subscribeTopic: (i, s) => this._reactor.subscribeTopic(n, i, s),
      subscribePresence: (i, s) => this._reactor.subscribePresence(e, n, i, s),
      publishTopic: (i, s) => this._reactor.publishTopic({ roomType: e, roomId: n, topic: i, data: s }),
      publishPresence: (i) => this._reactor.publishPresence(e, n, i),
      getPresence: (i) => this._reactor.getPresence(e, n, i)
    };
  }
  shutdown() {
    delete Bt[this._reactor.config.appId], this._reactor.shutdown();
  }
  /**
   * Use this for one-off queries.
   * Returns local data if available, otherwise fetches from the server.
   * Because we want to avoid stale data, this method will throw an error
   * if the user is offline or there is no active connection to the server.
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *
   *  const resp = await db.queryOnce({ goals: {} });
   *  console.log(resp.data.goals)
   */
  queryOnce(e) {
    return this._reactor.queryOnce(e);
  }
}
function jo(t, e, n, r) {
  const i = Bt[t.appId];
  if (i)
    return i;
  const s = new ro(Object.assign(Object.assign(Object.assign({}, wo), t), { cardinalityInference: !!t.schema }), e || fr, n || hr, Object.assign(Object.assign({}, r || {}), { "@instantdb/core": vr })), o = new Ro(s);
  return Bt[t.appId] = o, typeof window < "u" && typeof window.location < "u" && // show widget by default?
  ("devtool" in t ? t.devtool : go) && // only run on localhost (dev env)
  window.location.hostname === "localhost" && // used by dash and other internal consumers
  !globalThis._nodevtool && po(t.appId), o;
}
const Co = {
  isLoading: !0,
  data: void 0,
  pageInfo: void 0,
  error: void 0
};
function Po(t) {
  return {
    isLoading: !t,
    data: void 0,
    pageInfo: void 0,
    error: void 0,
    ...t || {}
  };
}
function To(t, e) {
  const n = e ? Eo(e) : null, r = Y(n), i = nt(Po(t._reactor.getPreviousResult(n))), s = rt(
    (a) => n ? t.subscribeQuery(n, (c) => {
      i.current = {
        isLoading: !c,
        data: void 0,
        pageInfo: void 0,
        error: void 0,
        ...c
      }, a();
    }) : () => {
    },
    // Build a new subscribe function if the query changes
    [r]
  );
  return { state: Pt(
    s,
    () => i.current,
    () => Co
  ), query: n };
}
function xo() {
  const t = nt(null);
  Se(() => {
    n();
  }, []);
  function e(r, i) {
    clearTimeout(t.current), t.current = setTimeout(i, r);
  }
  function n() {
    clearTimeout(t.current);
  }
  return { set: e, clear: n };
}
const Ao = 1e3;
class Mo {
  constructor(e, n, r) {
    this.useTopicEffect = (i, s) => {
      Se(() => this._core._reactor.subscribeTopic(
        this.id,
        i,
        (a, u) => {
          s(a, u);
        }
      ), [this.id, i]);
    }, this.usePublishTopic = (i) => (Se(() => this._core._reactor.joinRoom(this.id), [this.id]), rt(
      (o) => {
        this._core._reactor.publishTopic({
          roomType: this.type,
          roomId: this.id,
          topic: i,
          data: o
        });
      },
      [this.id, i]
    )), this.usePresence = (i = {}) => {
      var a, u;
      const [s, o] = zr(() => this._core._reactor.getPresence(this.type, this.id, i) ?? {
        peers: {},
        isLoading: !0
      });
      return Se(() => this._core._reactor.subscribePresence(
        this.type,
        this.id,
        i,
        (l) => {
          o(l);
        }
      ), [this.id, i.user, (a = i.peers) == null ? void 0 : a.join(), (u = i.keys) == null ? void 0 : u.join()]), {
        ...s,
        publishPresence: (c) => {
          this._core._reactor.publishPresence(this.type, this.id, c);
        }
      };
    }, this.useSyncPresence = (i, s) => {
      Se(() => this._core._reactor.joinRoom(this.id), [this.id]), Se(() => this._core._reactor.publishPresence(this.type, this.id, i), [this.type, this.id, s ?? JSON.stringify(i)]);
    }, this.useTypingIndicator = (i, s = {}) => {
      const o = xo(), a = this.usePresence({
        keys: [i]
      }), u = Wr(() => {
        const l = this._core._reactor.getPresence(
          this.type,
          this.id
        );
        return s != null && s.writeOnly ? [] : Object.values((l == null ? void 0 : l.peers) ?? {}).filter(
          (f) => f[i] === !0
        );
      }, [s == null ? void 0 : s.writeOnly, a]), c = (l) => {
        this._core._reactor.publishPresence(this.type, this.id, {
          [i]: l
        }), l && ((s == null ? void 0 : s.timeout) === null || (s == null ? void 0 : s.timeout) === 0 || o.set((s == null ? void 0 : s.timeout) ?? Ao, () => {
          this._core._reactor.publishPresence(this.type, this.id, {
            [i]: null
          });
        }));
      };
      return {
        active: u,
        setActive: (l) => {
          c(l);
        },
        inputProps: {
          onKeyDown: (l) => {
            const h = !((s == null ? void 0 : s.stopOnEnter) && l.key === "Enter");
            c(h);
          },
          onBlur: () => {
            c(!1);
          }
        }
      };
    }, this._core = e, this.type = n, this.id = r;
  }
}
const ko = {
  isLoading: !0,
  user: void 0,
  error: void 0
};
class Io {
  constructor(e, n) {
    this.tx = nn(), this.getLocalId = (r) => this._core.getLocalId(r), this.transact = (r) => this._core.transact(r), this.useQuery = (r) => To(this._core, r).state, this.useAuth = () => {
      const r = nt(
        this._core._reactor._currentUserCached
      ), i = rt((o) => this._core.subscribeAuth((u) => {
        r.current = { isLoading: !1, ...u }, o();
      }), []);
      return Pt(
        i,
        () => r.current,
        () => ko
      );
    }, this.useConnectionStatus = () => {
      const r = nt(this._core._reactor.status), i = rt((o) => this._core.subscribeConnectionStatus((u) => {
        u !== r.current && (r.current = u, o());
      }), []);
      return Pt(
        i,
        () => r.current,
        // For SSR, always return 'connecting' as the initial state
        () => "connecting"
      );
    }, this.queryOnce = (r) => this._core.queryOnce(r), this._core = jo(
      e,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.Storage,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.NetworkListener,
      n
    ), this.auth = this._core.auth, this.storage = this._core.storage;
  }
  /**
   * Obtain a handle to a room, which allows you to listen to topics and presence data
   *
   * If you don't provide a `type` or `id`, Instant will default to `_defaultRoomType` and `_defaultRoomId`
   * as the room type and id, respectively.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   *
   * @example
   *  const {
   *   useTopicEffect,
   *   usePublishTopic,
   *   useSyncPresence,
   *   useTypingIndicator,
   * } = db.room(roomType, roomId);
   */
  room(e = "_defaultRoomType", n = "_defaultRoomId") {
    return new Mo(this._core, e, n);
  }
}
class $o extends Io {
}
const Do = "v0.17.3";
function Uo(t) {
  return new $o(t, {
    "@instantdb/react": Do
  });
}
const Ko = Uo;
var Jt = { exports: {} }, Ae = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qn;
function Lo() {
  if (qn) return Ae;
  qn = 1;
  var t = Wn, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, u, c) {
    var l, f = {}, h = null, v = null;
    c !== void 0 && (h = "" + c), u.key !== void 0 && (h = "" + u.key), u.ref !== void 0 && (v = u.ref);
    for (l in u) r.call(u, l) && !s.hasOwnProperty(l) && (f[l] = u[l]);
    if (a && a.defaultProps) for (l in u = a.defaultProps, u) f[l] === void 0 && (f[l] = u[l]);
    return { $$typeof: e, type: a, key: h, ref: v, props: f, _owner: i.current };
  }
  return Ae.Fragment = n, Ae.jsx = o, Ae.jsxs = o, Ae;
}
var Me = {}, Fn;
function No() {
  if (Fn) return Me;
  Fn = 1;
  var t = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return t.NODE_ENV !== "production" && function() {
    var e = Wn, n = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), u = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), b = Symbol.for("react.offscreen"), m = Symbol.iterator, E = "@@iterator";
    function S(d) {
      if (d === null || typeof d != "object")
        return null;
      var p = m && d[m] || d[E];
      return typeof p == "function" ? p : null;
    }
    var y = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function g(d) {
      {
        for (var p = arguments.length, _ = new Array(p > 1 ? p - 1 : 0), w = 1; w < p; w++)
          _[w - 1] = arguments[w];
        A("error", d, _);
      }
    }
    function A(d, p, _) {
      {
        var w = y.ReactDebugCurrentFrame, P = w.getStackAddendum();
        P !== "" && (p += "%s", _ = _.concat([P]));
        var x = _.map(function(C) {
          return String(C);
        });
        x.unshift("Warning: " + p), Function.prototype.apply.call(console[d], console, x);
      }
    }
    var O = !1, $ = !1, W = !1, se = !1, Ce = !1, Le;
    Le = Symbol.for("react.module.reference");
    function he(d) {
      return !!(typeof d == "string" || typeof d == "function" || d === i || d === o || Ce || d === s || d === l || d === f || se || d === b || O || $ || W || typeof d == "object" && d !== null && (d.$$typeof === v || d.$$typeof === h || d.$$typeof === a || d.$$typeof === u || d.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      d.$$typeof === Le || d.getModuleId !== void 0));
    }
    function Ne(d, p, _) {
      var w = d.displayName;
      if (w)
        return w;
      var P = p.displayName || p.name || "";
      return P !== "" ? _ + "(" + P + ")" : _;
    }
    function Pe(d) {
      return d.displayName || "Context";
    }
    function Q(d) {
      if (d == null)
        return null;
      if (typeof d.tag == "number" && g("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof d == "function")
        return d.displayName || d.name || null;
      if (typeof d == "string")
        return d;
      switch (d) {
        case i:
          return "Fragment";
        case r:
          return "Portal";
        case o:
          return "Profiler";
        case s:
          return "StrictMode";
        case l:
          return "Suspense";
        case f:
          return "SuspenseList";
      }
      if (typeof d == "object")
        switch (d.$$typeof) {
          case u:
            var p = d;
            return Pe(p) + ".Consumer";
          case a:
            var _ = d;
            return Pe(_._context) + ".Provider";
          case c:
            return Ne(d, d.render, "ForwardRef");
          case h:
            var w = d.displayName || null;
            return w !== null ? w : Q(d.type) || "Memo";
          case v: {
            var P = d, x = P._payload, C = P._init;
            try {
              return Q(C(x));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var T = Object.assign, D = 0, oe, X, Z, we, ae, qe, Fe;
    function ze() {
    }
    ze.__reactDisabledLog = !0;
    function ht() {
      {
        if (D === 0) {
          oe = console.log, X = console.info, Z = console.warn, we = console.error, ae = console.group, qe = console.groupCollapsed, Fe = console.groupEnd;
          var d = {
            configurable: !0,
            enumerable: !0,
            value: ze,
            writable: !0
          };
          Object.defineProperties(console, {
            info: d,
            log: d,
            warn: d,
            error: d,
            group: d,
            groupCollapsed: d,
            groupEnd: d
          });
        }
        D++;
      }
    }
    function pt() {
      {
        if (D--, D === 0) {
          var d = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: T({}, d, {
              value: oe
            }),
            info: T({}, d, {
              value: X
            }),
            warn: T({}, d, {
              value: Z
            }),
            error: T({}, d, {
              value: we
            }),
            group: T({}, d, {
              value: ae
            }),
            groupCollapsed: T({}, d, {
              value: qe
            }),
            groupEnd: T({}, d, {
              value: Fe
            })
          });
        }
        D < 0 && g("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var vt = y.ReactCurrentDispatcher, _t;
    function We(d, p, _) {
      {
        if (_t === void 0)
          try {
            throw Error();
          } catch (P) {
            var w = P.stack.trim().match(/\n( *(at )?)/);
            _t = w && w[1] || "";
          }
        return `
` + _t + d;
      }
    }
    var yt = !1, Ve;
    {
      var yr = typeof WeakMap == "function" ? WeakMap : Map;
      Ve = new yr();
    }
    function rn(d, p) {
      if (!d || yt)
        return "";
      {
        var _ = Ve.get(d);
        if (_ !== void 0)
          return _;
      }
      var w;
      yt = !0;
      var P = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var x;
      x = vt.current, vt.current = null, ht();
      try {
        if (p) {
          var C = function() {
            throw Error();
          };
          if (Object.defineProperty(C.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(C, []);
            } catch (V) {
              w = V;
            }
            Reflect.construct(d, [], C);
          } else {
            try {
              C.call();
            } catch (V) {
              w = V;
            }
            d.call(C.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (V) {
            w = V;
          }
          d();
        }
      } catch (V) {
        if (V && w && typeof V.stack == "string") {
          for (var R = V.stack.split(`
`), q = w.stack.split(`
`), M = R.length - 1, I = q.length - 1; M >= 1 && I >= 0 && R[M] !== q[I]; )
            I--;
          for (; M >= 1 && I >= 0; M--, I--)
            if (R[M] !== q[I]) {
              if (M !== 1 || I !== 1)
                do
                  if (M--, I--, I < 0 || R[M] !== q[I]) {
                    var ee = `
` + R[M].replace(" at new ", " at ");
                    return d.displayName && ee.includes("<anonymous>") && (ee = ee.replace("<anonymous>", d.displayName)), typeof d == "function" && Ve.set(d, ee), ee;
                  }
                while (M >= 1 && I >= 0);
              break;
            }
        }
      } finally {
        yt = !1, vt.current = x, pt(), Error.prepareStackTrace = P;
      }
      var Oe = d ? d.displayName || d.name : "", pe = Oe ? We(Oe) : "";
      return typeof d == "function" && Ve.set(d, pe), pe;
    }
    function br(d, p, _) {
      return rn(d, !1);
    }
    function gr(d) {
      var p = d.prototype;
      return !!(p && p.isReactComponent);
    }
    function Be(d, p, _) {
      if (d == null)
        return "";
      if (typeof d == "function")
        return rn(d, gr(d));
      if (typeof d == "string")
        return We(d);
      switch (d) {
        case l:
          return We("Suspense");
        case f:
          return We("SuspenseList");
      }
      if (typeof d == "object")
        switch (d.$$typeof) {
          case c:
            return br(d.render);
          case h:
            return Be(d.type, p, _);
          case v: {
            var w = d, P = w._payload, x = w._init;
            try {
              return Be(x(P), p, _);
            } catch {
            }
          }
        }
      return "";
    }
    var Te = Object.prototype.hasOwnProperty, sn = {}, on = y.ReactDebugCurrentFrame;
    function Je(d) {
      if (d) {
        var p = d._owner, _ = Be(d.type, d._source, p ? p.type : null);
        on.setExtraStackFrame(_);
      } else
        on.setExtraStackFrame(null);
    }
    function wr(d, p, _, w, P) {
      {
        var x = Function.call.bind(Te);
        for (var C in d)
          if (x(d, C)) {
            var R = void 0;
            try {
              if (typeof d[C] != "function") {
                var q = Error((w || "React class") + ": " + _ + " type `" + C + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof d[C] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw q.name = "Invariant Violation", q;
              }
              R = d[C](p, C, w, _, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (M) {
              R = M;
            }
            R && !(R instanceof Error) && (Je(P), g("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", w || "React class", _, C, typeof R), Je(null)), R instanceof Error && !(R.message in sn) && (sn[R.message] = !0, Je(P), g("Failed %s type: %s", _, R.message), Je(null));
          }
      }
    }
    var mr = Array.isArray;
    function bt(d) {
      return mr(d);
    }
    function Or(d) {
      {
        var p = typeof Symbol == "function" && Symbol.toStringTag, _ = p && d[Symbol.toStringTag] || d.constructor.name || "Object";
        return _;
      }
    }
    function Sr(d) {
      try {
        return an(d), !1;
      } catch {
        return !0;
      }
    }
    function an(d) {
      return "" + d;
    }
    function un(d) {
      if (Sr(d))
        return g("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Or(d)), an(d);
    }
    var xe = y.ReactCurrentOwner, Er = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, cn, ln, gt;
    gt = {};
    function Rr(d) {
      if (Te.call(d, "ref")) {
        var p = Object.getOwnPropertyDescriptor(d, "ref").get;
        if (p && p.isReactWarning)
          return !1;
      }
      return d.ref !== void 0;
    }
    function jr(d) {
      if (Te.call(d, "key")) {
        var p = Object.getOwnPropertyDescriptor(d, "key").get;
        if (p && p.isReactWarning)
          return !1;
      }
      return d.key !== void 0;
    }
    function Cr(d, p) {
      if (typeof d.ref == "string" && xe.current && p && xe.current.stateNode !== p) {
        var _ = Q(xe.current.type);
        gt[_] || (g('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Q(xe.current.type), d.ref), gt[_] = !0);
      }
    }
    function Pr(d, p) {
      {
        var _ = function() {
          cn || (cn = !0, g("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", p));
        };
        _.isReactWarning = !0, Object.defineProperty(d, "key", {
          get: _,
          configurable: !0
        });
      }
    }
    function Tr(d, p) {
      {
        var _ = function() {
          ln || (ln = !0, g("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", p));
        };
        _.isReactWarning = !0, Object.defineProperty(d, "ref", {
          get: _,
          configurable: !0
        });
      }
    }
    var xr = function(d, p, _, w, P, x, C) {
      var R = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: n,
        // Built-in properties that belong on the element
        type: d,
        key: p,
        ref: _,
        props: C,
        // Record the component responsible for creating this element.
        _owner: x
      };
      return R._store = {}, Object.defineProperty(R._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(R, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: w
      }), Object.defineProperty(R, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: P
      }), Object.freeze && (Object.freeze(R.props), Object.freeze(R)), R;
    };
    function Ar(d, p, _, w, P) {
      {
        var x, C = {}, R = null, q = null;
        _ !== void 0 && (un(_), R = "" + _), jr(p) && (un(p.key), R = "" + p.key), Rr(p) && (q = p.ref, Cr(p, P));
        for (x in p)
          Te.call(p, x) && !Er.hasOwnProperty(x) && (C[x] = p[x]);
        if (d && d.defaultProps) {
          var M = d.defaultProps;
          for (x in M)
            C[x] === void 0 && (C[x] = M[x]);
        }
        if (R || q) {
          var I = typeof d == "function" ? d.displayName || d.name || "Unknown" : d;
          R && Pr(C, I), q && Tr(C, I);
        }
        return xr(d, R, q, P, w, xe.current, C);
      }
    }
    var wt = y.ReactCurrentOwner, dn = y.ReactDebugCurrentFrame;
    function me(d) {
      if (d) {
        var p = d._owner, _ = Be(d.type, d._source, p ? p.type : null);
        dn.setExtraStackFrame(_);
      } else
        dn.setExtraStackFrame(null);
    }
    var mt;
    mt = !1;
    function Ot(d) {
      return typeof d == "object" && d !== null && d.$$typeof === n;
    }
    function fn() {
      {
        if (wt.current) {
          var d = Q(wt.current.type);
          if (d)
            return `

Check the render method of \`` + d + "`.";
        }
        return "";
      }
    }
    function Mr(d) {
      return "";
    }
    var hn = {};
    function kr(d) {
      {
        var p = fn();
        if (!p) {
          var _ = typeof d == "string" ? d : d.displayName || d.name;
          _ && (p = `

Check the top-level render call using <` + _ + ">.");
        }
        return p;
      }
    }
    function pn(d, p) {
      {
        if (!d._store || d._store.validated || d.key != null)
          return;
        d._store.validated = !0;
        var _ = kr(p);
        if (hn[_])
          return;
        hn[_] = !0;
        var w = "";
        d && d._owner && d._owner !== wt.current && (w = " It was passed a child from " + Q(d._owner.type) + "."), me(d), g('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', _, w), me(null);
      }
    }
    function vn(d, p) {
      {
        if (typeof d != "object")
          return;
        if (bt(d))
          for (var _ = 0; _ < d.length; _++) {
            var w = d[_];
            Ot(w) && pn(w, p);
          }
        else if (Ot(d))
          d._store && (d._store.validated = !0);
        else if (d) {
          var P = S(d);
          if (typeof P == "function" && P !== d.entries)
            for (var x = P.call(d), C; !(C = x.next()).done; )
              Ot(C.value) && pn(C.value, p);
        }
      }
    }
    function Ir(d) {
      {
        var p = d.type;
        if (p == null || typeof p == "string")
          return;
        var _;
        if (typeof p == "function")
          _ = p.propTypes;
        else if (typeof p == "object" && (p.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        p.$$typeof === h))
          _ = p.propTypes;
        else
          return;
        if (_) {
          var w = Q(p);
          wr(_, d.props, "prop", w, d);
        } else if (p.PropTypes !== void 0 && !mt) {
          mt = !0;
          var P = Q(p);
          g("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", P || "Unknown");
        }
        typeof p.getDefaultProps == "function" && !p.getDefaultProps.isReactClassApproved && g("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function $r(d) {
      {
        for (var p = Object.keys(d.props), _ = 0; _ < p.length; _++) {
          var w = p[_];
          if (w !== "children" && w !== "key") {
            me(d), g("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", w), me(null);
            break;
          }
        }
        d.ref !== null && (me(d), g("Invalid attribute `ref` supplied to `React.Fragment`."), me(null));
      }
    }
    var _n = {};
    function yn(d, p, _, w, P, x) {
      {
        var C = he(d);
        if (!C) {
          var R = "";
          (d === void 0 || typeof d == "object" && d !== null && Object.keys(d).length === 0) && (R += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var q = Mr();
          q ? R += q : R += fn();
          var M;
          d === null ? M = "null" : bt(d) ? M = "array" : d !== void 0 && d.$$typeof === n ? (M = "<" + (Q(d.type) || "Unknown") + " />", R = " Did you accidentally export a JSX literal instead of a component?") : M = typeof d, g("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", M, R);
        }
        var I = Ar(d, p, _, P, x);
        if (I == null)
          return I;
        if (C) {
          var ee = p.children;
          if (ee !== void 0)
            if (w)
              if (bt(ee)) {
                for (var Oe = 0; Oe < ee.length; Oe++)
                  vn(ee[Oe], d);
                Object.freeze && Object.freeze(ee);
              } else
                g("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              vn(ee, d);
        }
        if (Te.call(p, "key")) {
          var pe = Q(d), V = Object.keys(p).filter(function(Fr) {
            return Fr !== "key";
          }), St = V.length > 0 ? "{key: someKey, " + V.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!_n[pe + St]) {
            var qr = V.length > 0 ? "{" + V.join(": ..., ") + ": ...}" : "{}";
            g(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, St, pe, qr, pe), _n[pe + St] = !0;
          }
        }
        return d === i ? $r(I) : Ir(I), I;
      }
    }
    function Dr(d, p, _) {
      return yn(d, p, _, !0);
    }
    function Ur(d, p, _) {
      return yn(d, p, _, !1);
    }
    var Lr = Ur, Nr = Dr;
    Me.Fragment = i, Me.jsx = Lr, Me.jsxs = Nr;
  }(), Me;
}
var qo = {};
qo.NODE_ENV === "production" ? Jt.exports = Lo() : Jt.exports = No();
var K = Jt.exports;
function Yo({
  as: t = "div",
  spaceId: e,
  room: n,
  className: r,
  style: i,
  userCursorColor: s,
  children: o,
  renderCursor: a,
  propagate: u,
  zIndex: c
}) {
  const l = e || `cursors-space-default--${String(n.type)}-${n.id}`, f = n.usePresence({
    keys: [l]
  }), h = n._core._reactor.getPresence(n.type, n.id);
  function v(y, g) {
    const A = g.clientX, O = g.clientY, $ = (A - y.left) / y.width * 100, W = (O - y.top) / y.height * 100;
    f.publishPresence({
      [l]: {
        x: A,
        y: O,
        xPercent: $,
        yPercent: W,
        color: s
      }
    });
  }
  function b(y) {
    u || y.stopPropagation();
    const g = y.currentTarget.getBoundingClientRect();
    v(g, y);
  }
  function m(y) {
    f.publishPresence({
      [l]: void 0
    });
  }
  function E(y) {
    if (y.touches.length !== 1)
      return;
    const g = y.touches[0];
    if (g.target instanceof Element) {
      u || y.stopPropagation();
      const A = g.target.getBoundingClientRect();
      v(A, g);
    }
  }
  function S(y) {
    f.publishPresence({
      [l]: void 0
    });
  }
  return Vr(
    t,
    {
      onMouseMove: b,
      onMouseOut: m,
      onTouchMove: E,
      onTouchEnd: S,
      className: r,
      style: {
        position: "relative",
        ...i
      }
    },
    [
      o,
      /* @__PURE__ */ K.jsx(
        "div",
        {
          style: {
            ...zn,
            ...zo,
            zIndex: c !== void 0 ? c : Wo
          },
          children: Object.entries(f.peers).map(([y, g]) => {
            const A = g[l];
            return A ? /* @__PURE__ */ K.jsx(
              "div",
              {
                style: {
                  ...zn,
                  transform: `translate(${A.xPercent}%, ${A.yPercent}%)`,
                  transformOrigin: "0 0",
                  transition: "transform 100ms"
                },
                children: a ? a({
                  color: A.color,
                  presence: h.peers[y]
                }) : /* @__PURE__ */ K.jsx(Fo, { ...A })
              },
              y
            ) : null;
          })
        },
        l
      )
    ]
  );
}
function Fo({ color: t }) {
  const n = t || "black";
  return /* @__PURE__ */ K.jsxs(
    "svg",
    {
      style: { height: 35, width: 35 },
      viewBox: "0 0 35 35",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [
        /* @__PURE__ */ K.jsxs(
          "g",
          {
            fill: "rgba(0,0,0,.2)",
            transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)",
            children: [
              /* @__PURE__ */ K.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
              /* @__PURE__ */ K.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
            ]
          }
        ),
        /* @__PURE__ */ K.jsxs(
          "g",
          {
            fill: "white",
            transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)",
            children: [
              /* @__PURE__ */ K.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
              /* @__PURE__ */ K.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
            ]
          }
        ),
        /* @__PURE__ */ K.jsxs(
          "g",
          {
            fill: n,
            transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)",
            children: [
              /* @__PURE__ */ K.jsx("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }),
              /* @__PURE__ */ K.jsx("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })
            ]
          }
        )
      ]
    }
  );
}
const zn = {
  position: "absolute",
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
}, zo = {
  overflow: "hidden",
  pointerEvents: "none",
  userSelect: "none"
}, Wo = 99999;
export {
  Yo as Cursors,
  Io as InstantReactAbstractDatabase,
  $o as InstantReactWebDatabase,
  Qo as i,
  N as id,
  Uo as init,
  Ko as init_experimental,
  Bo as lookup,
  Jo as tx
};
